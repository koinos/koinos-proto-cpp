// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: protocol.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 8000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "../common.capnp.h"

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(b686ce1dc2957e53);
CAPNP_DECLARE_SCHEMA(c28ae36fa3024a54);
CAPNP_DECLARE_SCHEMA(ac407886197419d8);
CAPNP_DECLARE_SCHEMA(acfa908737767d25);
CAPNP_DECLARE_SCHEMA(d9d889c84e65cfd8);
CAPNP_DECLARE_SCHEMA(f846d41d93e29448);
CAPNP_DECLARE_SCHEMA(db69d60b8cf04bd8);
CAPNP_DECLARE_SCHEMA(a46aea82397b275d);
CAPNP_DECLARE_SCHEMA(94dc38ecf0cf7112);
CAPNP_DECLARE_SCHEMA(e0a488f30c666d92);
CAPNP_DECLARE_SCHEMA(f9da41cfb2fdc55a);
CAPNP_DECLARE_SCHEMA(9d2e95ff1c6c3916);
CAPNP_DECLARE_SCHEMA(a5fa3ece1f52a4bc);
CAPNP_DECLARE_SCHEMA(f8b832c3c252679d);
CAPNP_DECLARE_SCHEMA(b38fcf154c2ca1c3);

}  // namespace schemas
}  // namespace capnp

namespace koinos {
namespace protocol {

struct UploadContractOperation {
  UploadContractOperation() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b686ce1dc2957e53, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CallContractOperation {
  CallContractOperation() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c28ae36fa3024a54, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SetSystemCallOperation {
  SetSystemCallOperation() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ac407886197419d8, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Operation {
  Operation() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Op;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(acfa908737767d25, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Operation::Op {
  Op() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    NOP,
    UPLOAD_CONTRACT,
    CALL_CONTRACT,
    SET_SYSTEM_CALL,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d9d889c84e65cfd8, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ActiveTransactionData {
  ActiveTransactionData() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f846d41d93e29448, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PassiveTransactionData {
  PassiveTransactionData() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(db69d60b8cf04bd8, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Transaction {
  Transaction() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct ActiveData;
  struct PassiveData;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a46aea82397b275d, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Transaction::ActiveData {
  ActiveData() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    NATIVE,
    BYTES,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(94dc38ecf0cf7112, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Transaction::PassiveData {
  PassiveData() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    NATIVE,
    BYTES,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e0a488f30c666d92, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ActiveBlockData {
  ActiveBlockData() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f9da41cfb2fdc55a, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PassiveBlockData {
  PassiveBlockData() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9d2e95ff1c6c3916, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockHeader {
  BlockHeader() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a5fa3ece1f52a4bc, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Block {
  Block() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f8b832c3c252679d, 0, 5)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockReceipt {
  BlockReceipt() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b38fcf154c2ca1c3, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class UploadContractOperation::Reader {
public:
  typedef UploadContractOperation Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContractID() const;
  inline  ::capnp::Data::Reader getContractID() const;

  inline bool hasBytecode() const;
  inline  ::capnp::Data::Reader getBytecode() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UploadContractOperation::Builder {
public:
  typedef UploadContractOperation Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContractID();
  inline  ::capnp::Data::Builder getContractID();
  inline void setContractID( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initContractID(unsigned int size);
  inline void adoptContractID(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownContractID();

  inline bool hasBytecode();
  inline  ::capnp::Data::Builder getBytecode();
  inline void setBytecode( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initBytecode(unsigned int size);
  inline void adoptBytecode(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownBytecode();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UploadContractOperation::Pipeline {
public:
  typedef UploadContractOperation Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CallContractOperation::Reader {
public:
  typedef CallContractOperation Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContractID() const;
  inline  ::capnp::Data::Reader getContractID() const;

  inline  ::uint32_t getEntryPoint() const;

  inline bool hasArgs() const;
  inline  ::capnp::Data::Reader getArgs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CallContractOperation::Builder {
public:
  typedef CallContractOperation Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContractID();
  inline  ::capnp::Data::Builder getContractID();
  inline void setContractID( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initContractID(unsigned int size);
  inline void adoptContractID(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownContractID();

  inline  ::uint32_t getEntryPoint();
  inline void setEntryPoint( ::uint32_t value);

  inline bool hasArgs();
  inline  ::capnp::Data::Builder getArgs();
  inline void setArgs( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initArgs(unsigned int size);
  inline void adoptArgs(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownArgs();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CallContractOperation::Pipeline {
public:
  typedef CallContractOperation Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SetSystemCallOperation::Reader {
public:
  typedef SetSystemCallOperation Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getCallID() const;

  inline bool hasTarget() const;
  inline  ::koinos::SystemCallTarget::Reader getTarget() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SetSystemCallOperation::Builder {
public:
  typedef SetSystemCallOperation Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getCallID();
  inline void setCallID( ::uint32_t value);

  inline bool hasTarget();
  inline  ::koinos::SystemCallTarget::Builder getTarget();
  inline void setTarget( ::koinos::SystemCallTarget::Reader value);
  inline  ::koinos::SystemCallTarget::Builder initTarget();
  inline void adoptTarget(::capnp::Orphan< ::koinos::SystemCallTarget>&& value);
  inline ::capnp::Orphan< ::koinos::SystemCallTarget> disownTarget();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SetSystemCallOperation::Pipeline {
public:
  typedef SetSystemCallOperation Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::koinos::SystemCallTarget::Pipeline getTarget();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Operation::Reader {
public:
  typedef Operation Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline typename Op::Reader getOp() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Operation::Builder {
public:
  typedef Operation Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline typename Op::Builder getOp();
  inline typename Op::Builder initOp();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Operation::Pipeline {
public:
  typedef Operation Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename Op::Pipeline getOp();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Operation::Op::Reader {
public:
  typedef Op Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isNop() const;
  inline  ::capnp::Void getNop() const;

  inline bool isUploadContract() const;
  inline bool hasUploadContract() const;
  inline  ::koinos::protocol::UploadContractOperation::Reader getUploadContract() const;

  inline bool isCallContract() const;
  inline bool hasCallContract() const;
  inline  ::koinos::protocol::CallContractOperation::Reader getCallContract() const;

  inline bool isSetSystemCall() const;
  inline bool hasSetSystemCall() const;
  inline  ::koinos::protocol::SetSystemCallOperation::Reader getSetSystemCall() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Operation::Op::Builder {
public:
  typedef Op Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isNop();
  inline  ::capnp::Void getNop();
  inline void setNop( ::capnp::Void value = ::capnp::VOID);

  inline bool isUploadContract();
  inline bool hasUploadContract();
  inline  ::koinos::protocol::UploadContractOperation::Builder getUploadContract();
  inline void setUploadContract( ::koinos::protocol::UploadContractOperation::Reader value);
  inline  ::koinos::protocol::UploadContractOperation::Builder initUploadContract();
  inline void adoptUploadContract(::capnp::Orphan< ::koinos::protocol::UploadContractOperation>&& value);
  inline ::capnp::Orphan< ::koinos::protocol::UploadContractOperation> disownUploadContract();

  inline bool isCallContract();
  inline bool hasCallContract();
  inline  ::koinos::protocol::CallContractOperation::Builder getCallContract();
  inline void setCallContract( ::koinos::protocol::CallContractOperation::Reader value);
  inline  ::koinos::protocol::CallContractOperation::Builder initCallContract();
  inline void adoptCallContract(::capnp::Orphan< ::koinos::protocol::CallContractOperation>&& value);
  inline ::capnp::Orphan< ::koinos::protocol::CallContractOperation> disownCallContract();

  inline bool isSetSystemCall();
  inline bool hasSetSystemCall();
  inline  ::koinos::protocol::SetSystemCallOperation::Builder getSetSystemCall();
  inline void setSetSystemCall( ::koinos::protocol::SetSystemCallOperation::Reader value);
  inline  ::koinos::protocol::SetSystemCallOperation::Builder initSetSystemCall();
  inline void adoptSetSystemCall(::capnp::Orphan< ::koinos::protocol::SetSystemCallOperation>&& value);
  inline ::capnp::Orphan< ::koinos::protocol::SetSystemCallOperation> disownSetSystemCall();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Operation::Op::Pipeline {
public:
  typedef Op Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ActiveTransactionData::Reader {
public:
  typedef ActiveTransactionData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResourceLimit() const;

  inline  ::uint64_t getNonce() const;

  inline bool hasOperations() const;
  inline  ::capnp::List< ::koinos::protocol::Operation,  ::capnp::Kind::STRUCT>::Reader getOperations() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ActiveTransactionData::Builder {
public:
  typedef ActiveTransactionData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResourceLimit();
  inline void setResourceLimit( ::capnp::Void value = ::capnp::VOID);

  inline  ::uint64_t getNonce();
  inline void setNonce( ::uint64_t value);

  inline bool hasOperations();
  inline  ::capnp::List< ::koinos::protocol::Operation,  ::capnp::Kind::STRUCT>::Builder getOperations();
  inline void setOperations( ::capnp::List< ::koinos::protocol::Operation,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::koinos::protocol::Operation,  ::capnp::Kind::STRUCT>::Builder initOperations(unsigned int size);
  inline void adoptOperations(::capnp::Orphan< ::capnp::List< ::koinos::protocol::Operation,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::koinos::protocol::Operation,  ::capnp::Kind::STRUCT>> disownOperations();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ActiveTransactionData::Pipeline {
public:
  typedef ActiveTransactionData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PassiveTransactionData::Reader {
public:
  typedef PassiveTransactionData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PassiveTransactionData::Builder {
public:
  typedef PassiveTransactionData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PassiveTransactionData::Pipeline {
public:
  typedef PassiveTransactionData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Transaction::Reader {
public:
  typedef Transaction Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasId() const;
  inline  ::capnp::Data::Reader getId() const;

  inline typename ActiveData::Reader getActiveData() const;

  inline typename PassiveData::Reader getPassiveData() const;

  inline bool hasSignatureData() const;
  inline  ::capnp::Data::Reader getSignatureData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Transaction::Builder {
public:
  typedef Transaction Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasId();
  inline  ::capnp::Data::Builder getId();
  inline void setId( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initId(unsigned int size);
  inline void adoptId(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownId();

  inline typename ActiveData::Builder getActiveData();
  inline typename ActiveData::Builder initActiveData();

  inline typename PassiveData::Builder getPassiveData();
  inline typename PassiveData::Builder initPassiveData();

  inline bool hasSignatureData();
  inline  ::capnp::Data::Builder getSignatureData();
  inline void setSignatureData( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initSignatureData(unsigned int size);
  inline void adoptSignatureData(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownSignatureData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Transaction::Pipeline {
public:
  typedef Transaction Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename ActiveData::Pipeline getActiveData();
  inline typename PassiveData::Pipeline getPassiveData();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Transaction::ActiveData::Reader {
public:
  typedef ActiveData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isNative() const;
  inline bool hasNative() const;
  inline  ::koinos::protocol::ActiveTransactionData::Reader getNative() const;

  inline bool isBytes() const;
  inline bool hasBytes() const;
  inline  ::capnp::Data::Reader getBytes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Transaction::ActiveData::Builder {
public:
  typedef ActiveData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isNative();
  inline bool hasNative();
  inline  ::koinos::protocol::ActiveTransactionData::Builder getNative();
  inline void setNative( ::koinos::protocol::ActiveTransactionData::Reader value);
  inline  ::koinos::protocol::ActiveTransactionData::Builder initNative();
  inline void adoptNative(::capnp::Orphan< ::koinos::protocol::ActiveTransactionData>&& value);
  inline ::capnp::Orphan< ::koinos::protocol::ActiveTransactionData> disownNative();

  inline bool isBytes();
  inline bool hasBytes();
  inline  ::capnp::Data::Builder getBytes();
  inline void setBytes( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initBytes(unsigned int size);
  inline void adoptBytes(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownBytes();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Transaction::ActiveData::Pipeline {
public:
  typedef ActiveData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Transaction::PassiveData::Reader {
public:
  typedef PassiveData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isNative() const;
  inline bool hasNative() const;
  inline  ::koinos::protocol::PassiveTransactionData::Reader getNative() const;

  inline bool isBytes() const;
  inline bool hasBytes() const;
  inline  ::capnp::Data::Reader getBytes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Transaction::PassiveData::Builder {
public:
  typedef PassiveData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isNative();
  inline bool hasNative();
  inline  ::koinos::protocol::PassiveTransactionData::Builder getNative();
  inline void setNative( ::koinos::protocol::PassiveTransactionData::Reader value);
  inline  ::koinos::protocol::PassiveTransactionData::Builder initNative();
  inline void adoptNative(::capnp::Orphan< ::koinos::protocol::PassiveTransactionData>&& value);
  inline ::capnp::Orphan< ::koinos::protocol::PassiveTransactionData> disownNative();

  inline bool isBytes();
  inline bool hasBytes();
  inline  ::capnp::Data::Builder getBytes();
  inline void setBytes( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initBytes(unsigned int size);
  inline void adoptBytes(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownBytes();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Transaction::PassiveData::Pipeline {
public:
  typedef PassiveData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ActiveBlockData::Reader {
public:
  typedef ActiveBlockData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTransactionMerkleRoot() const;
  inline  ::capnp::Data::Reader getTransactionMerkleRoot() const;

  inline bool hasPassiveDataMerkleRoot() const;
  inline  ::capnp::Data::Reader getPassiveDataMerkleRoot() const;

  inline bool hasSigner() const;
  inline  ::capnp::Data::Reader getSigner() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ActiveBlockData::Builder {
public:
  typedef ActiveBlockData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTransactionMerkleRoot();
  inline  ::capnp::Data::Builder getTransactionMerkleRoot();
  inline void setTransactionMerkleRoot( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initTransactionMerkleRoot(unsigned int size);
  inline void adoptTransactionMerkleRoot(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownTransactionMerkleRoot();

  inline bool hasPassiveDataMerkleRoot();
  inline  ::capnp::Data::Builder getPassiveDataMerkleRoot();
  inline void setPassiveDataMerkleRoot( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initPassiveDataMerkleRoot(unsigned int size);
  inline void adoptPassiveDataMerkleRoot(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownPassiveDataMerkleRoot();

  inline bool hasSigner();
  inline  ::capnp::Data::Builder getSigner();
  inline void setSigner( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initSigner(unsigned int size);
  inline void adoptSigner(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownSigner();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ActiveBlockData::Pipeline {
public:
  typedef ActiveBlockData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PassiveBlockData::Reader {
public:
  typedef PassiveBlockData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PassiveBlockData::Builder {
public:
  typedef PassiveBlockData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PassiveBlockData::Pipeline {
public:
  typedef PassiveBlockData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockHeader::Reader {
public:
  typedef BlockHeader Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPrevious() const;
  inline  ::capnp::Data::Reader getPrevious() const;

  inline  ::uint32_t getHeight() const;

  inline  ::uint64_t getTimestamp() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockHeader::Builder {
public:
  typedef BlockHeader Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPrevious();
  inline  ::capnp::Data::Builder getPrevious();
  inline void setPrevious( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initPrevious(unsigned int size);
  inline void adoptPrevious(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownPrevious();

  inline  ::uint32_t getHeight();
  inline void setHeight( ::uint32_t value);

  inline  ::uint64_t getTimestamp();
  inline void setTimestamp( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockHeader::Pipeline {
public:
  typedef BlockHeader Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Block::Reader {
public:
  typedef Block Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasId() const;
  inline  ::capnp::Data::Reader getId() const;

  inline bool hasHeader() const;
  inline  ::koinos::protocol::BlockHeader::Reader getHeader() const;

  inline bool hasActiveData() const;
  inline  ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>::Reader getActiveData() const;

  inline bool hasPassiveData() const;
  inline  ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>::Reader getPassiveData() const;

  inline bool hasSignatureData() const;
  inline  ::capnp::Data::Reader getSignatureData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Block::Builder {
public:
  typedef Block Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasId();
  inline  ::capnp::Data::Builder getId();
  inline void setId( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initId(unsigned int size);
  inline void adoptId(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownId();

  inline bool hasHeader();
  inline  ::koinos::protocol::BlockHeader::Builder getHeader();
  inline void setHeader( ::koinos::protocol::BlockHeader::Reader value);
  inline  ::koinos::protocol::BlockHeader::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::koinos::protocol::BlockHeader>&& value);
  inline ::capnp::Orphan< ::koinos::protocol::BlockHeader> disownHeader();

  inline bool hasActiveData();
  inline  ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>::Builder getActiveData();
  inline void setActiveData( ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>::Reader value);
  inline  ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>::Builder initActiveData();
  inline void adoptActiveData(::capnp::Orphan< ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>>&& value);
  inline ::capnp::Orphan< ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>> disownActiveData();

  inline bool hasPassiveData();
  inline  ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>::Builder getPassiveData();
  inline void setPassiveData( ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>::Reader value);
  inline  ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>::Builder initPassiveData();
  inline void adoptPassiveData(::capnp::Orphan< ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>>&& value);
  inline ::capnp::Orphan< ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>> disownPassiveData();

  inline bool hasSignatureData();
  inline  ::capnp::Data::Builder getSignatureData();
  inline void setSignatureData( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initSignatureData(unsigned int size);
  inline void adoptSignatureData(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownSignatureData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Block::Pipeline {
public:
  typedef Block Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::koinos::protocol::BlockHeader::Pipeline getHeader();
  inline  ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>::Pipeline getActiveData();
  inline  ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>::Pipeline getPassiveData();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockReceipt::Reader {
public:
  typedef BlockReceipt Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockReceipt::Builder {
public:
  typedef BlockReceipt Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockReceipt::Pipeline {
public:
  typedef BlockReceipt Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool UploadContractOperation::Reader::hasContractID() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool UploadContractOperation::Builder::hasContractID() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader UploadContractOperation::Reader::getContractID() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder UploadContractOperation::Builder::getContractID() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void UploadContractOperation::Builder::setContractID( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder UploadContractOperation::Builder::initContractID(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void UploadContractOperation::Builder::adoptContractID(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> UploadContractOperation::Builder::disownContractID() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool UploadContractOperation::Reader::hasBytecode() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool UploadContractOperation::Builder::hasBytecode() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader UploadContractOperation::Reader::getBytecode() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder UploadContractOperation::Builder::getBytecode() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void UploadContractOperation::Builder::setBytecode( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder UploadContractOperation::Builder::initBytecode(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void UploadContractOperation::Builder::adoptBytecode(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> UploadContractOperation::Builder::disownBytecode() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool CallContractOperation::Reader::hasContractID() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CallContractOperation::Builder::hasContractID() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader CallContractOperation::Reader::getContractID() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder CallContractOperation::Builder::getContractID() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CallContractOperation::Builder::setContractID( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder CallContractOperation::Builder::initContractID(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void CallContractOperation::Builder::adoptContractID(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> CallContractOperation::Builder::disownContractID() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t CallContractOperation::Reader::getEntryPoint() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CallContractOperation::Builder::getEntryPoint() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CallContractOperation::Builder::setEntryPoint( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool CallContractOperation::Reader::hasArgs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CallContractOperation::Builder::hasArgs() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader CallContractOperation::Reader::getArgs() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder CallContractOperation::Builder::getArgs() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CallContractOperation::Builder::setArgs( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder CallContractOperation::Builder::initArgs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void CallContractOperation::Builder::adoptArgs(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> CallContractOperation::Builder::disownArgs() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint32_t SetSystemCallOperation::Reader::getCallID() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t SetSystemCallOperation::Builder::getCallID() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void SetSystemCallOperation::Builder::setCallID( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool SetSystemCallOperation::Reader::hasTarget() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SetSystemCallOperation::Builder::hasTarget() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::koinos::SystemCallTarget::Reader SetSystemCallOperation::Reader::getTarget() const {
  return ::capnp::_::PointerHelpers< ::koinos::SystemCallTarget>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::koinos::SystemCallTarget::Builder SetSystemCallOperation::Builder::getTarget() {
  return ::capnp::_::PointerHelpers< ::koinos::SystemCallTarget>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::koinos::SystemCallTarget::Pipeline SetSystemCallOperation::Pipeline::getTarget() {
  return  ::koinos::SystemCallTarget::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void SetSystemCallOperation::Builder::setTarget( ::koinos::SystemCallTarget::Reader value) {
  ::capnp::_::PointerHelpers< ::koinos::SystemCallTarget>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::koinos::SystemCallTarget::Builder SetSystemCallOperation::Builder::initTarget() {
  return ::capnp::_::PointerHelpers< ::koinos::SystemCallTarget>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SetSystemCallOperation::Builder::adoptTarget(
    ::capnp::Orphan< ::koinos::SystemCallTarget>&& value) {
  ::capnp::_::PointerHelpers< ::koinos::SystemCallTarget>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::koinos::SystemCallTarget> SetSystemCallOperation::Builder::disownTarget() {
  return ::capnp::_::PointerHelpers< ::koinos::SystemCallTarget>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline typename Operation::Op::Reader Operation::Reader::getOp() const {
  return typename Operation::Op::Reader(_reader);
}
inline typename Operation::Op::Builder Operation::Builder::getOp() {
  return typename Operation::Op::Builder(_builder);
}
#if !CAPNP_LITE
inline typename Operation::Op::Pipeline Operation::Pipeline::getOp() {
  return typename Operation::Op::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename Operation::Op::Builder Operation::Builder::initOp() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename Operation::Op::Builder(_builder);
}
inline  ::koinos::protocol::Operation::Op::Which Operation::Op::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::koinos::protocol::Operation::Op::Which Operation::Op::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Operation::Op::Reader::isNop() const {
  return which() == Operation::Op::NOP;
}
inline bool Operation::Op::Builder::isNop() {
  return which() == Operation::Op::NOP;
}
inline  ::capnp::Void Operation::Op::Reader::getNop() const {
  KJ_IREQUIRE((which() == Operation::Op::NOP),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Operation::Op::Builder::getNop() {
  KJ_IREQUIRE((which() == Operation::Op::NOP),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Operation::Op::Builder::setNop( ::capnp::Void value) {
  _builder.setDataField<Operation::Op::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Operation::Op::NOP);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Operation::Op::Reader::isUploadContract() const {
  return which() == Operation::Op::UPLOAD_CONTRACT;
}
inline bool Operation::Op::Builder::isUploadContract() {
  return which() == Operation::Op::UPLOAD_CONTRACT;
}
inline bool Operation::Op::Reader::hasUploadContract() const {
  if (which() != Operation::Op::UPLOAD_CONTRACT) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Operation::Op::Builder::hasUploadContract() {
  if (which() != Operation::Op::UPLOAD_CONTRACT) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::koinos::protocol::UploadContractOperation::Reader Operation::Op::Reader::getUploadContract() const {
  KJ_IREQUIRE((which() == Operation::Op::UPLOAD_CONTRACT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::protocol::UploadContractOperation>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::koinos::protocol::UploadContractOperation::Builder Operation::Op::Builder::getUploadContract() {
  KJ_IREQUIRE((which() == Operation::Op::UPLOAD_CONTRACT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::protocol::UploadContractOperation>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Operation::Op::Builder::setUploadContract( ::koinos::protocol::UploadContractOperation::Reader value) {
  _builder.setDataField<Operation::Op::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Operation::Op::UPLOAD_CONTRACT);
  ::capnp::_::PointerHelpers< ::koinos::protocol::UploadContractOperation>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::koinos::protocol::UploadContractOperation::Builder Operation::Op::Builder::initUploadContract() {
  _builder.setDataField<Operation::Op::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Operation::Op::UPLOAD_CONTRACT);
  return ::capnp::_::PointerHelpers< ::koinos::protocol::UploadContractOperation>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Operation::Op::Builder::adoptUploadContract(
    ::capnp::Orphan< ::koinos::protocol::UploadContractOperation>&& value) {
  _builder.setDataField<Operation::Op::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Operation::Op::UPLOAD_CONTRACT);
  ::capnp::_::PointerHelpers< ::koinos::protocol::UploadContractOperation>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::koinos::protocol::UploadContractOperation> Operation::Op::Builder::disownUploadContract() {
  KJ_IREQUIRE((which() == Operation::Op::UPLOAD_CONTRACT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::protocol::UploadContractOperation>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Operation::Op::Reader::isCallContract() const {
  return which() == Operation::Op::CALL_CONTRACT;
}
inline bool Operation::Op::Builder::isCallContract() {
  return which() == Operation::Op::CALL_CONTRACT;
}
inline bool Operation::Op::Reader::hasCallContract() const {
  if (which() != Operation::Op::CALL_CONTRACT) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Operation::Op::Builder::hasCallContract() {
  if (which() != Operation::Op::CALL_CONTRACT) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::koinos::protocol::CallContractOperation::Reader Operation::Op::Reader::getCallContract() const {
  KJ_IREQUIRE((which() == Operation::Op::CALL_CONTRACT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::protocol::CallContractOperation>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::koinos::protocol::CallContractOperation::Builder Operation::Op::Builder::getCallContract() {
  KJ_IREQUIRE((which() == Operation::Op::CALL_CONTRACT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::protocol::CallContractOperation>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Operation::Op::Builder::setCallContract( ::koinos::protocol::CallContractOperation::Reader value) {
  _builder.setDataField<Operation::Op::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Operation::Op::CALL_CONTRACT);
  ::capnp::_::PointerHelpers< ::koinos::protocol::CallContractOperation>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::koinos::protocol::CallContractOperation::Builder Operation::Op::Builder::initCallContract() {
  _builder.setDataField<Operation::Op::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Operation::Op::CALL_CONTRACT);
  return ::capnp::_::PointerHelpers< ::koinos::protocol::CallContractOperation>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Operation::Op::Builder::adoptCallContract(
    ::capnp::Orphan< ::koinos::protocol::CallContractOperation>&& value) {
  _builder.setDataField<Operation::Op::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Operation::Op::CALL_CONTRACT);
  ::capnp::_::PointerHelpers< ::koinos::protocol::CallContractOperation>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::koinos::protocol::CallContractOperation> Operation::Op::Builder::disownCallContract() {
  KJ_IREQUIRE((which() == Operation::Op::CALL_CONTRACT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::protocol::CallContractOperation>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Operation::Op::Reader::isSetSystemCall() const {
  return which() == Operation::Op::SET_SYSTEM_CALL;
}
inline bool Operation::Op::Builder::isSetSystemCall() {
  return which() == Operation::Op::SET_SYSTEM_CALL;
}
inline bool Operation::Op::Reader::hasSetSystemCall() const {
  if (which() != Operation::Op::SET_SYSTEM_CALL) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Operation::Op::Builder::hasSetSystemCall() {
  if (which() != Operation::Op::SET_SYSTEM_CALL) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::koinos::protocol::SetSystemCallOperation::Reader Operation::Op::Reader::getSetSystemCall() const {
  KJ_IREQUIRE((which() == Operation::Op::SET_SYSTEM_CALL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::protocol::SetSystemCallOperation>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::koinos::protocol::SetSystemCallOperation::Builder Operation::Op::Builder::getSetSystemCall() {
  KJ_IREQUIRE((which() == Operation::Op::SET_SYSTEM_CALL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::protocol::SetSystemCallOperation>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Operation::Op::Builder::setSetSystemCall( ::koinos::protocol::SetSystemCallOperation::Reader value) {
  _builder.setDataField<Operation::Op::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Operation::Op::SET_SYSTEM_CALL);
  ::capnp::_::PointerHelpers< ::koinos::protocol::SetSystemCallOperation>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::koinos::protocol::SetSystemCallOperation::Builder Operation::Op::Builder::initSetSystemCall() {
  _builder.setDataField<Operation::Op::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Operation::Op::SET_SYSTEM_CALL);
  return ::capnp::_::PointerHelpers< ::koinos::protocol::SetSystemCallOperation>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Operation::Op::Builder::adoptSetSystemCall(
    ::capnp::Orphan< ::koinos::protocol::SetSystemCallOperation>&& value) {
  _builder.setDataField<Operation::Op::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Operation::Op::SET_SYSTEM_CALL);
  ::capnp::_::PointerHelpers< ::koinos::protocol::SetSystemCallOperation>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::koinos::protocol::SetSystemCallOperation> Operation::Op::Builder::disownSetSystemCall() {
  KJ_IREQUIRE((which() == Operation::Op::SET_SYSTEM_CALL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::protocol::SetSystemCallOperation>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::capnp::Void ActiveTransactionData::Reader::getResourceLimit() const {
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void ActiveTransactionData::Builder::getResourceLimit() {
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ActiveTransactionData::Builder::setResourceLimit( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t ActiveTransactionData::Reader::getNonce() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t ActiveTransactionData::Builder::getNonce() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ActiveTransactionData::Builder::setNonce( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool ActiveTransactionData::Reader::hasOperations() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ActiveTransactionData::Builder::hasOperations() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::koinos::protocol::Operation,  ::capnp::Kind::STRUCT>::Reader ActiveTransactionData::Reader::getOperations() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::koinos::protocol::Operation,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::koinos::protocol::Operation,  ::capnp::Kind::STRUCT>::Builder ActiveTransactionData::Builder::getOperations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::koinos::protocol::Operation,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ActiveTransactionData::Builder::setOperations( ::capnp::List< ::koinos::protocol::Operation,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::koinos::protocol::Operation,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::koinos::protocol::Operation,  ::capnp::Kind::STRUCT>::Builder ActiveTransactionData::Builder::initOperations(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::koinos::protocol::Operation,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ActiveTransactionData::Builder::adoptOperations(
    ::capnp::Orphan< ::capnp::List< ::koinos::protocol::Operation,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::koinos::protocol::Operation,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::koinos::protocol::Operation,  ::capnp::Kind::STRUCT>> ActiveTransactionData::Builder::disownOperations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::koinos::protocol::Operation,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Transaction::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Transaction::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader Transaction::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder Transaction::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Transaction::Builder::setId( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder Transaction::Builder::initId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Transaction::Builder::adoptId(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> Transaction::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline typename Transaction::ActiveData::Reader Transaction::Reader::getActiveData() const {
  return typename Transaction::ActiveData::Reader(_reader);
}
inline typename Transaction::ActiveData::Builder Transaction::Builder::getActiveData() {
  return typename Transaction::ActiveData::Builder(_builder);
}
#if !CAPNP_LITE
inline typename Transaction::ActiveData::Pipeline Transaction::Pipeline::getActiveData() {
  return typename Transaction::ActiveData::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename Transaction::ActiveData::Builder Transaction::Builder::initActiveData() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  return typename Transaction::ActiveData::Builder(_builder);
}
inline typename Transaction::PassiveData::Reader Transaction::Reader::getPassiveData() const {
  return typename Transaction::PassiveData::Reader(_reader);
}
inline typename Transaction::PassiveData::Builder Transaction::Builder::getPassiveData() {
  return typename Transaction::PassiveData::Builder(_builder);
}
#if !CAPNP_LITE
inline typename Transaction::PassiveData::Pipeline Transaction::Pipeline::getPassiveData() {
  return typename Transaction::PassiveData::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename Transaction::PassiveData::Builder Transaction::Builder::initPassiveData() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<2>() * ::capnp::POINTERS).clear();
  return typename Transaction::PassiveData::Builder(_builder);
}
inline bool Transaction::Reader::hasSignatureData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Transaction::Builder::hasSignatureData() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader Transaction::Reader::getSignatureData() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder Transaction::Builder::getSignatureData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Transaction::Builder::setSignatureData( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder Transaction::Builder::initSignatureData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void Transaction::Builder::adoptSignatureData(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> Transaction::Builder::disownSignatureData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline  ::koinos::protocol::Transaction::ActiveData::Which Transaction::ActiveData::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::koinos::protocol::Transaction::ActiveData::Which Transaction::ActiveData::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Transaction::ActiveData::Reader::isNative() const {
  return which() == Transaction::ActiveData::NATIVE;
}
inline bool Transaction::ActiveData::Builder::isNative() {
  return which() == Transaction::ActiveData::NATIVE;
}
inline bool Transaction::ActiveData::Reader::hasNative() const {
  if (which() != Transaction::ActiveData::NATIVE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Transaction::ActiveData::Builder::hasNative() {
  if (which() != Transaction::ActiveData::NATIVE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::koinos::protocol::ActiveTransactionData::Reader Transaction::ActiveData::Reader::getNative() const {
  KJ_IREQUIRE((which() == Transaction::ActiveData::NATIVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::protocol::ActiveTransactionData>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::koinos::protocol::ActiveTransactionData::Builder Transaction::ActiveData::Builder::getNative() {
  KJ_IREQUIRE((which() == Transaction::ActiveData::NATIVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::protocol::ActiveTransactionData>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Transaction::ActiveData::Builder::setNative( ::koinos::protocol::ActiveTransactionData::Reader value) {
  _builder.setDataField<Transaction::ActiveData::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Transaction::ActiveData::NATIVE);
  ::capnp::_::PointerHelpers< ::koinos::protocol::ActiveTransactionData>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::koinos::protocol::ActiveTransactionData::Builder Transaction::ActiveData::Builder::initNative() {
  _builder.setDataField<Transaction::ActiveData::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Transaction::ActiveData::NATIVE);
  return ::capnp::_::PointerHelpers< ::koinos::protocol::ActiveTransactionData>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Transaction::ActiveData::Builder::adoptNative(
    ::capnp::Orphan< ::koinos::protocol::ActiveTransactionData>&& value) {
  _builder.setDataField<Transaction::ActiveData::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Transaction::ActiveData::NATIVE);
  ::capnp::_::PointerHelpers< ::koinos::protocol::ActiveTransactionData>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::koinos::protocol::ActiveTransactionData> Transaction::ActiveData::Builder::disownNative() {
  KJ_IREQUIRE((which() == Transaction::ActiveData::NATIVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::protocol::ActiveTransactionData>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Transaction::ActiveData::Reader::isBytes() const {
  return which() == Transaction::ActiveData::BYTES;
}
inline bool Transaction::ActiveData::Builder::isBytes() {
  return which() == Transaction::ActiveData::BYTES;
}
inline bool Transaction::ActiveData::Reader::hasBytes() const {
  if (which() != Transaction::ActiveData::BYTES) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Transaction::ActiveData::Builder::hasBytes() {
  if (which() != Transaction::ActiveData::BYTES) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader Transaction::ActiveData::Reader::getBytes() const {
  KJ_IREQUIRE((which() == Transaction::ActiveData::BYTES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder Transaction::ActiveData::Builder::getBytes() {
  KJ_IREQUIRE((which() == Transaction::ActiveData::BYTES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Transaction::ActiveData::Builder::setBytes( ::capnp::Data::Reader value) {
  _builder.setDataField<Transaction::ActiveData::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Transaction::ActiveData::BYTES);
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder Transaction::ActiveData::Builder::initBytes(unsigned int size) {
  _builder.setDataField<Transaction::ActiveData::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Transaction::ActiveData::BYTES);
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Transaction::ActiveData::Builder::adoptBytes(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  _builder.setDataField<Transaction::ActiveData::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Transaction::ActiveData::BYTES);
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> Transaction::ActiveData::Builder::disownBytes() {
  KJ_IREQUIRE((which() == Transaction::ActiveData::BYTES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::koinos::protocol::Transaction::PassiveData::Which Transaction::PassiveData::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline  ::koinos::protocol::Transaction::PassiveData::Which Transaction::PassiveData::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool Transaction::PassiveData::Reader::isNative() const {
  return which() == Transaction::PassiveData::NATIVE;
}
inline bool Transaction::PassiveData::Builder::isNative() {
  return which() == Transaction::PassiveData::NATIVE;
}
inline bool Transaction::PassiveData::Reader::hasNative() const {
  if (which() != Transaction::PassiveData::NATIVE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Transaction::PassiveData::Builder::hasNative() {
  if (which() != Transaction::PassiveData::NATIVE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::koinos::protocol::PassiveTransactionData::Reader Transaction::PassiveData::Reader::getNative() const {
  KJ_IREQUIRE((which() == Transaction::PassiveData::NATIVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::protocol::PassiveTransactionData>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::koinos::protocol::PassiveTransactionData::Builder Transaction::PassiveData::Builder::getNative() {
  KJ_IREQUIRE((which() == Transaction::PassiveData::NATIVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::protocol::PassiveTransactionData>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Transaction::PassiveData::Builder::setNative( ::koinos::protocol::PassiveTransactionData::Reader value) {
  _builder.setDataField<Transaction::PassiveData::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Transaction::PassiveData::NATIVE);
  ::capnp::_::PointerHelpers< ::koinos::protocol::PassiveTransactionData>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::koinos::protocol::PassiveTransactionData::Builder Transaction::PassiveData::Builder::initNative() {
  _builder.setDataField<Transaction::PassiveData::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Transaction::PassiveData::NATIVE);
  return ::capnp::_::PointerHelpers< ::koinos::protocol::PassiveTransactionData>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Transaction::PassiveData::Builder::adoptNative(
    ::capnp::Orphan< ::koinos::protocol::PassiveTransactionData>&& value) {
  _builder.setDataField<Transaction::PassiveData::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Transaction::PassiveData::NATIVE);
  ::capnp::_::PointerHelpers< ::koinos::protocol::PassiveTransactionData>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::koinos::protocol::PassiveTransactionData> Transaction::PassiveData::Builder::disownNative() {
  KJ_IREQUIRE((which() == Transaction::PassiveData::NATIVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::protocol::PassiveTransactionData>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Transaction::PassiveData::Reader::isBytes() const {
  return which() == Transaction::PassiveData::BYTES;
}
inline bool Transaction::PassiveData::Builder::isBytes() {
  return which() == Transaction::PassiveData::BYTES;
}
inline bool Transaction::PassiveData::Reader::hasBytes() const {
  if (which() != Transaction::PassiveData::BYTES) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Transaction::PassiveData::Builder::hasBytes() {
  if (which() != Transaction::PassiveData::BYTES) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader Transaction::PassiveData::Reader::getBytes() const {
  KJ_IREQUIRE((which() == Transaction::PassiveData::BYTES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder Transaction::PassiveData::Builder::getBytes() {
  KJ_IREQUIRE((which() == Transaction::PassiveData::BYTES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Transaction::PassiveData::Builder::setBytes( ::capnp::Data::Reader value) {
  _builder.setDataField<Transaction::PassiveData::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Transaction::PassiveData::BYTES);
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder Transaction::PassiveData::Builder::initBytes(unsigned int size) {
  _builder.setDataField<Transaction::PassiveData::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Transaction::PassiveData::BYTES);
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Transaction::PassiveData::Builder::adoptBytes(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  _builder.setDataField<Transaction::PassiveData::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Transaction::PassiveData::BYTES);
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> Transaction::PassiveData::Builder::disownBytes() {
  KJ_IREQUIRE((which() == Transaction::PassiveData::BYTES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool ActiveBlockData::Reader::hasTransactionMerkleRoot() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ActiveBlockData::Builder::hasTransactionMerkleRoot() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader ActiveBlockData::Reader::getTransactionMerkleRoot() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder ActiveBlockData::Builder::getTransactionMerkleRoot() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ActiveBlockData::Builder::setTransactionMerkleRoot( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder ActiveBlockData::Builder::initTransactionMerkleRoot(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ActiveBlockData::Builder::adoptTransactionMerkleRoot(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> ActiveBlockData::Builder::disownTransactionMerkleRoot() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ActiveBlockData::Reader::hasPassiveDataMerkleRoot() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ActiveBlockData::Builder::hasPassiveDataMerkleRoot() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader ActiveBlockData::Reader::getPassiveDataMerkleRoot() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder ActiveBlockData::Builder::getPassiveDataMerkleRoot() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ActiveBlockData::Builder::setPassiveDataMerkleRoot( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder ActiveBlockData::Builder::initPassiveDataMerkleRoot(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void ActiveBlockData::Builder::adoptPassiveDataMerkleRoot(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> ActiveBlockData::Builder::disownPassiveDataMerkleRoot() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool ActiveBlockData::Reader::hasSigner() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool ActiveBlockData::Builder::hasSigner() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader ActiveBlockData::Reader::getSigner() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder ActiveBlockData::Builder::getSigner() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void ActiveBlockData::Builder::setSigner( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder ActiveBlockData::Builder::initSigner(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void ActiveBlockData::Builder::adoptSigner(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> ActiveBlockData::Builder::disownSigner() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool BlockHeader::Reader::hasPrevious() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockHeader::Builder::hasPrevious() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader BlockHeader::Reader::getPrevious() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder BlockHeader::Builder::getPrevious() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockHeader::Builder::setPrevious( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder BlockHeader::Builder::initPrevious(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BlockHeader::Builder::adoptPrevious(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> BlockHeader::Builder::disownPrevious() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t BlockHeader::Reader::getHeight() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t BlockHeader::Builder::getHeight() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BlockHeader::Builder::setHeight( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t BlockHeader::Reader::getTimestamp() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t BlockHeader::Builder::getTimestamp() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void BlockHeader::Builder::setTimestamp( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Block::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Block::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader Block::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder Block::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Block::Builder::setId( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder Block::Builder::initId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Block::Builder::adoptId(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> Block::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Block::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Block::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::koinos::protocol::BlockHeader::Reader Block::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::koinos::protocol::BlockHeader>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::koinos::protocol::BlockHeader::Builder Block::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::koinos::protocol::BlockHeader>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::koinos::protocol::BlockHeader::Pipeline Block::Pipeline::getHeader() {
  return  ::koinos::protocol::BlockHeader::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Block::Builder::setHeader( ::koinos::protocol::BlockHeader::Reader value) {
  ::capnp::_::PointerHelpers< ::koinos::protocol::BlockHeader>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::koinos::protocol::BlockHeader::Builder Block::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::koinos::protocol::BlockHeader>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Block::Builder::adoptHeader(
    ::capnp::Orphan< ::koinos::protocol::BlockHeader>&& value) {
  ::capnp::_::PointerHelpers< ::koinos::protocol::BlockHeader>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::koinos::protocol::BlockHeader> Block::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::koinos::protocol::BlockHeader>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Block::Reader::hasActiveData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Block::Builder::hasActiveData() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>::Reader Block::Reader::getActiveData() const {
  return ::capnp::_::PointerHelpers< ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>::Builder Block::Builder::getActiveData() {
  return ::capnp::_::PointerHelpers< ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>::Pipeline Block::Pipeline::getActiveData() {
  return  ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Block::Builder::setActiveData( ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>::Reader value) {
  ::capnp::_::PointerHelpers< ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>::Builder Block::Builder::initActiveData() {
  return ::capnp::_::PointerHelpers< ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Block::Builder::adoptActiveData(
    ::capnp::Orphan< ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>>&& value) {
  ::capnp::_::PointerHelpers< ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>> Block::Builder::disownActiveData() {
  return ::capnp::_::PointerHelpers< ::koinos::Opaque< ::koinos::protocol::ActiveBlockData>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Block::Reader::hasPassiveData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Block::Builder::hasPassiveData() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>::Reader Block::Reader::getPassiveData() const {
  return ::capnp::_::PointerHelpers< ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>::Builder Block::Builder::getPassiveData() {
  return ::capnp::_::PointerHelpers< ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>::Pipeline Block::Pipeline::getPassiveData() {
  return  ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Block::Builder::setPassiveData( ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>::Reader value) {
  ::capnp::_::PointerHelpers< ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>::Builder Block::Builder::initPassiveData() {
  return ::capnp::_::PointerHelpers< ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Block::Builder::adoptPassiveData(
    ::capnp::Orphan< ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>>&& value) {
  ::capnp::_::PointerHelpers< ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>> Block::Builder::disownPassiveData() {
  return ::capnp::_::PointerHelpers< ::koinos::Opaque< ::koinos::protocol::PassiveBlockData>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Block::Reader::hasSignatureData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool Block::Builder::hasSignatureData() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader Block::Reader::getSignatureData() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder Block::Builder::getSignatureData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void Block::Builder::setSignatureData( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder Block::Builder::initSignatureData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void Block::Builder::adoptSignatureData(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> Block::Builder::disownSignatureData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace

