// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: common.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 8000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(ffc7ef2185762c70);
CAPNP_DECLARE_SCHEMA(a11cdc7f34b73147);
CAPNP_DECLARE_SCHEMA(bc2f08e5acdea3aa);
CAPNP_DECLARE_SCHEMA(997dbb766f2696fa);
CAPNP_DECLARE_SCHEMA(b6084849c378a152);

}  // namespace schemas
}  // namespace capnp

namespace koinos {

struct BlockTopology {
  BlockTopology() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ffc7ef2185762c70, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ContractCallBundle {
  ContractCallBundle() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a11cdc7f34b73147, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SystemCallTarget {
  SystemCallTarget() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    THUNK_I_D,
    SYSTEM_CALL_BUNDLE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bc2f08e5acdea3aa, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename Type = ::capnp::AnyPointer>
struct Opaque {
  Opaque() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    NATIVE,
    BYTES,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(997dbb766f2696fa, 1, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Type>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Type = ::capnp::AnyPointer>
struct Optional {
  Optional() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    NULL_,
    VALUE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b6084849c378a152, 1, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Type>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class BlockTopology::Reader {
public:
  typedef BlockTopology Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasId() const;
  inline  ::capnp::Data::Reader getId() const;

  inline  ::uint64_t getHeight() const;

  inline bool hasPrevious() const;
  inline  ::capnp::Data::Reader getPrevious() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTopology::Builder {
public:
  typedef BlockTopology Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasId();
  inline  ::capnp::Data::Builder getId();
  inline void setId( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initId(unsigned int size);
  inline void adoptId(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownId();

  inline  ::uint64_t getHeight();
  inline void setHeight( ::uint64_t value);

  inline bool hasPrevious();
  inline  ::capnp::Data::Builder getPrevious();
  inline void setPrevious( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initPrevious(unsigned int size);
  inline void adoptPrevious(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownPrevious();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTopology::Pipeline {
public:
  typedef BlockTopology Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ContractCallBundle::Reader {
public:
  typedef ContractCallBundle Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContractID() const;
  inline  ::capnp::Data::Reader getContractID() const;

  inline  ::uint32_t getEntryPoint() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ContractCallBundle::Builder {
public:
  typedef ContractCallBundle Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContractID();
  inline  ::capnp::Data::Builder getContractID();
  inline void setContractID( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initContractID(unsigned int size);
  inline void adoptContractID(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownContractID();

  inline  ::uint32_t getEntryPoint();
  inline void setEntryPoint( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ContractCallBundle::Pipeline {
public:
  typedef ContractCallBundle Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SystemCallTarget::Reader {
public:
  typedef SystemCallTarget Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isThunkID() const;
  inline  ::uint32_t getThunkID() const;

  inline bool isSystemCallBundle() const;
  inline bool hasSystemCallBundle() const;
  inline  ::koinos::ContractCallBundle::Reader getSystemCallBundle() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SystemCallTarget::Builder {
public:
  typedef SystemCallTarget Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isThunkID();
  inline  ::uint32_t getThunkID();
  inline void setThunkID( ::uint32_t value);

  inline bool isSystemCallBundle();
  inline bool hasSystemCallBundle();
  inline  ::koinos::ContractCallBundle::Builder getSystemCallBundle();
  inline void setSystemCallBundle( ::koinos::ContractCallBundle::Reader value);
  inline  ::koinos::ContractCallBundle::Builder initSystemCallBundle();
  inline void adoptSystemCallBundle(::capnp::Orphan< ::koinos::ContractCallBundle>&& value);
  inline ::capnp::Orphan< ::koinos::ContractCallBundle> disownSystemCallBundle();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SystemCallTarget::Pipeline {
public:
  typedef SystemCallTarget Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Type>
class Opaque<Type>::Reader {
public:
  typedef Opaque Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Type2 = ::capnp::AnyPointer>
  typename Opaque<Type2>::Reader asGeneric() {
    return typename Opaque<Type2>::Reader(_reader);
  }

  inline Which which() const;
  inline bool isNative() const;
  inline bool hasNative() const;
  inline  ::capnp::ReaderFor<Type> getNative() const;

  inline bool isBytes() const;
  inline bool hasBytes() const;
  inline  ::capnp::Data::Reader getBytes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Type>
class Opaque<Type>::Builder {
public:
  typedef Opaque Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Type2 = ::capnp::AnyPointer>
  typename Opaque<Type2>::Builder asGeneric() {
    return typename Opaque<Type2>::Builder(_builder);
  }

  inline Which which();
  inline bool isNative();
  inline bool hasNative();
  inline  ::capnp::BuilderFor<Type> getNative();
  inline void setNative( ::capnp::ReaderFor<Type> value);
  inline  ::capnp::BuilderFor<Type> initNative();
  inline  ::capnp::BuilderFor<Type> initNative(unsigned int size);
  inline void adoptNative(::capnp::Orphan<Type>&& value);
  inline ::capnp::Orphan<Type> disownNative();

  inline bool isBytes();
  inline bool hasBytes();
  inline  ::capnp::Data::Builder getBytes();
  inline void setBytes( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initBytes(unsigned int size);
  inline void adoptBytes(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownBytes();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Type>
class Opaque<Type>::Pipeline {
public:
  typedef Opaque Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Type>
class Optional<Type>::Reader {
public:
  typedef Optional Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Type2 = ::capnp::AnyPointer>
  typename Optional<Type2>::Reader asGeneric() {
    return typename Optional<Type2>::Reader(_reader);
  }

  inline Which which() const;
  inline bool isNull() const;
  inline  ::capnp::Void getNull() const;

  inline bool isValue() const;
  inline bool hasValue() const;
  inline  ::capnp::ReaderFor<Type> getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Type>
class Optional<Type>::Builder {
public:
  typedef Optional Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Type2 = ::capnp::AnyPointer>
  typename Optional<Type2>::Builder asGeneric() {
    return typename Optional<Type2>::Builder(_builder);
  }

  inline Which which();
  inline bool isNull();
  inline  ::capnp::Void getNull();
  inline void setNull( ::capnp::Void value = ::capnp::VOID);

  inline bool isValue();
  inline bool hasValue();
  inline  ::capnp::BuilderFor<Type> getValue();
  inline void setValue( ::capnp::ReaderFor<Type> value);
  inline  ::capnp::BuilderFor<Type> initValue();
  inline  ::capnp::BuilderFor<Type> initValue(unsigned int size);
  inline void adoptValue(::capnp::Orphan<Type>&& value);
  inline ::capnp::Orphan<Type> disownValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Type>
class Optional<Type>::Pipeline {
public:
  typedef Optional Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool BlockTopology::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTopology::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader BlockTopology::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder BlockTopology::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockTopology::Builder::setId( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder BlockTopology::Builder::initId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BlockTopology::Builder::adoptId(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> BlockTopology::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t BlockTopology::Reader::getHeight() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t BlockTopology::Builder::getHeight() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BlockTopology::Builder::setHeight( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool BlockTopology::Reader::hasPrevious() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTopology::Builder::hasPrevious() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader BlockTopology::Reader::getPrevious() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder BlockTopology::Builder::getPrevious() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void BlockTopology::Builder::setPrevious( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder BlockTopology::Builder::initPrevious(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void BlockTopology::Builder::adoptPrevious(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> BlockTopology::Builder::disownPrevious() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool ContractCallBundle::Reader::hasContractID() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ContractCallBundle::Builder::hasContractID() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader ContractCallBundle::Reader::getContractID() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder ContractCallBundle::Builder::getContractID() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ContractCallBundle::Builder::setContractID( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder ContractCallBundle::Builder::initContractID(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ContractCallBundle::Builder::adoptContractID(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> ContractCallBundle::Builder::disownContractID() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t ContractCallBundle::Reader::getEntryPoint() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t ContractCallBundle::Builder::getEntryPoint() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ContractCallBundle::Builder::setEntryPoint( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::koinos::SystemCallTarget::Which SystemCallTarget::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline  ::koinos::SystemCallTarget::Which SystemCallTarget::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline bool SystemCallTarget::Reader::isThunkID() const {
  return which() == SystemCallTarget::THUNK_I_D;
}
inline bool SystemCallTarget::Builder::isThunkID() {
  return which() == SystemCallTarget::THUNK_I_D;
}
inline  ::uint32_t SystemCallTarget::Reader::getThunkID() const {
  KJ_IREQUIRE((which() == SystemCallTarget::THUNK_I_D),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t SystemCallTarget::Builder::getThunkID() {
  KJ_IREQUIRE((which() == SystemCallTarget::THUNK_I_D),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void SystemCallTarget::Builder::setThunkID( ::uint32_t value) {
  _builder.setDataField<SystemCallTarget::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, SystemCallTarget::THUNK_I_D);
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool SystemCallTarget::Reader::isSystemCallBundle() const {
  return which() == SystemCallTarget::SYSTEM_CALL_BUNDLE;
}
inline bool SystemCallTarget::Builder::isSystemCallBundle() {
  return which() == SystemCallTarget::SYSTEM_CALL_BUNDLE;
}
inline bool SystemCallTarget::Reader::hasSystemCallBundle() const {
  if (which() != SystemCallTarget::SYSTEM_CALL_BUNDLE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SystemCallTarget::Builder::hasSystemCallBundle() {
  if (which() != SystemCallTarget::SYSTEM_CALL_BUNDLE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::koinos::ContractCallBundle::Reader SystemCallTarget::Reader::getSystemCallBundle() const {
  KJ_IREQUIRE((which() == SystemCallTarget::SYSTEM_CALL_BUNDLE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::ContractCallBundle>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::koinos::ContractCallBundle::Builder SystemCallTarget::Builder::getSystemCallBundle() {
  KJ_IREQUIRE((which() == SystemCallTarget::SYSTEM_CALL_BUNDLE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::ContractCallBundle>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SystemCallTarget::Builder::setSystemCallBundle( ::koinos::ContractCallBundle::Reader value) {
  _builder.setDataField<SystemCallTarget::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, SystemCallTarget::SYSTEM_CALL_BUNDLE);
  ::capnp::_::PointerHelpers< ::koinos::ContractCallBundle>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::koinos::ContractCallBundle::Builder SystemCallTarget::Builder::initSystemCallBundle() {
  _builder.setDataField<SystemCallTarget::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, SystemCallTarget::SYSTEM_CALL_BUNDLE);
  return ::capnp::_::PointerHelpers< ::koinos::ContractCallBundle>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SystemCallTarget::Builder::adoptSystemCallBundle(
    ::capnp::Orphan< ::koinos::ContractCallBundle>&& value) {
  _builder.setDataField<SystemCallTarget::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, SystemCallTarget::SYSTEM_CALL_BUNDLE);
  ::capnp::_::PointerHelpers< ::koinos::ContractCallBundle>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::koinos::ContractCallBundle> SystemCallTarget::Builder::disownSystemCallBundle() {
  KJ_IREQUIRE((which() == SystemCallTarget::SYSTEM_CALL_BUNDLE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::ContractCallBundle>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Type>
inline typename  ::koinos::Opaque<Type>::Which Opaque<Type>::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename Type>
inline typename  ::koinos::Opaque<Type>::Which Opaque<Type>::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename Type>
inline bool Opaque<Type>::Reader::isNative() const {
  return which() == Opaque<Type>::NATIVE;
}
template <typename Type>
inline bool Opaque<Type>::Builder::isNative() {
  return which() == Opaque<Type>::NATIVE;
}
template <typename Type>
inline bool Opaque<Type>::Reader::hasNative() const {
  if (which() != Opaque<Type>::NATIVE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Type>
inline bool Opaque<Type>::Builder::hasNative() {
  if (which() != Opaque<Type>::NATIVE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Type>
inline  ::capnp::ReaderFor<Type> Opaque<Type>::Reader::getNative() const {
  KJ_IREQUIRE((which() == Opaque<Type>::NATIVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<Type>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Type>
inline  ::capnp::BuilderFor<Type> Opaque<Type>::Builder::getNative() {
  KJ_IREQUIRE((which() == Opaque<Type>::NATIVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<Type>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Type>
inline void Opaque<Type>::Builder::setNative( ::capnp::ReaderFor<Type> value) {
  _builder.setDataField<Opaque<Type>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Opaque<Type>::NATIVE);
  ::capnp::_::PointerHelpers<Type>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Type>
inline  ::capnp::BuilderFor<Type> Opaque<Type>::Builder::initNative() {
  _builder.setDataField<Opaque<Type>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Opaque<Type>::NATIVE);
  return ::capnp::_::PointerHelpers<Type>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Type>
inline  ::capnp::BuilderFor<Type> Opaque<Type>::Builder::initNative(unsigned int size) {
  _builder.setDataField<Opaque<Type>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Opaque<Type>::NATIVE);
  return ::capnp::_::PointerHelpers<Type>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Type>
inline void Opaque<Type>::Builder::adoptNative(
    ::capnp::Orphan<Type>&& value) {
  _builder.setDataField<Opaque<Type>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Opaque<Type>::NATIVE);
  ::capnp::_::PointerHelpers<Type>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Type>
inline ::capnp::Orphan<Type> Opaque<Type>::Builder::disownNative() {
  KJ_IREQUIRE((which() == Opaque<Type>::NATIVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<Type>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Type>
inline bool Opaque<Type>::Reader::isBytes() const {
  return which() == Opaque<Type>::BYTES;
}
template <typename Type>
inline bool Opaque<Type>::Builder::isBytes() {
  return which() == Opaque<Type>::BYTES;
}
template <typename Type>
inline bool Opaque<Type>::Reader::hasBytes() const {
  if (which() != Opaque<Type>::BYTES) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Type>
inline bool Opaque<Type>::Builder::hasBytes() {
  if (which() != Opaque<Type>::BYTES) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Type>
inline  ::capnp::Data::Reader Opaque<Type>::Reader::getBytes() const {
  KJ_IREQUIRE((which() == Opaque<Type>::BYTES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Type>
inline  ::capnp::Data::Builder Opaque<Type>::Builder::getBytes() {
  KJ_IREQUIRE((which() == Opaque<Type>::BYTES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Type>
inline void Opaque<Type>::Builder::setBytes( ::capnp::Data::Reader value) {
  _builder.setDataField<Opaque<Type>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Opaque<Type>::BYTES);
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Type>
inline  ::capnp::Data::Builder Opaque<Type>::Builder::initBytes(unsigned int size) {
  _builder.setDataField<Opaque<Type>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Opaque<Type>::BYTES);
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Type>
inline void Opaque<Type>::Builder::adoptBytes(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  _builder.setDataField<Opaque<Type>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Opaque<Type>::BYTES);
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Type>
inline ::capnp::Orphan< ::capnp::Data> Opaque<Type>::Builder::disownBytes() {
  KJ_IREQUIRE((which() == Opaque<Type>::BYTES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// Opaque<Type>
template <typename Type>
constexpr uint16_t Opaque<Type>::_capnpPrivate::dataWordSize;
template <typename Type>
constexpr uint16_t Opaque<Type>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Type>
constexpr ::capnp::Kind Opaque<Type>::_capnpPrivate::kind;
template <typename Type>
constexpr ::capnp::_::RawSchema const* Opaque<Type>::_capnpPrivate::schema;
template <typename Type>
const ::capnp::_::RawBrandedSchema::Scope Opaque<Type>::_capnpPrivate::brandScopes[] = {
  { 0x997dbb766f2696fa, brandBindings + 0, 1, false},
};
template <typename Type>
const ::capnp::_::RawBrandedSchema::Binding Opaque<Type>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Type>(),
};
template <typename Type>
const ::capnp::_::RawBrandedSchema Opaque<Type>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_997dbb766f2696fa, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename Type>
inline typename  ::koinos::Optional<Type>::Which Optional<Type>::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename Type>
inline typename  ::koinos::Optional<Type>::Which Optional<Type>::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename Type>
inline bool Optional<Type>::Reader::isNull() const {
  return which() == Optional<Type>::NULL_;
}
template <typename Type>
inline bool Optional<Type>::Builder::isNull() {
  return which() == Optional<Type>::NULL_;
}
template <typename Type>
inline  ::capnp::Void Optional<Type>::Reader::getNull() const {
  KJ_IREQUIRE((which() == Optional<Type>::NULL_),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename Type>
inline  ::capnp::Void Optional<Type>::Builder::getNull() {
  KJ_IREQUIRE((which() == Optional<Type>::NULL_),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename Type>
inline void Optional<Type>::Builder::setNull( ::capnp::Void value) {
  _builder.setDataField<Optional<Type>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Optional<Type>::NULL_);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

template <typename Type>
inline bool Optional<Type>::Reader::isValue() const {
  return which() == Optional<Type>::VALUE;
}
template <typename Type>
inline bool Optional<Type>::Builder::isValue() {
  return which() == Optional<Type>::VALUE;
}
template <typename Type>
inline bool Optional<Type>::Reader::hasValue() const {
  if (which() != Optional<Type>::VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Type>
inline bool Optional<Type>::Builder::hasValue() {
  if (which() != Optional<Type>::VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Type>
inline  ::capnp::ReaderFor<Type> Optional<Type>::Reader::getValue() const {
  KJ_IREQUIRE((which() == Optional<Type>::VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<Type>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Type>
inline  ::capnp::BuilderFor<Type> Optional<Type>::Builder::getValue() {
  KJ_IREQUIRE((which() == Optional<Type>::VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<Type>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Type>
inline void Optional<Type>::Builder::setValue( ::capnp::ReaderFor<Type> value) {
  _builder.setDataField<Optional<Type>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Optional<Type>::VALUE);
  ::capnp::_::PointerHelpers<Type>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Type>
inline  ::capnp::BuilderFor<Type> Optional<Type>::Builder::initValue() {
  _builder.setDataField<Optional<Type>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Optional<Type>::VALUE);
  return ::capnp::_::PointerHelpers<Type>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Type>
inline  ::capnp::BuilderFor<Type> Optional<Type>::Builder::initValue(unsigned int size) {
  _builder.setDataField<Optional<Type>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Optional<Type>::VALUE);
  return ::capnp::_::PointerHelpers<Type>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Type>
inline void Optional<Type>::Builder::adoptValue(
    ::capnp::Orphan<Type>&& value) {
  _builder.setDataField<Optional<Type>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Optional<Type>::VALUE);
  ::capnp::_::PointerHelpers<Type>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Type>
inline ::capnp::Orphan<Type> Optional<Type>::Builder::disownValue() {
  KJ_IREQUIRE((which() == Optional<Type>::VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<Type>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// Optional<Type>
template <typename Type>
constexpr uint16_t Optional<Type>::_capnpPrivate::dataWordSize;
template <typename Type>
constexpr uint16_t Optional<Type>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Type>
constexpr ::capnp::Kind Optional<Type>::_capnpPrivate::kind;
template <typename Type>
constexpr ::capnp::_::RawSchema const* Optional<Type>::_capnpPrivate::schema;
template <typename Type>
const ::capnp::_::RawBrandedSchema::Scope Optional<Type>::_capnpPrivate::brandScopes[] = {
  { 0xb6084849c378a152, brandBindings + 0, 1, false},
};
template <typename Type>
const ::capnp::_::RawBrandedSchema::Binding Optional<Type>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Type>(),
};
template <typename Type>
const ::capnp::_::RawBrandedSchema Optional<Type>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b6084849c378a152, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

}  // namespace

