// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: koinos/chain/chain.proto

#include "koinos/chain/chain.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace koinos {
namespace chain {
constexpr object_space::object_space(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : zone_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , system_(false)
  , id_(0u){}
struct object_spaceDefaultTypeInternal {
  constexpr object_spaceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~object_spaceDefaultTypeInternal() {}
  union {
    object_space _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT object_spaceDefaultTypeInternal _object_space_default_instance_;
constexpr database_key::database_key(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , space_(nullptr){}
struct database_keyDefaultTypeInternal {
  constexpr database_keyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~database_keyDefaultTypeInternal() {}
  union {
    database_key _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT database_keyDefaultTypeInternal _database_key_default_instance_;
constexpr head_info::head_info(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : head_topology_(nullptr)
  , head_block_time_(uint64_t{0u})
  , last_irreversible_block_(uint64_t{0u}){}
struct head_infoDefaultTypeInternal {
  constexpr head_infoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~head_infoDefaultTypeInternal() {}
  union {
    head_info _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT head_infoDefaultTypeInternal _head_info_default_instance_;
constexpr caller_data::caller_data(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : caller_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , caller_privilege_(0)
{}
struct caller_dataDefaultTypeInternal {
  constexpr caller_dataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~caller_dataDefaultTypeInternal() {}
  union {
    caller_data _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT caller_dataDefaultTypeInternal _caller_data_default_instance_;
constexpr resource_limit_data::resource_limit_data(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : disk_storage_limit_(uint64_t{0u})
  , disk_storage_cost_(uint64_t{0u})
  , network_bandwidth_limit_(uint64_t{0u})
  , network_bandwidth_cost_(uint64_t{0u})
  , compute_bandwidth_limit_(uint64_t{0u})
  , compute_bandwidth_cost_(uint64_t{0u}){}
struct resource_limit_dataDefaultTypeInternal {
  constexpr resource_limit_dataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~resource_limit_dataDefaultTypeInternal() {}
  union {
    resource_limit_data _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT resource_limit_dataDefaultTypeInternal _resource_limit_data_default_instance_;
constexpr contract_metadata_object::contract_metadata_object(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : hash_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , system_(false){}
struct contract_metadata_objectDefaultTypeInternal {
  constexpr contract_metadata_objectDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~contract_metadata_objectDefaultTypeInternal() {}
  union {
    contract_metadata_object _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT contract_metadata_objectDefaultTypeInternal _contract_metadata_object_default_instance_;
}  // namespace chain
}  // namespace koinos
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_koinos_2fchain_2fchain_2eproto[6];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_koinos_2fchain_2fchain_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_koinos_2fchain_2fchain_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_koinos_2fchain_2fchain_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::object_space, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::object_space, system_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::object_space, zone_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::object_space, id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::database_key, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::database_key, space_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::database_key, key_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::head_info, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::head_info, head_topology_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::head_info, head_block_time_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::head_info, last_irreversible_block_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::caller_data, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::caller_data, caller_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::caller_data, caller_privilege_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::resource_limit_data, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::resource_limit_data, disk_storage_limit_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::resource_limit_data, disk_storage_cost_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::resource_limit_data, network_bandwidth_limit_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::resource_limit_data, network_bandwidth_cost_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::resource_limit_data, compute_bandwidth_limit_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::resource_limit_data, compute_bandwidth_cost_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::contract_metadata_object, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::contract_metadata_object, hash_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::contract_metadata_object, system_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::koinos::chain::object_space)},
  { 8, -1, sizeof(::koinos::chain::database_key)},
  { 15, -1, sizeof(::koinos::chain::head_info)},
  { 23, -1, sizeof(::koinos::chain::caller_data)},
  { 30, -1, sizeof(::koinos::chain::resource_limit_data)},
  { 41, -1, sizeof(::koinos::chain::contract_metadata_object)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::koinos::chain::_object_space_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::koinos::chain::_database_key_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::koinos::chain::_head_info_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::koinos::chain::_caller_data_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::koinos::chain::_resource_limit_data_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::koinos::chain::_contract_metadata_object_default_instance_),
};

const char descriptor_table_protodef_koinos_2fchain_2fchain_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\030koinos/chain/chain.proto\022\014koinos.chain"
  "\032\024koinos/options.proto\032\023koinos/common.pr"
  "oto\032\036koinos/protocol/protocol.proto\"8\n\014o"
  "bject_space\022\016\n\006system\030\001 \001(\010\022\014\n\004zone\030\002 \001("
  "\014\022\n\n\002id\030\003 \001(\r\"F\n\014database_key\022)\n\005space\030\001"
  " \001(\0132\032.koinos.chain.object_space\022\013\n\003key\030"
  "\002 \001(\014\"|\n\thead_info\022-\n\rhead_topology\030\001 \001("
  "\0132\026.koinos.block_topology\022\033\n\017head_block_"
  "time\030\002 \001(\004B\0020\001\022#\n\027last_irreversible_bloc"
  "k\030\003 \001(\004B\0020\001\"V\n\013caller_data\022\024\n\006caller\030\001 \001"
  "(\014B\004\200\265\030\006\0221\n\020caller_privilege\030\002 \001(\0162\027.koi"
  "nos.chain.privilege\"\346\001\n\023resource_limit_d"
  "ata\022\036\n\022disk_storage_limit\030\001 \001(\004B\0020\001\022\035\n\021d"
  "isk_storage_cost\030\002 \001(\004B\0020\001\022#\n\027network_ba"
  "ndwidth_limit\030\003 \001(\004B\0020\001\022\"\n\026network_bandw"
  "idth_cost\030\004 \001(\004B\0020\001\022#\n\027compute_bandwidth"
  "_limit\030\005 \001(\004B\0020\001\022\"\n\026compute_bandwidth_co"
  "st\030\006 \001(\004B\0020\001\"8\n\030contract_metadata_object"
  "\022\014\n\004hash\030\001 \001(\014\022\016\n\006system\030\002 \001(\010*+\n\tprivil"
  "ege\022\017\n\013kernel_mode\020\000\022\r\n\tuser_mode\020\001B4Z2g"
  "ithub.com/koinos/koinos-proto-golang/koi"
  "nos/chainb\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_koinos_2fchain_2fchain_2eproto_deps[3] = {
  &::descriptor_table_koinos_2fcommon_2eproto,
  &::descriptor_table_koinos_2foptions_2eproto,
  &::descriptor_table_koinos_2fprotocol_2fprotocol_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_koinos_2fchain_2fchain_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_koinos_2fchain_2fchain_2eproto = {
  false, false, 857, descriptor_table_protodef_koinos_2fchain_2fchain_2eproto, "koinos/chain/chain.proto", 
  &descriptor_table_koinos_2fchain_2fchain_2eproto_once, descriptor_table_koinos_2fchain_2fchain_2eproto_deps, 3, 6,
  schemas, file_default_instances, TableStruct_koinos_2fchain_2fchain_2eproto::offsets,
  file_level_metadata_koinos_2fchain_2fchain_2eproto, file_level_enum_descriptors_koinos_2fchain_2fchain_2eproto, file_level_service_descriptors_koinos_2fchain_2fchain_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_koinos_2fchain_2fchain_2eproto_getter() {
  return &descriptor_table_koinos_2fchain_2fchain_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_koinos_2fchain_2fchain_2eproto(&descriptor_table_koinos_2fchain_2fchain_2eproto);
namespace koinos {
namespace chain {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* privilege_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_koinos_2fchain_2fchain_2eproto);
  return file_level_enum_descriptors_koinos_2fchain_2fchain_2eproto[0];
}
bool privilege_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class object_space::_Internal {
 public:
};

object_space::object_space(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:koinos.chain.object_space)
}
object_space::object_space(const object_space& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  zone_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_zone().empty()) {
    zone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_zone(), 
      GetArenaForAllocation());
  }
  ::memcpy(&system_, &from.system_,
    static_cast<size_t>(reinterpret_cast<char*>(&id_) -
    reinterpret_cast<char*>(&system_)) + sizeof(id_));
  // @@protoc_insertion_point(copy_constructor:koinos.chain.object_space)
}

inline void object_space::SharedCtor() {
zone_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&system_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&id_) -
    reinterpret_cast<char*>(&system_)) + sizeof(id_));
}

object_space::~object_space() {
  // @@protoc_insertion_point(destructor:koinos.chain.object_space)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void object_space::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  zone_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void object_space::ArenaDtor(void* object) {
  object_space* _this = reinterpret_cast< object_space* >(object);
  (void)_this;
}
void object_space::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void object_space::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void object_space::Clear() {
// @@protoc_insertion_point(message_clear_start:koinos.chain.object_space)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  zone_.ClearToEmpty();
  ::memset(&system_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&system_)) + sizeof(id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* object_space::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool system = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          system_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bytes zone = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_zone();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* object_space::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:koinos.chain.object_space)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bool system = 1;
  if (this->_internal_system() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_system(), target);
  }

  // bytes zone = 2;
  if (!this->_internal_zone().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_zone(), target);
  }

  // uint32 id = 3;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:koinos.chain.object_space)
  return target;
}

size_t object_space::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:koinos.chain.object_space)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes zone = 2;
  if (!this->_internal_zone().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_zone());
  }

  // bool system = 1;
  if (this->_internal_system() != 0) {
    total_size += 1 + 1;
  }

  // uint32 id = 3;
  if (this->_internal_id() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData object_space::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    object_space::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*object_space::GetClassData() const { return &_class_data_; }

void object_space::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<object_space *>(to)->MergeFrom(
      static_cast<const object_space &>(from));
}


void object_space::MergeFrom(const object_space& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:koinos.chain.object_space)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_zone().empty()) {
    _internal_set_zone(from._internal_zone());
  }
  if (from._internal_system() != 0) {
    _internal_set_system(from._internal_system());
  }
  if (from._internal_id() != 0) {
    _internal_set_id(from._internal_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void object_space::CopyFrom(const object_space& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:koinos.chain.object_space)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool object_space::IsInitialized() const {
  return true;
}

void object_space::InternalSwap(object_space* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &zone_, GetArenaForAllocation(),
      &other->zone_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(object_space, id_)
      + sizeof(object_space::id_)
      - PROTOBUF_FIELD_OFFSET(object_space, system_)>(
          reinterpret_cast<char*>(&system_),
          reinterpret_cast<char*>(&other->system_));
}

::PROTOBUF_NAMESPACE_ID::Metadata object_space::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_koinos_2fchain_2fchain_2eproto_getter, &descriptor_table_koinos_2fchain_2fchain_2eproto_once,
      file_level_metadata_koinos_2fchain_2fchain_2eproto[0]);
}

// ===================================================================

class database_key::_Internal {
 public:
  static const ::koinos::chain::object_space& space(const database_key* msg);
};

const ::koinos::chain::object_space&
database_key::_Internal::space(const database_key* msg) {
  return *msg->space_;
}
database_key::database_key(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:koinos.chain.database_key)
}
database_key::database_key(const database_key& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_key().empty()) {
    key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_space()) {
    space_ = new ::koinos::chain::object_space(*from.space_);
  } else {
    space_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:koinos.chain.database_key)
}

inline void database_key::SharedCtor() {
key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
space_ = nullptr;
}

database_key::~database_key() {
  // @@protoc_insertion_point(destructor:koinos.chain.database_key)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void database_key::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete space_;
}

void database_key::ArenaDtor(void* object) {
  database_key* _this = reinterpret_cast< database_key* >(object);
  (void)_this;
}
void database_key::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void database_key::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void database_key::Clear() {
// @@protoc_insertion_point(message_clear_start:koinos.chain.database_key)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  key_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && space_ != nullptr) {
    delete space_;
  }
  space_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* database_key::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .koinos.chain.object_space space = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_space(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bytes key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* database_key::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:koinos.chain.database_key)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .koinos.chain.object_space space = 1;
  if (this->_internal_has_space()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::space(this), target, stream);
  }

  // bytes key = 2;
  if (!this->_internal_key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:koinos.chain.database_key)
  return target;
}

size_t database_key::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:koinos.chain.database_key)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes key = 2;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());
  }

  // .koinos.chain.object_space space = 1;
  if (this->_internal_has_space()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *space_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData database_key::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    database_key::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*database_key::GetClassData() const { return &_class_data_; }

void database_key::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<database_key *>(to)->MergeFrom(
      static_cast<const database_key &>(from));
}


void database_key::MergeFrom(const database_key& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:koinos.chain.database_key)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _internal_set_key(from._internal_key());
  }
  if (from._internal_has_space()) {
    _internal_mutable_space()->::koinos::chain::object_space::MergeFrom(from._internal_space());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void database_key::CopyFrom(const database_key& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:koinos.chain.database_key)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool database_key::IsInitialized() const {
  return true;
}

void database_key::InternalSwap(database_key* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_, GetArenaForAllocation(),
      &other->key_, other->GetArenaForAllocation()
  );
  swap(space_, other->space_);
}

::PROTOBUF_NAMESPACE_ID::Metadata database_key::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_koinos_2fchain_2fchain_2eproto_getter, &descriptor_table_koinos_2fchain_2fchain_2eproto_once,
      file_level_metadata_koinos_2fchain_2fchain_2eproto[1]);
}

// ===================================================================

class head_info::_Internal {
 public:
  static const ::koinos::block_topology& head_topology(const head_info* msg);
};

const ::koinos::block_topology&
head_info::_Internal::head_topology(const head_info* msg) {
  return *msg->head_topology_;
}
void head_info::clear_head_topology() {
  if (GetArenaForAllocation() == nullptr && head_topology_ != nullptr) {
    delete head_topology_;
  }
  head_topology_ = nullptr;
}
head_info::head_info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:koinos.chain.head_info)
}
head_info::head_info(const head_info& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_head_topology()) {
    head_topology_ = new ::koinos::block_topology(*from.head_topology_);
  } else {
    head_topology_ = nullptr;
  }
  ::memcpy(&head_block_time_, &from.head_block_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&last_irreversible_block_) -
    reinterpret_cast<char*>(&head_block_time_)) + sizeof(last_irreversible_block_));
  // @@protoc_insertion_point(copy_constructor:koinos.chain.head_info)
}

inline void head_info::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&head_topology_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&last_irreversible_block_) -
    reinterpret_cast<char*>(&head_topology_)) + sizeof(last_irreversible_block_));
}

head_info::~head_info() {
  // @@protoc_insertion_point(destructor:koinos.chain.head_info)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void head_info::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete head_topology_;
}

void head_info::ArenaDtor(void* object) {
  head_info* _this = reinterpret_cast< head_info* >(object);
  (void)_this;
}
void head_info::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void head_info::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void head_info::Clear() {
// @@protoc_insertion_point(message_clear_start:koinos.chain.head_info)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && head_topology_ != nullptr) {
    delete head_topology_;
  }
  head_topology_ = nullptr;
  ::memset(&head_block_time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&last_irreversible_block_) -
      reinterpret_cast<char*>(&head_block_time_)) + sizeof(last_irreversible_block_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* head_info::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .koinos.block_topology head_topology = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_head_topology(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 head_block_time = 2 [jstype = JS_STRING];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          head_block_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 last_irreversible_block = 3 [jstype = JS_STRING];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          last_irreversible_block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* head_info::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:koinos.chain.head_info)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .koinos.block_topology head_topology = 1;
  if (this->_internal_has_head_topology()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::head_topology(this), target, stream);
  }

  // uint64 head_block_time = 2 [jstype = JS_STRING];
  if (this->_internal_head_block_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_head_block_time(), target);
  }

  // uint64 last_irreversible_block = 3 [jstype = JS_STRING];
  if (this->_internal_last_irreversible_block() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_last_irreversible_block(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:koinos.chain.head_info)
  return target;
}

size_t head_info::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:koinos.chain.head_info)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .koinos.block_topology head_topology = 1;
  if (this->_internal_has_head_topology()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *head_topology_);
  }

  // uint64 head_block_time = 2 [jstype = JS_STRING];
  if (this->_internal_head_block_time() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_head_block_time());
  }

  // uint64 last_irreversible_block = 3 [jstype = JS_STRING];
  if (this->_internal_last_irreversible_block() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_last_irreversible_block());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData head_info::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    head_info::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*head_info::GetClassData() const { return &_class_data_; }

void head_info::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<head_info *>(to)->MergeFrom(
      static_cast<const head_info &>(from));
}


void head_info::MergeFrom(const head_info& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:koinos.chain.head_info)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_head_topology()) {
    _internal_mutable_head_topology()->::koinos::block_topology::MergeFrom(from._internal_head_topology());
  }
  if (from._internal_head_block_time() != 0) {
    _internal_set_head_block_time(from._internal_head_block_time());
  }
  if (from._internal_last_irreversible_block() != 0) {
    _internal_set_last_irreversible_block(from._internal_last_irreversible_block());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void head_info::CopyFrom(const head_info& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:koinos.chain.head_info)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool head_info::IsInitialized() const {
  return true;
}

void head_info::InternalSwap(head_info* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(head_info, last_irreversible_block_)
      + sizeof(head_info::last_irreversible_block_)
      - PROTOBUF_FIELD_OFFSET(head_info, head_topology_)>(
          reinterpret_cast<char*>(&head_topology_),
          reinterpret_cast<char*>(&other->head_topology_));
}

::PROTOBUF_NAMESPACE_ID::Metadata head_info::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_koinos_2fchain_2fchain_2eproto_getter, &descriptor_table_koinos_2fchain_2fchain_2eproto_once,
      file_level_metadata_koinos_2fchain_2fchain_2eproto[2]);
}

// ===================================================================

class caller_data::_Internal {
 public:
};

caller_data::caller_data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:koinos.chain.caller_data)
}
caller_data::caller_data(const caller_data& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  caller_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_caller().empty()) {
    caller_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_caller(), 
      GetArenaForAllocation());
  }
  caller_privilege_ = from.caller_privilege_;
  // @@protoc_insertion_point(copy_constructor:koinos.chain.caller_data)
}

inline void caller_data::SharedCtor() {
caller_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
caller_privilege_ = 0;
}

caller_data::~caller_data() {
  // @@protoc_insertion_point(destructor:koinos.chain.caller_data)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void caller_data::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  caller_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void caller_data::ArenaDtor(void* object) {
  caller_data* _this = reinterpret_cast< caller_data* >(object);
  (void)_this;
}
void caller_data::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void caller_data::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void caller_data::Clear() {
// @@protoc_insertion_point(message_clear_start:koinos.chain.caller_data)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  caller_.ClearToEmpty();
  caller_privilege_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* caller_data::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes caller = 1 [(.koinos.koinos_bytes_type) = ADDRESS];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_caller();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .koinos.chain.privilege caller_privilege = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_caller_privilege(static_cast<::koinos::chain::privilege>(val));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* caller_data::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:koinos.chain.caller_data)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes caller = 1 [(.koinos.koinos_bytes_type) = ADDRESS];
  if (!this->_internal_caller().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_caller(), target);
  }

  // .koinos.chain.privilege caller_privilege = 2;
  if (this->_internal_caller_privilege() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_caller_privilege(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:koinos.chain.caller_data)
  return target;
}

size_t caller_data::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:koinos.chain.caller_data)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes caller = 1 [(.koinos.koinos_bytes_type) = ADDRESS];
  if (!this->_internal_caller().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_caller());
  }

  // .koinos.chain.privilege caller_privilege = 2;
  if (this->_internal_caller_privilege() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_caller_privilege());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData caller_data::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    caller_data::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*caller_data::GetClassData() const { return &_class_data_; }

void caller_data::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<caller_data *>(to)->MergeFrom(
      static_cast<const caller_data &>(from));
}


void caller_data::MergeFrom(const caller_data& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:koinos.chain.caller_data)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_caller().empty()) {
    _internal_set_caller(from._internal_caller());
  }
  if (from._internal_caller_privilege() != 0) {
    _internal_set_caller_privilege(from._internal_caller_privilege());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void caller_data::CopyFrom(const caller_data& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:koinos.chain.caller_data)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool caller_data::IsInitialized() const {
  return true;
}

void caller_data::InternalSwap(caller_data* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &caller_, GetArenaForAllocation(),
      &other->caller_, other->GetArenaForAllocation()
  );
  swap(caller_privilege_, other->caller_privilege_);
}

::PROTOBUF_NAMESPACE_ID::Metadata caller_data::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_koinos_2fchain_2fchain_2eproto_getter, &descriptor_table_koinos_2fchain_2fchain_2eproto_once,
      file_level_metadata_koinos_2fchain_2fchain_2eproto[3]);
}

// ===================================================================

class resource_limit_data::_Internal {
 public:
};

resource_limit_data::resource_limit_data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:koinos.chain.resource_limit_data)
}
resource_limit_data::resource_limit_data(const resource_limit_data& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&disk_storage_limit_, &from.disk_storage_limit_,
    static_cast<size_t>(reinterpret_cast<char*>(&compute_bandwidth_cost_) -
    reinterpret_cast<char*>(&disk_storage_limit_)) + sizeof(compute_bandwidth_cost_));
  // @@protoc_insertion_point(copy_constructor:koinos.chain.resource_limit_data)
}

inline void resource_limit_data::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&disk_storage_limit_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&compute_bandwidth_cost_) -
    reinterpret_cast<char*>(&disk_storage_limit_)) + sizeof(compute_bandwidth_cost_));
}

resource_limit_data::~resource_limit_data() {
  // @@protoc_insertion_point(destructor:koinos.chain.resource_limit_data)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void resource_limit_data::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void resource_limit_data::ArenaDtor(void* object) {
  resource_limit_data* _this = reinterpret_cast< resource_limit_data* >(object);
  (void)_this;
}
void resource_limit_data::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void resource_limit_data::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void resource_limit_data::Clear() {
// @@protoc_insertion_point(message_clear_start:koinos.chain.resource_limit_data)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&disk_storage_limit_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&compute_bandwidth_cost_) -
      reinterpret_cast<char*>(&disk_storage_limit_)) + sizeof(compute_bandwidth_cost_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* resource_limit_data::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 disk_storage_limit = 1 [jstype = JS_STRING];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          disk_storage_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 disk_storage_cost = 2 [jstype = JS_STRING];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          disk_storage_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 network_bandwidth_limit = 3 [jstype = JS_STRING];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          network_bandwidth_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 network_bandwidth_cost = 4 [jstype = JS_STRING];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          network_bandwidth_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 compute_bandwidth_limit = 5 [jstype = JS_STRING];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          compute_bandwidth_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 compute_bandwidth_cost = 6 [jstype = JS_STRING];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          compute_bandwidth_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* resource_limit_data::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:koinos.chain.resource_limit_data)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 disk_storage_limit = 1 [jstype = JS_STRING];
  if (this->_internal_disk_storage_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_disk_storage_limit(), target);
  }

  // uint64 disk_storage_cost = 2 [jstype = JS_STRING];
  if (this->_internal_disk_storage_cost() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_disk_storage_cost(), target);
  }

  // uint64 network_bandwidth_limit = 3 [jstype = JS_STRING];
  if (this->_internal_network_bandwidth_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_network_bandwidth_limit(), target);
  }

  // uint64 network_bandwidth_cost = 4 [jstype = JS_STRING];
  if (this->_internal_network_bandwidth_cost() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_network_bandwidth_cost(), target);
  }

  // uint64 compute_bandwidth_limit = 5 [jstype = JS_STRING];
  if (this->_internal_compute_bandwidth_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_compute_bandwidth_limit(), target);
  }

  // uint64 compute_bandwidth_cost = 6 [jstype = JS_STRING];
  if (this->_internal_compute_bandwidth_cost() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_compute_bandwidth_cost(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:koinos.chain.resource_limit_data)
  return target;
}

size_t resource_limit_data::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:koinos.chain.resource_limit_data)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 disk_storage_limit = 1 [jstype = JS_STRING];
  if (this->_internal_disk_storage_limit() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_disk_storage_limit());
  }

  // uint64 disk_storage_cost = 2 [jstype = JS_STRING];
  if (this->_internal_disk_storage_cost() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_disk_storage_cost());
  }

  // uint64 network_bandwidth_limit = 3 [jstype = JS_STRING];
  if (this->_internal_network_bandwidth_limit() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_network_bandwidth_limit());
  }

  // uint64 network_bandwidth_cost = 4 [jstype = JS_STRING];
  if (this->_internal_network_bandwidth_cost() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_network_bandwidth_cost());
  }

  // uint64 compute_bandwidth_limit = 5 [jstype = JS_STRING];
  if (this->_internal_compute_bandwidth_limit() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_compute_bandwidth_limit());
  }

  // uint64 compute_bandwidth_cost = 6 [jstype = JS_STRING];
  if (this->_internal_compute_bandwidth_cost() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_compute_bandwidth_cost());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData resource_limit_data::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    resource_limit_data::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*resource_limit_data::GetClassData() const { return &_class_data_; }

void resource_limit_data::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<resource_limit_data *>(to)->MergeFrom(
      static_cast<const resource_limit_data &>(from));
}


void resource_limit_data::MergeFrom(const resource_limit_data& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:koinos.chain.resource_limit_data)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_disk_storage_limit() != 0) {
    _internal_set_disk_storage_limit(from._internal_disk_storage_limit());
  }
  if (from._internal_disk_storage_cost() != 0) {
    _internal_set_disk_storage_cost(from._internal_disk_storage_cost());
  }
  if (from._internal_network_bandwidth_limit() != 0) {
    _internal_set_network_bandwidth_limit(from._internal_network_bandwidth_limit());
  }
  if (from._internal_network_bandwidth_cost() != 0) {
    _internal_set_network_bandwidth_cost(from._internal_network_bandwidth_cost());
  }
  if (from._internal_compute_bandwidth_limit() != 0) {
    _internal_set_compute_bandwidth_limit(from._internal_compute_bandwidth_limit());
  }
  if (from._internal_compute_bandwidth_cost() != 0) {
    _internal_set_compute_bandwidth_cost(from._internal_compute_bandwidth_cost());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void resource_limit_data::CopyFrom(const resource_limit_data& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:koinos.chain.resource_limit_data)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool resource_limit_data::IsInitialized() const {
  return true;
}

void resource_limit_data::InternalSwap(resource_limit_data* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(resource_limit_data, compute_bandwidth_cost_)
      + sizeof(resource_limit_data::compute_bandwidth_cost_)
      - PROTOBUF_FIELD_OFFSET(resource_limit_data, disk_storage_limit_)>(
          reinterpret_cast<char*>(&disk_storage_limit_),
          reinterpret_cast<char*>(&other->disk_storage_limit_));
}

::PROTOBUF_NAMESPACE_ID::Metadata resource_limit_data::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_koinos_2fchain_2fchain_2eproto_getter, &descriptor_table_koinos_2fchain_2fchain_2eproto_once,
      file_level_metadata_koinos_2fchain_2fchain_2eproto[4]);
}

// ===================================================================

class contract_metadata_object::_Internal {
 public:
};

contract_metadata_object::contract_metadata_object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:koinos.chain.contract_metadata_object)
}
contract_metadata_object::contract_metadata_object(const contract_metadata_object& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_hash().empty()) {
    hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_hash(), 
      GetArenaForAllocation());
  }
  system_ = from.system_;
  // @@protoc_insertion_point(copy_constructor:koinos.chain.contract_metadata_object)
}

inline void contract_metadata_object::SharedCtor() {
hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
system_ = false;
}

contract_metadata_object::~contract_metadata_object() {
  // @@protoc_insertion_point(destructor:koinos.chain.contract_metadata_object)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void contract_metadata_object::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void contract_metadata_object::ArenaDtor(void* object) {
  contract_metadata_object* _this = reinterpret_cast< contract_metadata_object* >(object);
  (void)_this;
}
void contract_metadata_object::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void contract_metadata_object::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void contract_metadata_object::Clear() {
// @@protoc_insertion_point(message_clear_start:koinos.chain.contract_metadata_object)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  hash_.ClearToEmpty();
  system_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* contract_metadata_object::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_hash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool system = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          system_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* contract_metadata_object::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:koinos.chain.contract_metadata_object)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes hash = 1;
  if (!this->_internal_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_hash(), target);
  }

  // bool system = 2;
  if (this->_internal_system() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_system(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:koinos.chain.contract_metadata_object)
  return target;
}

size_t contract_metadata_object::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:koinos.chain.contract_metadata_object)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes hash = 1;
  if (!this->_internal_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_hash());
  }

  // bool system = 2;
  if (this->_internal_system() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData contract_metadata_object::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    contract_metadata_object::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*contract_metadata_object::GetClassData() const { return &_class_data_; }

void contract_metadata_object::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<contract_metadata_object *>(to)->MergeFrom(
      static_cast<const contract_metadata_object &>(from));
}


void contract_metadata_object::MergeFrom(const contract_metadata_object& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:koinos.chain.contract_metadata_object)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_hash().empty()) {
    _internal_set_hash(from._internal_hash());
  }
  if (from._internal_system() != 0) {
    _internal_set_system(from._internal_system());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void contract_metadata_object::CopyFrom(const contract_metadata_object& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:koinos.chain.contract_metadata_object)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool contract_metadata_object::IsInitialized() const {
  return true;
}

void contract_metadata_object::InternalSwap(contract_metadata_object* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &hash_, GetArenaForAllocation(),
      &other->hash_, other->GetArenaForAllocation()
  );
  swap(system_, other->system_);
}

::PROTOBUF_NAMESPACE_ID::Metadata contract_metadata_object::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_koinos_2fchain_2fchain_2eproto_getter, &descriptor_table_koinos_2fchain_2fchain_2eproto_once,
      file_level_metadata_koinos_2fchain_2fchain_2eproto[5]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace chain
}  // namespace koinos
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::koinos::chain::object_space* Arena::CreateMaybeMessage< ::koinos::chain::object_space >(Arena* arena) {
  return Arena::CreateMessageInternal< ::koinos::chain::object_space >(arena);
}
template<> PROTOBUF_NOINLINE ::koinos::chain::database_key* Arena::CreateMaybeMessage< ::koinos::chain::database_key >(Arena* arena) {
  return Arena::CreateMessageInternal< ::koinos::chain::database_key >(arena);
}
template<> PROTOBUF_NOINLINE ::koinos::chain::head_info* Arena::CreateMaybeMessage< ::koinos::chain::head_info >(Arena* arena) {
  return Arena::CreateMessageInternal< ::koinos::chain::head_info >(arena);
}
template<> PROTOBUF_NOINLINE ::koinos::chain::caller_data* Arena::CreateMaybeMessage< ::koinos::chain::caller_data >(Arena* arena) {
  return Arena::CreateMessageInternal< ::koinos::chain::caller_data >(arena);
}
template<> PROTOBUF_NOINLINE ::koinos::chain::resource_limit_data* Arena::CreateMaybeMessage< ::koinos::chain::resource_limit_data >(Arena* arena) {
  return Arena::CreateMessageInternal< ::koinos::chain::resource_limit_data >(arena);
}
template<> PROTOBUF_NOINLINE ::koinos::chain::contract_metadata_object* Arena::CreateMaybeMessage< ::koinos::chain::contract_metadata_object >(Arena* arena) {
  return Arena::CreateMessageInternal< ::koinos::chain::contract_metadata_object >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
