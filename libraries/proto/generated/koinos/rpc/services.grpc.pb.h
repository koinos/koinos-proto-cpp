// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: koinos/rpc/services.proto
#ifndef GRPC_koinos_2frpc_2fservices_2eproto__INCLUDED
#define GRPC_koinos_2frpc_2fservices_2eproto__INCLUDED

#include "koinos/rpc/services.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace koinos {
namespace services {

class koinos final {
 public:
  static constexpr char const* service_full_name() {
    return "koinos.services.koinos";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Account History
    virtual ::grpc::Status get_account_history(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request& request, ::koinos::rpc::account_history::get_account_history_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::account_history::get_account_history_response>> Asyncget_account_history(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::account_history::get_account_history_response>>(Asyncget_account_historyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::account_history::get_account_history_response>> PrepareAsyncget_account_history(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::account_history::get_account_history_response>>(PrepareAsyncget_account_historyRaw(context, request, cq));
    }
    // Block Store
    virtual ::grpc::Status get_blocks_by_id(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request& request, ::koinos::rpc::block_store::get_blocks_by_id_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::block_store::get_blocks_by_id_response>> Asyncget_blocks_by_id(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::block_store::get_blocks_by_id_response>>(Asyncget_blocks_by_idRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::block_store::get_blocks_by_id_response>> PrepareAsyncget_blocks_by_id(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::block_store::get_blocks_by_id_response>>(PrepareAsyncget_blocks_by_idRaw(context, request, cq));
    }
    virtual ::grpc::Status get_blocks_by_height(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request& request, ::koinos::rpc::block_store::get_blocks_by_height_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::block_store::get_blocks_by_height_response>> Asyncget_blocks_by_height(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::block_store::get_blocks_by_height_response>>(Asyncget_blocks_by_heightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::block_store::get_blocks_by_height_response>> PrepareAsyncget_blocks_by_height(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::block_store::get_blocks_by_height_response>>(PrepareAsyncget_blocks_by_heightRaw(context, request, cq));
    }
    virtual ::grpc::Status get_highest_block(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request& request, ::koinos::rpc::block_store::get_highest_block_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::block_store::get_highest_block_response>> Asyncget_highest_block(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::block_store::get_highest_block_response>>(Asyncget_highest_blockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::block_store::get_highest_block_response>> PrepareAsyncget_highest_block(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::block_store::get_highest_block_response>>(PrepareAsyncget_highest_blockRaw(context, request, cq));
    }
    // Chain
    virtual ::grpc::Status submit_block(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request& request, ::koinos::rpc::chain::submit_block_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::submit_block_response>> Asyncsubmit_block(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::submit_block_response>>(Asyncsubmit_blockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::submit_block_response>> PrepareAsyncsubmit_block(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::submit_block_response>>(PrepareAsyncsubmit_blockRaw(context, request, cq));
    }
    virtual ::grpc::Status submit_transaction(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request& request, ::koinos::rpc::chain::submit_transaction_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::submit_transaction_response>> Asyncsubmit_transaction(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::submit_transaction_response>>(Asyncsubmit_transactionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::submit_transaction_response>> PrepareAsyncsubmit_transaction(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::submit_transaction_response>>(PrepareAsyncsubmit_transactionRaw(context, request, cq));
    }
    virtual ::grpc::Status get_head_info(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request& request, ::koinos::rpc::chain::get_head_info_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_head_info_response>> Asyncget_head_info(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_head_info_response>>(Asyncget_head_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_head_info_response>> PrepareAsyncget_head_info(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_head_info_response>>(PrepareAsyncget_head_infoRaw(context, request, cq));
    }
    virtual ::grpc::Status get_chain_id(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request& request, ::koinos::rpc::chain::get_chain_id_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_chain_id_response>> Asyncget_chain_id(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_chain_id_response>>(Asyncget_chain_idRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_chain_id_response>> PrepareAsyncget_chain_id(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_chain_id_response>>(PrepareAsyncget_chain_idRaw(context, request, cq));
    }
    virtual ::grpc::Status get_fork_heads(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request& request, ::koinos::rpc::chain::get_fork_heads_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_fork_heads_response>> Asyncget_fork_heads(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_fork_heads_response>>(Asyncget_fork_headsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_fork_heads_response>> PrepareAsyncget_fork_heads(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_fork_heads_response>>(PrepareAsyncget_fork_headsRaw(context, request, cq));
    }
    virtual ::grpc::Status read_contract(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request& request, ::koinos::rpc::chain::read_contract_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::read_contract_response>> Asyncread_contract(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::read_contract_response>>(Asyncread_contractRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::read_contract_response>> PrepareAsyncread_contract(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::read_contract_response>>(PrepareAsyncread_contractRaw(context, request, cq));
    }
    virtual ::grpc::Status get_account_nonce(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request& request, ::koinos::rpc::chain::get_account_nonce_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_account_nonce_response>> Asyncget_account_nonce(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_account_nonce_response>>(Asyncget_account_nonceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_account_nonce_response>> PrepareAsyncget_account_nonce(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_account_nonce_response>>(PrepareAsyncget_account_nonceRaw(context, request, cq));
    }
    virtual ::grpc::Status get_account_rc(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request& request, ::koinos::rpc::chain::get_account_rc_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_account_rc_response>> Asyncget_account_rc(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_account_rc_response>>(Asyncget_account_rcRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_account_rc_response>> PrepareAsyncget_account_rc(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_account_rc_response>>(PrepareAsyncget_account_rcRaw(context, request, cq));
    }
    virtual ::grpc::Status get_resource_limits(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request& request, ::koinos::rpc::chain::get_resource_limits_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_resource_limits_response>> Asyncget_resource_limits(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_resource_limits_response>>(Asyncget_resource_limitsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_resource_limits_response>> PrepareAsyncget_resource_limits(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_resource_limits_response>>(PrepareAsyncget_resource_limitsRaw(context, request, cq));
    }
    // Contract Meta Store
    virtual ::grpc::Status get_contract_meta(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request& request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::contract_meta_store::get_contract_meta_response>> Asyncget_contract_meta(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::contract_meta_store::get_contract_meta_response>>(Asyncget_contract_metaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::contract_meta_store::get_contract_meta_response>> PrepareAsyncget_contract_meta(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::contract_meta_store::get_contract_meta_response>>(PrepareAsyncget_contract_metaRaw(context, request, cq));
    }
    // Mempool
    virtual ::grpc::Status get_pending_transactions(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request& request, ::koinos::rpc::mempool::get_pending_transactions_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::mempool::get_pending_transactions_response>> Asyncget_pending_transactions(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::mempool::get_pending_transactions_response>>(Asyncget_pending_transactionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::mempool::get_pending_transactions_response>> PrepareAsyncget_pending_transactions(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::mempool::get_pending_transactions_response>>(PrepareAsyncget_pending_transactionsRaw(context, request, cq));
    }
    virtual ::grpc::Status check_pending_account_resources(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request& request, ::koinos::rpc::mempool::check_pending_account_resources_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::mempool::check_pending_account_resources_response>> Asynccheck_pending_account_resources(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::mempool::check_pending_account_resources_response>>(Asynccheck_pending_account_resourcesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::mempool::check_pending_account_resources_response>> PrepareAsynccheck_pending_account_resources(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::mempool::check_pending_account_resources_response>>(PrepareAsynccheck_pending_account_resourcesRaw(context, request, cq));
    }
    // P2P
    virtual ::grpc::Status get_gossip_status(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request& request, ::koinos::rpc::p2p::get_gossip_status_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::p2p::get_gossip_status_response>> Asyncget_gossip_status(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::p2p::get_gossip_status_response>>(Asyncget_gossip_statusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::p2p::get_gossip_status_response>> PrepareAsyncget_gossip_status(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::p2p::get_gossip_status_response>>(PrepareAsyncget_gossip_statusRaw(context, request, cq));
    }
    // Transaction Store
    virtual ::grpc::Status get_transactions_by_id(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request& request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::transaction_store::get_transactions_by_id_response>> Asyncget_transactions_by_id(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::transaction_store::get_transactions_by_id_response>>(Asyncget_transactions_by_idRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::transaction_store::get_transactions_by_id_response>> PrepareAsyncget_transactions_by_id(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::transaction_store::get_transactions_by_id_response>>(PrepareAsyncget_transactions_by_idRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Account History
      virtual void get_account_history(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request* request, ::koinos::rpc::account_history::get_account_history_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_account_history(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::account_history::get_account_history_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_account_history(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request* request, ::koinos::rpc::account_history::get_account_history_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_account_history(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request* request, ::koinos::rpc::account_history::get_account_history_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_account_history(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::account_history::get_account_history_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_account_history(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::account_history::get_account_history_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Block Store
      virtual void get_blocks_by_id(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request* request, ::koinos::rpc::block_store::get_blocks_by_id_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_blocks_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_blocks_by_id_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_blocks_by_id(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request* request, ::koinos::rpc::block_store::get_blocks_by_id_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_blocks_by_id(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request* request, ::koinos::rpc::block_store::get_blocks_by_id_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_blocks_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_blocks_by_id_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_blocks_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_blocks_by_id_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void get_blocks_by_height(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request* request, ::koinos::rpc::block_store::get_blocks_by_height_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_blocks_by_height(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_blocks_by_height_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_blocks_by_height(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request* request, ::koinos::rpc::block_store::get_blocks_by_height_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_blocks_by_height(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request* request, ::koinos::rpc::block_store::get_blocks_by_height_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_blocks_by_height(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_blocks_by_height_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_blocks_by_height(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_blocks_by_height_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void get_highest_block(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request* request, ::koinos::rpc::block_store::get_highest_block_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_highest_block(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_highest_block_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_highest_block(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request* request, ::koinos::rpc::block_store::get_highest_block_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_highest_block(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request* request, ::koinos::rpc::block_store::get_highest_block_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_highest_block(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_highest_block_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_highest_block(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_highest_block_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Chain
      virtual void submit_block(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request* request, ::koinos::rpc::chain::submit_block_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void submit_block(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::submit_block_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void submit_block(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request* request, ::koinos::rpc::chain::submit_block_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void submit_block(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request* request, ::koinos::rpc::chain::submit_block_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void submit_block(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::submit_block_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void submit_block(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::submit_block_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void submit_transaction(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request* request, ::koinos::rpc::chain::submit_transaction_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void submit_transaction(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::submit_transaction_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void submit_transaction(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request* request, ::koinos::rpc::chain::submit_transaction_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void submit_transaction(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request* request, ::koinos::rpc::chain::submit_transaction_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void submit_transaction(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::submit_transaction_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void submit_transaction(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::submit_transaction_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void get_head_info(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request* request, ::koinos::rpc::chain::get_head_info_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_head_info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_head_info_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_head_info(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request* request, ::koinos::rpc::chain::get_head_info_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_head_info(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request* request, ::koinos::rpc::chain::get_head_info_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_head_info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_head_info_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_head_info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_head_info_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void get_chain_id(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request* request, ::koinos::rpc::chain::get_chain_id_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_chain_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_chain_id_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_chain_id(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request* request, ::koinos::rpc::chain::get_chain_id_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_chain_id(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request* request, ::koinos::rpc::chain::get_chain_id_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_chain_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_chain_id_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_chain_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_chain_id_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void get_fork_heads(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request* request, ::koinos::rpc::chain::get_fork_heads_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_fork_heads(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_fork_heads_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_fork_heads(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request* request, ::koinos::rpc::chain::get_fork_heads_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_fork_heads(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request* request, ::koinos::rpc::chain::get_fork_heads_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_fork_heads(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_fork_heads_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_fork_heads(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_fork_heads_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void read_contract(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request* request, ::koinos::rpc::chain::read_contract_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void read_contract(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::read_contract_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void read_contract(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request* request, ::koinos::rpc::chain::read_contract_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void read_contract(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request* request, ::koinos::rpc::chain::read_contract_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void read_contract(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::read_contract_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void read_contract(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::read_contract_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void get_account_nonce(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request* request, ::koinos::rpc::chain::get_account_nonce_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_account_nonce(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_account_nonce_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_account_nonce(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request* request, ::koinos::rpc::chain::get_account_nonce_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_account_nonce(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request* request, ::koinos::rpc::chain::get_account_nonce_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_account_nonce(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_account_nonce_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_account_nonce(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_account_nonce_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void get_account_rc(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request* request, ::koinos::rpc::chain::get_account_rc_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_account_rc(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_account_rc_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_account_rc(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request* request, ::koinos::rpc::chain::get_account_rc_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_account_rc(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request* request, ::koinos::rpc::chain::get_account_rc_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_account_rc(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_account_rc_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_account_rc(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_account_rc_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void get_resource_limits(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request* request, ::koinos::rpc::chain::get_resource_limits_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_resource_limits(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_resource_limits_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_resource_limits(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request* request, ::koinos::rpc::chain::get_resource_limits_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_resource_limits(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request* request, ::koinos::rpc::chain::get_resource_limits_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_resource_limits(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_resource_limits_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_resource_limits(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_resource_limits_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Contract Meta Store
      virtual void get_contract_meta(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request* request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_contract_meta(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_contract_meta(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request* request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_contract_meta(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request* request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_contract_meta(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_contract_meta(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Mempool
      virtual void get_pending_transactions(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request* request, ::koinos::rpc::mempool::get_pending_transactions_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_pending_transactions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::mempool::get_pending_transactions_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_pending_transactions(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request* request, ::koinos::rpc::mempool::get_pending_transactions_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_pending_transactions(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request* request, ::koinos::rpc::mempool::get_pending_transactions_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_pending_transactions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::mempool::get_pending_transactions_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_pending_transactions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::mempool::get_pending_transactions_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void check_pending_account_resources(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request* request, ::koinos::rpc::mempool::check_pending_account_resources_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void check_pending_account_resources(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::mempool::check_pending_account_resources_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void check_pending_account_resources(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request* request, ::koinos::rpc::mempool::check_pending_account_resources_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void check_pending_account_resources(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request* request, ::koinos::rpc::mempool::check_pending_account_resources_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void check_pending_account_resources(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::mempool::check_pending_account_resources_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void check_pending_account_resources(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::mempool::check_pending_account_resources_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // P2P
      virtual void get_gossip_status(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request* request, ::koinos::rpc::p2p::get_gossip_status_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_gossip_status(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::p2p::get_gossip_status_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_gossip_status(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request* request, ::koinos::rpc::p2p::get_gossip_status_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_gossip_status(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request* request, ::koinos::rpc::p2p::get_gossip_status_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_gossip_status(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::p2p::get_gossip_status_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_gossip_status(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::p2p::get_gossip_status_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Transaction Store
      virtual void get_transactions_by_id(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request* request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_transactions_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_transactions_by_id(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request* request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_transactions_by_id(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request* request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_transactions_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_transactions_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::account_history::get_account_history_response>* Asyncget_account_historyRaw(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::account_history::get_account_history_response>* PrepareAsyncget_account_historyRaw(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::block_store::get_blocks_by_id_response>* Asyncget_blocks_by_idRaw(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::block_store::get_blocks_by_id_response>* PrepareAsyncget_blocks_by_idRaw(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::block_store::get_blocks_by_height_response>* Asyncget_blocks_by_heightRaw(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::block_store::get_blocks_by_height_response>* PrepareAsyncget_blocks_by_heightRaw(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::block_store::get_highest_block_response>* Asyncget_highest_blockRaw(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::block_store::get_highest_block_response>* PrepareAsyncget_highest_blockRaw(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::submit_block_response>* Asyncsubmit_blockRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::submit_block_response>* PrepareAsyncsubmit_blockRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::submit_transaction_response>* Asyncsubmit_transactionRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::submit_transaction_response>* PrepareAsyncsubmit_transactionRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_head_info_response>* Asyncget_head_infoRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_head_info_response>* PrepareAsyncget_head_infoRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_chain_id_response>* Asyncget_chain_idRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_chain_id_response>* PrepareAsyncget_chain_idRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_fork_heads_response>* Asyncget_fork_headsRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_fork_heads_response>* PrepareAsyncget_fork_headsRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::read_contract_response>* Asyncread_contractRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::read_contract_response>* PrepareAsyncread_contractRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_account_nonce_response>* Asyncget_account_nonceRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_account_nonce_response>* PrepareAsyncget_account_nonceRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_account_rc_response>* Asyncget_account_rcRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_account_rc_response>* PrepareAsyncget_account_rcRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_resource_limits_response>* Asyncget_resource_limitsRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::chain::get_resource_limits_response>* PrepareAsyncget_resource_limitsRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::contract_meta_store::get_contract_meta_response>* Asyncget_contract_metaRaw(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::contract_meta_store::get_contract_meta_response>* PrepareAsyncget_contract_metaRaw(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::mempool::get_pending_transactions_response>* Asyncget_pending_transactionsRaw(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::mempool::get_pending_transactions_response>* PrepareAsyncget_pending_transactionsRaw(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::mempool::check_pending_account_resources_response>* Asynccheck_pending_account_resourcesRaw(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::mempool::check_pending_account_resources_response>* PrepareAsynccheck_pending_account_resourcesRaw(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::p2p::get_gossip_status_response>* Asyncget_gossip_statusRaw(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::p2p::get_gossip_status_response>* PrepareAsyncget_gossip_statusRaw(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::transaction_store::get_transactions_by_id_response>* Asyncget_transactions_by_idRaw(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::koinos::rpc::transaction_store::get_transactions_by_id_response>* PrepareAsyncget_transactions_by_idRaw(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status get_account_history(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request& request, ::koinos::rpc::account_history::get_account_history_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::account_history::get_account_history_response>> Asyncget_account_history(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::account_history::get_account_history_response>>(Asyncget_account_historyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::account_history::get_account_history_response>> PrepareAsyncget_account_history(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::account_history::get_account_history_response>>(PrepareAsyncget_account_historyRaw(context, request, cq));
    }
    ::grpc::Status get_blocks_by_id(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request& request, ::koinos::rpc::block_store::get_blocks_by_id_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_blocks_by_id_response>> Asyncget_blocks_by_id(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_blocks_by_id_response>>(Asyncget_blocks_by_idRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_blocks_by_id_response>> PrepareAsyncget_blocks_by_id(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_blocks_by_id_response>>(PrepareAsyncget_blocks_by_idRaw(context, request, cq));
    }
    ::grpc::Status get_blocks_by_height(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request& request, ::koinos::rpc::block_store::get_blocks_by_height_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_blocks_by_height_response>> Asyncget_blocks_by_height(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_blocks_by_height_response>>(Asyncget_blocks_by_heightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_blocks_by_height_response>> PrepareAsyncget_blocks_by_height(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_blocks_by_height_response>>(PrepareAsyncget_blocks_by_heightRaw(context, request, cq));
    }
    ::grpc::Status get_highest_block(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request& request, ::koinos::rpc::block_store::get_highest_block_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_highest_block_response>> Asyncget_highest_block(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_highest_block_response>>(Asyncget_highest_blockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_highest_block_response>> PrepareAsyncget_highest_block(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_highest_block_response>>(PrepareAsyncget_highest_blockRaw(context, request, cq));
    }
    ::grpc::Status submit_block(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request& request, ::koinos::rpc::chain::submit_block_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::submit_block_response>> Asyncsubmit_block(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::submit_block_response>>(Asyncsubmit_blockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::submit_block_response>> PrepareAsyncsubmit_block(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::submit_block_response>>(PrepareAsyncsubmit_blockRaw(context, request, cq));
    }
    ::grpc::Status submit_transaction(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request& request, ::koinos::rpc::chain::submit_transaction_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::submit_transaction_response>> Asyncsubmit_transaction(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::submit_transaction_response>>(Asyncsubmit_transactionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::submit_transaction_response>> PrepareAsyncsubmit_transaction(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::submit_transaction_response>>(PrepareAsyncsubmit_transactionRaw(context, request, cq));
    }
    ::grpc::Status get_head_info(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request& request, ::koinos::rpc::chain::get_head_info_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_head_info_response>> Asyncget_head_info(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_head_info_response>>(Asyncget_head_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_head_info_response>> PrepareAsyncget_head_info(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_head_info_response>>(PrepareAsyncget_head_infoRaw(context, request, cq));
    }
    ::grpc::Status get_chain_id(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request& request, ::koinos::rpc::chain::get_chain_id_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_chain_id_response>> Asyncget_chain_id(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_chain_id_response>>(Asyncget_chain_idRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_chain_id_response>> PrepareAsyncget_chain_id(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_chain_id_response>>(PrepareAsyncget_chain_idRaw(context, request, cq));
    }
    ::grpc::Status get_fork_heads(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request& request, ::koinos::rpc::chain::get_fork_heads_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_fork_heads_response>> Asyncget_fork_heads(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_fork_heads_response>>(Asyncget_fork_headsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_fork_heads_response>> PrepareAsyncget_fork_heads(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_fork_heads_response>>(PrepareAsyncget_fork_headsRaw(context, request, cq));
    }
    ::grpc::Status read_contract(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request& request, ::koinos::rpc::chain::read_contract_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::read_contract_response>> Asyncread_contract(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::read_contract_response>>(Asyncread_contractRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::read_contract_response>> PrepareAsyncread_contract(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::read_contract_response>>(PrepareAsyncread_contractRaw(context, request, cq));
    }
    ::grpc::Status get_account_nonce(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request& request, ::koinos::rpc::chain::get_account_nonce_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_account_nonce_response>> Asyncget_account_nonce(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_account_nonce_response>>(Asyncget_account_nonceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_account_nonce_response>> PrepareAsyncget_account_nonce(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_account_nonce_response>>(PrepareAsyncget_account_nonceRaw(context, request, cq));
    }
    ::grpc::Status get_account_rc(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request& request, ::koinos::rpc::chain::get_account_rc_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_account_rc_response>> Asyncget_account_rc(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_account_rc_response>>(Asyncget_account_rcRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_account_rc_response>> PrepareAsyncget_account_rc(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_account_rc_response>>(PrepareAsyncget_account_rcRaw(context, request, cq));
    }
    ::grpc::Status get_resource_limits(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request& request, ::koinos::rpc::chain::get_resource_limits_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_resource_limits_response>> Asyncget_resource_limits(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_resource_limits_response>>(Asyncget_resource_limitsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_resource_limits_response>> PrepareAsyncget_resource_limits(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_resource_limits_response>>(PrepareAsyncget_resource_limitsRaw(context, request, cq));
    }
    ::grpc::Status get_contract_meta(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request& request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::contract_meta_store::get_contract_meta_response>> Asyncget_contract_meta(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::contract_meta_store::get_contract_meta_response>>(Asyncget_contract_metaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::contract_meta_store::get_contract_meta_response>> PrepareAsyncget_contract_meta(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::contract_meta_store::get_contract_meta_response>>(PrepareAsyncget_contract_metaRaw(context, request, cq));
    }
    ::grpc::Status get_pending_transactions(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request& request, ::koinos::rpc::mempool::get_pending_transactions_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::mempool::get_pending_transactions_response>> Asyncget_pending_transactions(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::mempool::get_pending_transactions_response>>(Asyncget_pending_transactionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::mempool::get_pending_transactions_response>> PrepareAsyncget_pending_transactions(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::mempool::get_pending_transactions_response>>(PrepareAsyncget_pending_transactionsRaw(context, request, cq));
    }
    ::grpc::Status check_pending_account_resources(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request& request, ::koinos::rpc::mempool::check_pending_account_resources_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::mempool::check_pending_account_resources_response>> Asynccheck_pending_account_resources(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::mempool::check_pending_account_resources_response>>(Asynccheck_pending_account_resourcesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::mempool::check_pending_account_resources_response>> PrepareAsynccheck_pending_account_resources(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::mempool::check_pending_account_resources_response>>(PrepareAsynccheck_pending_account_resourcesRaw(context, request, cq));
    }
    ::grpc::Status get_gossip_status(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request& request, ::koinos::rpc::p2p::get_gossip_status_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::p2p::get_gossip_status_response>> Asyncget_gossip_status(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::p2p::get_gossip_status_response>>(Asyncget_gossip_statusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::p2p::get_gossip_status_response>> PrepareAsyncget_gossip_status(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::p2p::get_gossip_status_response>>(PrepareAsyncget_gossip_statusRaw(context, request, cq));
    }
    ::grpc::Status get_transactions_by_id(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request& request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::transaction_store::get_transactions_by_id_response>> Asyncget_transactions_by_id(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::transaction_store::get_transactions_by_id_response>>(Asyncget_transactions_by_idRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::transaction_store::get_transactions_by_id_response>> PrepareAsyncget_transactions_by_id(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::koinos::rpc::transaction_store::get_transactions_by_id_response>>(PrepareAsyncget_transactions_by_idRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void get_account_history(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request* request, ::koinos::rpc::account_history::get_account_history_response* response, std::function<void(::grpc::Status)>) override;
      void get_account_history(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::account_history::get_account_history_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_account_history(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request* request, ::koinos::rpc::account_history::get_account_history_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_account_history(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request* request, ::koinos::rpc::account_history::get_account_history_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_account_history(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::account_history::get_account_history_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_account_history(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::account_history::get_account_history_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void get_blocks_by_id(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request* request, ::koinos::rpc::block_store::get_blocks_by_id_response* response, std::function<void(::grpc::Status)>) override;
      void get_blocks_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_blocks_by_id_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_blocks_by_id(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request* request, ::koinos::rpc::block_store::get_blocks_by_id_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_blocks_by_id(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request* request, ::koinos::rpc::block_store::get_blocks_by_id_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_blocks_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_blocks_by_id_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_blocks_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_blocks_by_id_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void get_blocks_by_height(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request* request, ::koinos::rpc::block_store::get_blocks_by_height_response* response, std::function<void(::grpc::Status)>) override;
      void get_blocks_by_height(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_blocks_by_height_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_blocks_by_height(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request* request, ::koinos::rpc::block_store::get_blocks_by_height_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_blocks_by_height(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request* request, ::koinos::rpc::block_store::get_blocks_by_height_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_blocks_by_height(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_blocks_by_height_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_blocks_by_height(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_blocks_by_height_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void get_highest_block(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request* request, ::koinos::rpc::block_store::get_highest_block_response* response, std::function<void(::grpc::Status)>) override;
      void get_highest_block(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_highest_block_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_highest_block(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request* request, ::koinos::rpc::block_store::get_highest_block_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_highest_block(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request* request, ::koinos::rpc::block_store::get_highest_block_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_highest_block(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_highest_block_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_highest_block(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_highest_block_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void submit_block(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request* request, ::koinos::rpc::chain::submit_block_response* response, std::function<void(::grpc::Status)>) override;
      void submit_block(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::submit_block_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void submit_block(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request* request, ::koinos::rpc::chain::submit_block_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void submit_block(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request* request, ::koinos::rpc::chain::submit_block_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void submit_block(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::submit_block_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void submit_block(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::submit_block_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void submit_transaction(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request* request, ::koinos::rpc::chain::submit_transaction_response* response, std::function<void(::grpc::Status)>) override;
      void submit_transaction(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::submit_transaction_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void submit_transaction(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request* request, ::koinos::rpc::chain::submit_transaction_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void submit_transaction(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request* request, ::koinos::rpc::chain::submit_transaction_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void submit_transaction(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::submit_transaction_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void submit_transaction(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::submit_transaction_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void get_head_info(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request* request, ::koinos::rpc::chain::get_head_info_response* response, std::function<void(::grpc::Status)>) override;
      void get_head_info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_head_info_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_head_info(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request* request, ::koinos::rpc::chain::get_head_info_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_head_info(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request* request, ::koinos::rpc::chain::get_head_info_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_head_info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_head_info_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_head_info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_head_info_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void get_chain_id(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request* request, ::koinos::rpc::chain::get_chain_id_response* response, std::function<void(::grpc::Status)>) override;
      void get_chain_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_chain_id_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_chain_id(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request* request, ::koinos::rpc::chain::get_chain_id_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_chain_id(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request* request, ::koinos::rpc::chain::get_chain_id_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_chain_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_chain_id_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_chain_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_chain_id_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void get_fork_heads(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request* request, ::koinos::rpc::chain::get_fork_heads_response* response, std::function<void(::grpc::Status)>) override;
      void get_fork_heads(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_fork_heads_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_fork_heads(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request* request, ::koinos::rpc::chain::get_fork_heads_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_fork_heads(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request* request, ::koinos::rpc::chain::get_fork_heads_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_fork_heads(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_fork_heads_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_fork_heads(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_fork_heads_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void read_contract(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request* request, ::koinos::rpc::chain::read_contract_response* response, std::function<void(::grpc::Status)>) override;
      void read_contract(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::read_contract_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void read_contract(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request* request, ::koinos::rpc::chain::read_contract_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void read_contract(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request* request, ::koinos::rpc::chain::read_contract_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void read_contract(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::read_contract_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void read_contract(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::read_contract_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void get_account_nonce(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request* request, ::koinos::rpc::chain::get_account_nonce_response* response, std::function<void(::grpc::Status)>) override;
      void get_account_nonce(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_account_nonce_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_account_nonce(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request* request, ::koinos::rpc::chain::get_account_nonce_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_account_nonce(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request* request, ::koinos::rpc::chain::get_account_nonce_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_account_nonce(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_account_nonce_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_account_nonce(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_account_nonce_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void get_account_rc(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request* request, ::koinos::rpc::chain::get_account_rc_response* response, std::function<void(::grpc::Status)>) override;
      void get_account_rc(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_account_rc_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_account_rc(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request* request, ::koinos::rpc::chain::get_account_rc_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_account_rc(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request* request, ::koinos::rpc::chain::get_account_rc_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_account_rc(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_account_rc_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_account_rc(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_account_rc_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void get_resource_limits(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request* request, ::koinos::rpc::chain::get_resource_limits_response* response, std::function<void(::grpc::Status)>) override;
      void get_resource_limits(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_resource_limits_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_resource_limits(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request* request, ::koinos::rpc::chain::get_resource_limits_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_resource_limits(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request* request, ::koinos::rpc::chain::get_resource_limits_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_resource_limits(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_resource_limits_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_resource_limits(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_resource_limits_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void get_contract_meta(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request* request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response, std::function<void(::grpc::Status)>) override;
      void get_contract_meta(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_contract_meta(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request* request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_contract_meta(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request* request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_contract_meta(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_contract_meta(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void get_pending_transactions(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request* request, ::koinos::rpc::mempool::get_pending_transactions_response* response, std::function<void(::grpc::Status)>) override;
      void get_pending_transactions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::mempool::get_pending_transactions_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_pending_transactions(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request* request, ::koinos::rpc::mempool::get_pending_transactions_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_pending_transactions(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request* request, ::koinos::rpc::mempool::get_pending_transactions_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_pending_transactions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::mempool::get_pending_transactions_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_pending_transactions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::mempool::get_pending_transactions_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void check_pending_account_resources(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request* request, ::koinos::rpc::mempool::check_pending_account_resources_response* response, std::function<void(::grpc::Status)>) override;
      void check_pending_account_resources(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::mempool::check_pending_account_resources_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void check_pending_account_resources(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request* request, ::koinos::rpc::mempool::check_pending_account_resources_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void check_pending_account_resources(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request* request, ::koinos::rpc::mempool::check_pending_account_resources_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void check_pending_account_resources(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::mempool::check_pending_account_resources_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void check_pending_account_resources(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::mempool::check_pending_account_resources_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void get_gossip_status(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request* request, ::koinos::rpc::p2p::get_gossip_status_response* response, std::function<void(::grpc::Status)>) override;
      void get_gossip_status(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::p2p::get_gossip_status_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_gossip_status(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request* request, ::koinos::rpc::p2p::get_gossip_status_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_gossip_status(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request* request, ::koinos::rpc::p2p::get_gossip_status_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_gossip_status(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::p2p::get_gossip_status_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_gossip_status(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::p2p::get_gossip_status_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void get_transactions_by_id(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request* request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response, std::function<void(::grpc::Status)>) override;
      void get_transactions_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_transactions_by_id(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request* request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_transactions_by_id(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request* request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_transactions_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_transactions_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::account_history::get_account_history_response>* Asyncget_account_historyRaw(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::account_history::get_account_history_response>* PrepareAsyncget_account_historyRaw(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_blocks_by_id_response>* Asyncget_blocks_by_idRaw(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_blocks_by_id_response>* PrepareAsyncget_blocks_by_idRaw(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_blocks_by_height_response>* Asyncget_blocks_by_heightRaw(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_blocks_by_height_response>* PrepareAsyncget_blocks_by_heightRaw(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_highest_block_response>* Asyncget_highest_blockRaw(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_highest_block_response>* PrepareAsyncget_highest_blockRaw(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::submit_block_response>* Asyncsubmit_blockRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::submit_block_response>* PrepareAsyncsubmit_blockRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::submit_transaction_response>* Asyncsubmit_transactionRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::submit_transaction_response>* PrepareAsyncsubmit_transactionRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_head_info_response>* Asyncget_head_infoRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_head_info_response>* PrepareAsyncget_head_infoRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_chain_id_response>* Asyncget_chain_idRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_chain_id_response>* PrepareAsyncget_chain_idRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_fork_heads_response>* Asyncget_fork_headsRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_fork_heads_response>* PrepareAsyncget_fork_headsRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::read_contract_response>* Asyncread_contractRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::read_contract_response>* PrepareAsyncread_contractRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_account_nonce_response>* Asyncget_account_nonceRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_account_nonce_response>* PrepareAsyncget_account_nonceRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_account_rc_response>* Asyncget_account_rcRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_account_rc_response>* PrepareAsyncget_account_rcRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_resource_limits_response>* Asyncget_resource_limitsRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_resource_limits_response>* PrepareAsyncget_resource_limitsRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::contract_meta_store::get_contract_meta_response>* Asyncget_contract_metaRaw(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::contract_meta_store::get_contract_meta_response>* PrepareAsyncget_contract_metaRaw(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::mempool::get_pending_transactions_response>* Asyncget_pending_transactionsRaw(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::mempool::get_pending_transactions_response>* PrepareAsyncget_pending_transactionsRaw(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::mempool::check_pending_account_resources_response>* Asynccheck_pending_account_resourcesRaw(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::mempool::check_pending_account_resources_response>* PrepareAsynccheck_pending_account_resourcesRaw(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::p2p::get_gossip_status_response>* Asyncget_gossip_statusRaw(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::p2p::get_gossip_status_response>* PrepareAsyncget_gossip_statusRaw(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::transaction_store::get_transactions_by_id_response>* Asyncget_transactions_by_idRaw(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::koinos::rpc::transaction_store::get_transactions_by_id_response>* PrepareAsyncget_transactions_by_idRaw(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_get_account_history_;
    const ::grpc::internal::RpcMethod rpcmethod_get_blocks_by_id_;
    const ::grpc::internal::RpcMethod rpcmethod_get_blocks_by_height_;
    const ::grpc::internal::RpcMethod rpcmethod_get_highest_block_;
    const ::grpc::internal::RpcMethod rpcmethod_submit_block_;
    const ::grpc::internal::RpcMethod rpcmethod_submit_transaction_;
    const ::grpc::internal::RpcMethod rpcmethod_get_head_info_;
    const ::grpc::internal::RpcMethod rpcmethod_get_chain_id_;
    const ::grpc::internal::RpcMethod rpcmethod_get_fork_heads_;
    const ::grpc::internal::RpcMethod rpcmethod_read_contract_;
    const ::grpc::internal::RpcMethod rpcmethod_get_account_nonce_;
    const ::grpc::internal::RpcMethod rpcmethod_get_account_rc_;
    const ::grpc::internal::RpcMethod rpcmethod_get_resource_limits_;
    const ::grpc::internal::RpcMethod rpcmethod_get_contract_meta_;
    const ::grpc::internal::RpcMethod rpcmethod_get_pending_transactions_;
    const ::grpc::internal::RpcMethod rpcmethod_check_pending_account_resources_;
    const ::grpc::internal::RpcMethod rpcmethod_get_gossip_status_;
    const ::grpc::internal::RpcMethod rpcmethod_get_transactions_by_id_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Account History
    virtual ::grpc::Status get_account_history(::grpc::ServerContext* context, const ::koinos::rpc::account_history::get_account_history_request* request, ::koinos::rpc::account_history::get_account_history_response* response);
    // Block Store
    virtual ::grpc::Status get_blocks_by_id(::grpc::ServerContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request* request, ::koinos::rpc::block_store::get_blocks_by_id_response* response);
    virtual ::grpc::Status get_blocks_by_height(::grpc::ServerContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request* request, ::koinos::rpc::block_store::get_blocks_by_height_response* response);
    virtual ::grpc::Status get_highest_block(::grpc::ServerContext* context, const ::koinos::rpc::block_store::get_highest_block_request* request, ::koinos::rpc::block_store::get_highest_block_response* response);
    // Chain
    virtual ::grpc::Status submit_block(::grpc::ServerContext* context, const ::koinos::rpc::chain::submit_block_request* request, ::koinos::rpc::chain::submit_block_response* response);
    virtual ::grpc::Status submit_transaction(::grpc::ServerContext* context, const ::koinos::rpc::chain::submit_transaction_request* request, ::koinos::rpc::chain::submit_transaction_response* response);
    virtual ::grpc::Status get_head_info(::grpc::ServerContext* context, const ::koinos::rpc::chain::get_head_info_request* request, ::koinos::rpc::chain::get_head_info_response* response);
    virtual ::grpc::Status get_chain_id(::grpc::ServerContext* context, const ::koinos::rpc::chain::get_chain_id_request* request, ::koinos::rpc::chain::get_chain_id_response* response);
    virtual ::grpc::Status get_fork_heads(::grpc::ServerContext* context, const ::koinos::rpc::chain::get_fork_heads_request* request, ::koinos::rpc::chain::get_fork_heads_response* response);
    virtual ::grpc::Status read_contract(::grpc::ServerContext* context, const ::koinos::rpc::chain::read_contract_request* request, ::koinos::rpc::chain::read_contract_response* response);
    virtual ::grpc::Status get_account_nonce(::grpc::ServerContext* context, const ::koinos::rpc::chain::get_account_nonce_request* request, ::koinos::rpc::chain::get_account_nonce_response* response);
    virtual ::grpc::Status get_account_rc(::grpc::ServerContext* context, const ::koinos::rpc::chain::get_account_rc_request* request, ::koinos::rpc::chain::get_account_rc_response* response);
    virtual ::grpc::Status get_resource_limits(::grpc::ServerContext* context, const ::koinos::rpc::chain::get_resource_limits_request* request, ::koinos::rpc::chain::get_resource_limits_response* response);
    // Contract Meta Store
    virtual ::grpc::Status get_contract_meta(::grpc::ServerContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request* request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response);
    // Mempool
    virtual ::grpc::Status get_pending_transactions(::grpc::ServerContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request* request, ::koinos::rpc::mempool::get_pending_transactions_response* response);
    virtual ::grpc::Status check_pending_account_resources(::grpc::ServerContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request* request, ::koinos::rpc::mempool::check_pending_account_resources_response* response);
    // P2P
    virtual ::grpc::Status get_gossip_status(::grpc::ServerContext* context, const ::koinos::rpc::p2p::get_gossip_status_request* request, ::koinos::rpc::p2p::get_gossip_status_response* response);
    // Transaction Store
    virtual ::grpc::Status get_transactions_by_id(::grpc::ServerContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request* request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_get_account_history : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_account_history() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_get_account_history() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_account_history(::grpc::ServerContext* /*context*/, const ::koinos::rpc::account_history::get_account_history_request* /*request*/, ::koinos::rpc::account_history::get_account_history_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_account_history(::grpc::ServerContext* context, ::koinos::rpc::account_history::get_account_history_request* request, ::grpc::ServerAsyncResponseWriter< ::koinos::rpc::account_history::get_account_history_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_blocks_by_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_blocks_by_id() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_get_blocks_by_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_blocks_by_id(::grpc::ServerContext* /*context*/, const ::koinos::rpc::block_store::get_blocks_by_id_request* /*request*/, ::koinos::rpc::block_store::get_blocks_by_id_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_blocks_by_id(::grpc::ServerContext* context, ::koinos::rpc::block_store::get_blocks_by_id_request* request, ::grpc::ServerAsyncResponseWriter< ::koinos::rpc::block_store::get_blocks_by_id_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_blocks_by_height : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_blocks_by_height() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_get_blocks_by_height() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_blocks_by_height(::grpc::ServerContext* /*context*/, const ::koinos::rpc::block_store::get_blocks_by_height_request* /*request*/, ::koinos::rpc::block_store::get_blocks_by_height_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_blocks_by_height(::grpc::ServerContext* context, ::koinos::rpc::block_store::get_blocks_by_height_request* request, ::grpc::ServerAsyncResponseWriter< ::koinos::rpc::block_store::get_blocks_by_height_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_highest_block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_highest_block() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_get_highest_block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_highest_block(::grpc::ServerContext* /*context*/, const ::koinos::rpc::block_store::get_highest_block_request* /*request*/, ::koinos::rpc::block_store::get_highest_block_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_highest_block(::grpc::ServerContext* context, ::koinos::rpc::block_store::get_highest_block_request* request, ::grpc::ServerAsyncResponseWriter< ::koinos::rpc::block_store::get_highest_block_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_submit_block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_submit_block() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_submit_block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status submit_block(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::submit_block_request* /*request*/, ::koinos::rpc::chain::submit_block_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsubmit_block(::grpc::ServerContext* context, ::koinos::rpc::chain::submit_block_request* request, ::grpc::ServerAsyncResponseWriter< ::koinos::rpc::chain::submit_block_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_submit_transaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_submit_transaction() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_submit_transaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status submit_transaction(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::submit_transaction_request* /*request*/, ::koinos::rpc::chain::submit_transaction_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsubmit_transaction(::grpc::ServerContext* context, ::koinos::rpc::chain::submit_transaction_request* request, ::grpc::ServerAsyncResponseWriter< ::koinos::rpc::chain::submit_transaction_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_head_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_head_info() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_get_head_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_head_info(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_head_info_request* /*request*/, ::koinos::rpc::chain::get_head_info_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_head_info(::grpc::ServerContext* context, ::koinos::rpc::chain::get_head_info_request* request, ::grpc::ServerAsyncResponseWriter< ::koinos::rpc::chain::get_head_info_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_chain_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_chain_id() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_get_chain_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_chain_id(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_chain_id_request* /*request*/, ::koinos::rpc::chain::get_chain_id_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_chain_id(::grpc::ServerContext* context, ::koinos::rpc::chain::get_chain_id_request* request, ::grpc::ServerAsyncResponseWriter< ::koinos::rpc::chain::get_chain_id_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_fork_heads : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_fork_heads() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_get_fork_heads() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_fork_heads(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_fork_heads_request* /*request*/, ::koinos::rpc::chain::get_fork_heads_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_fork_heads(::grpc::ServerContext* context, ::koinos::rpc::chain::get_fork_heads_request* request, ::grpc::ServerAsyncResponseWriter< ::koinos::rpc::chain::get_fork_heads_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_read_contract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_read_contract() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_read_contract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status read_contract(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::read_contract_request* /*request*/, ::koinos::rpc::chain::read_contract_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestread_contract(::grpc::ServerContext* context, ::koinos::rpc::chain::read_contract_request* request, ::grpc::ServerAsyncResponseWriter< ::koinos::rpc::chain::read_contract_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_account_nonce : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_account_nonce() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_get_account_nonce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_account_nonce(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_account_nonce_request* /*request*/, ::koinos::rpc::chain::get_account_nonce_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_account_nonce(::grpc::ServerContext* context, ::koinos::rpc::chain::get_account_nonce_request* request, ::grpc::ServerAsyncResponseWriter< ::koinos::rpc::chain::get_account_nonce_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_account_rc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_account_rc() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_get_account_rc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_account_rc(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_account_rc_request* /*request*/, ::koinos::rpc::chain::get_account_rc_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_account_rc(::grpc::ServerContext* context, ::koinos::rpc::chain::get_account_rc_request* request, ::grpc::ServerAsyncResponseWriter< ::koinos::rpc::chain::get_account_rc_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_resource_limits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_resource_limits() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_get_resource_limits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_resource_limits(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_resource_limits_request* /*request*/, ::koinos::rpc::chain::get_resource_limits_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_resource_limits(::grpc::ServerContext* context, ::koinos::rpc::chain::get_resource_limits_request* request, ::grpc::ServerAsyncResponseWriter< ::koinos::rpc::chain::get_resource_limits_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_contract_meta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_contract_meta() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_get_contract_meta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_contract_meta(::grpc::ServerContext* /*context*/, const ::koinos::rpc::contract_meta_store::get_contract_meta_request* /*request*/, ::koinos::rpc::contract_meta_store::get_contract_meta_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_contract_meta(::grpc::ServerContext* context, ::koinos::rpc::contract_meta_store::get_contract_meta_request* request, ::grpc::ServerAsyncResponseWriter< ::koinos::rpc::contract_meta_store::get_contract_meta_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_pending_transactions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_pending_transactions() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_get_pending_transactions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_pending_transactions(::grpc::ServerContext* /*context*/, const ::koinos::rpc::mempool::get_pending_transactions_request* /*request*/, ::koinos::rpc::mempool::get_pending_transactions_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_pending_transactions(::grpc::ServerContext* context, ::koinos::rpc::mempool::get_pending_transactions_request* request, ::grpc::ServerAsyncResponseWriter< ::koinos::rpc::mempool::get_pending_transactions_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_check_pending_account_resources : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_check_pending_account_resources() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_check_pending_account_resources() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status check_pending_account_resources(::grpc::ServerContext* /*context*/, const ::koinos::rpc::mempool::check_pending_account_resources_request* /*request*/, ::koinos::rpc::mempool::check_pending_account_resources_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcheck_pending_account_resources(::grpc::ServerContext* context, ::koinos::rpc::mempool::check_pending_account_resources_request* request, ::grpc::ServerAsyncResponseWriter< ::koinos::rpc::mempool::check_pending_account_resources_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_gossip_status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_gossip_status() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_get_gossip_status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_gossip_status(::grpc::ServerContext* /*context*/, const ::koinos::rpc::p2p::get_gossip_status_request* /*request*/, ::koinos::rpc::p2p::get_gossip_status_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_gossip_status(::grpc::ServerContext* context, ::koinos::rpc::p2p::get_gossip_status_request* request, ::grpc::ServerAsyncResponseWriter< ::koinos::rpc::p2p::get_gossip_status_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_transactions_by_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_transactions_by_id() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_get_transactions_by_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_transactions_by_id(::grpc::ServerContext* /*context*/, const ::koinos::rpc::transaction_store::get_transactions_by_id_request* /*request*/, ::koinos::rpc::transaction_store::get_transactions_by_id_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_transactions_by_id(::grpc::ServerContext* context, ::koinos::rpc::transaction_store::get_transactions_by_id_request* request, ::grpc::ServerAsyncResponseWriter< ::koinos::rpc::transaction_store::get_transactions_by_id_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_get_account_history<WithAsyncMethod_get_blocks_by_id<WithAsyncMethod_get_blocks_by_height<WithAsyncMethod_get_highest_block<WithAsyncMethod_submit_block<WithAsyncMethod_submit_transaction<WithAsyncMethod_get_head_info<WithAsyncMethod_get_chain_id<WithAsyncMethod_get_fork_heads<WithAsyncMethod_read_contract<WithAsyncMethod_get_account_nonce<WithAsyncMethod_get_account_rc<WithAsyncMethod_get_resource_limits<WithAsyncMethod_get_contract_meta<WithAsyncMethod_get_pending_transactions<WithAsyncMethod_check_pending_account_resources<WithAsyncMethod_get_gossip_status<WithAsyncMethod_get_transactions_by_id<Service > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_account_history : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_get_account_history() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::account_history::get_account_history_request, ::koinos::rpc::account_history::get_account_history_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::koinos::rpc::account_history::get_account_history_request* request, ::koinos::rpc::account_history::get_account_history_response* response) { return this->get_account_history(context, request, response); }));}
    void SetMessageAllocatorFor_get_account_history(
        ::grpc::experimental::MessageAllocator< ::koinos::rpc::account_history::get_account_history_request, ::koinos::rpc::account_history::get_account_history_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::account_history::get_account_history_request, ::koinos::rpc::account_history::get_account_history_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_account_history() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_account_history(::grpc::ServerContext* /*context*/, const ::koinos::rpc::account_history::get_account_history_request* /*request*/, ::koinos::rpc::account_history::get_account_history_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_account_history(
      ::grpc::CallbackServerContext* /*context*/, const ::koinos::rpc::account_history::get_account_history_request* /*request*/, ::koinos::rpc::account_history::get_account_history_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_account_history(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::koinos::rpc::account_history::get_account_history_request* /*request*/, ::koinos::rpc::account_history::get_account_history_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_blocks_by_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_get_blocks_by_id() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::block_store::get_blocks_by_id_request, ::koinos::rpc::block_store::get_blocks_by_id_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::koinos::rpc::block_store::get_blocks_by_id_request* request, ::koinos::rpc::block_store::get_blocks_by_id_response* response) { return this->get_blocks_by_id(context, request, response); }));}
    void SetMessageAllocatorFor_get_blocks_by_id(
        ::grpc::experimental::MessageAllocator< ::koinos::rpc::block_store::get_blocks_by_id_request, ::koinos::rpc::block_store::get_blocks_by_id_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::block_store::get_blocks_by_id_request, ::koinos::rpc::block_store::get_blocks_by_id_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_blocks_by_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_blocks_by_id(::grpc::ServerContext* /*context*/, const ::koinos::rpc::block_store::get_blocks_by_id_request* /*request*/, ::koinos::rpc::block_store::get_blocks_by_id_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_blocks_by_id(
      ::grpc::CallbackServerContext* /*context*/, const ::koinos::rpc::block_store::get_blocks_by_id_request* /*request*/, ::koinos::rpc::block_store::get_blocks_by_id_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_blocks_by_id(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::koinos::rpc::block_store::get_blocks_by_id_request* /*request*/, ::koinos::rpc::block_store::get_blocks_by_id_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_blocks_by_height : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_get_blocks_by_height() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::block_store::get_blocks_by_height_request, ::koinos::rpc::block_store::get_blocks_by_height_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::koinos::rpc::block_store::get_blocks_by_height_request* request, ::koinos::rpc::block_store::get_blocks_by_height_response* response) { return this->get_blocks_by_height(context, request, response); }));}
    void SetMessageAllocatorFor_get_blocks_by_height(
        ::grpc::experimental::MessageAllocator< ::koinos::rpc::block_store::get_blocks_by_height_request, ::koinos::rpc::block_store::get_blocks_by_height_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::block_store::get_blocks_by_height_request, ::koinos::rpc::block_store::get_blocks_by_height_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_blocks_by_height() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_blocks_by_height(::grpc::ServerContext* /*context*/, const ::koinos::rpc::block_store::get_blocks_by_height_request* /*request*/, ::koinos::rpc::block_store::get_blocks_by_height_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_blocks_by_height(
      ::grpc::CallbackServerContext* /*context*/, const ::koinos::rpc::block_store::get_blocks_by_height_request* /*request*/, ::koinos::rpc::block_store::get_blocks_by_height_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_blocks_by_height(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::koinos::rpc::block_store::get_blocks_by_height_request* /*request*/, ::koinos::rpc::block_store::get_blocks_by_height_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_highest_block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_get_highest_block() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::block_store::get_highest_block_request, ::koinos::rpc::block_store::get_highest_block_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::koinos::rpc::block_store::get_highest_block_request* request, ::koinos::rpc::block_store::get_highest_block_response* response) { return this->get_highest_block(context, request, response); }));}
    void SetMessageAllocatorFor_get_highest_block(
        ::grpc::experimental::MessageAllocator< ::koinos::rpc::block_store::get_highest_block_request, ::koinos::rpc::block_store::get_highest_block_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::block_store::get_highest_block_request, ::koinos::rpc::block_store::get_highest_block_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_highest_block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_highest_block(::grpc::ServerContext* /*context*/, const ::koinos::rpc::block_store::get_highest_block_request* /*request*/, ::koinos::rpc::block_store::get_highest_block_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_highest_block(
      ::grpc::CallbackServerContext* /*context*/, const ::koinos::rpc::block_store::get_highest_block_request* /*request*/, ::koinos::rpc::block_store::get_highest_block_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_highest_block(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::koinos::rpc::block_store::get_highest_block_request* /*request*/, ::koinos::rpc::block_store::get_highest_block_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_submit_block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_submit_block() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::chain::submit_block_request, ::koinos::rpc::chain::submit_block_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::koinos::rpc::chain::submit_block_request* request, ::koinos::rpc::chain::submit_block_response* response) { return this->submit_block(context, request, response); }));}
    void SetMessageAllocatorFor_submit_block(
        ::grpc::experimental::MessageAllocator< ::koinos::rpc::chain::submit_block_request, ::koinos::rpc::chain::submit_block_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::chain::submit_block_request, ::koinos::rpc::chain::submit_block_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_submit_block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status submit_block(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::submit_block_request* /*request*/, ::koinos::rpc::chain::submit_block_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* submit_block(
      ::grpc::CallbackServerContext* /*context*/, const ::koinos::rpc::chain::submit_block_request* /*request*/, ::koinos::rpc::chain::submit_block_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* submit_block(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::koinos::rpc::chain::submit_block_request* /*request*/, ::koinos::rpc::chain::submit_block_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_submit_transaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_submit_transaction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::chain::submit_transaction_request, ::koinos::rpc::chain::submit_transaction_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::koinos::rpc::chain::submit_transaction_request* request, ::koinos::rpc::chain::submit_transaction_response* response) { return this->submit_transaction(context, request, response); }));}
    void SetMessageAllocatorFor_submit_transaction(
        ::grpc::experimental::MessageAllocator< ::koinos::rpc::chain::submit_transaction_request, ::koinos::rpc::chain::submit_transaction_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::chain::submit_transaction_request, ::koinos::rpc::chain::submit_transaction_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_submit_transaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status submit_transaction(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::submit_transaction_request* /*request*/, ::koinos::rpc::chain::submit_transaction_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* submit_transaction(
      ::grpc::CallbackServerContext* /*context*/, const ::koinos::rpc::chain::submit_transaction_request* /*request*/, ::koinos::rpc::chain::submit_transaction_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* submit_transaction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::koinos::rpc::chain::submit_transaction_request* /*request*/, ::koinos::rpc::chain::submit_transaction_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_head_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_get_head_info() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::chain::get_head_info_request, ::koinos::rpc::chain::get_head_info_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::koinos::rpc::chain::get_head_info_request* request, ::koinos::rpc::chain::get_head_info_response* response) { return this->get_head_info(context, request, response); }));}
    void SetMessageAllocatorFor_get_head_info(
        ::grpc::experimental::MessageAllocator< ::koinos::rpc::chain::get_head_info_request, ::koinos::rpc::chain::get_head_info_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::chain::get_head_info_request, ::koinos::rpc::chain::get_head_info_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_head_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_head_info(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_head_info_request* /*request*/, ::koinos::rpc::chain::get_head_info_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_head_info(
      ::grpc::CallbackServerContext* /*context*/, const ::koinos::rpc::chain::get_head_info_request* /*request*/, ::koinos::rpc::chain::get_head_info_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_head_info(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::koinos::rpc::chain::get_head_info_request* /*request*/, ::koinos::rpc::chain::get_head_info_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_chain_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_get_chain_id() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::chain::get_chain_id_request, ::koinos::rpc::chain::get_chain_id_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::koinos::rpc::chain::get_chain_id_request* request, ::koinos::rpc::chain::get_chain_id_response* response) { return this->get_chain_id(context, request, response); }));}
    void SetMessageAllocatorFor_get_chain_id(
        ::grpc::experimental::MessageAllocator< ::koinos::rpc::chain::get_chain_id_request, ::koinos::rpc::chain::get_chain_id_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::chain::get_chain_id_request, ::koinos::rpc::chain::get_chain_id_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_chain_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_chain_id(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_chain_id_request* /*request*/, ::koinos::rpc::chain::get_chain_id_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_chain_id(
      ::grpc::CallbackServerContext* /*context*/, const ::koinos::rpc::chain::get_chain_id_request* /*request*/, ::koinos::rpc::chain::get_chain_id_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_chain_id(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::koinos::rpc::chain::get_chain_id_request* /*request*/, ::koinos::rpc::chain::get_chain_id_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_fork_heads : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_get_fork_heads() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::chain::get_fork_heads_request, ::koinos::rpc::chain::get_fork_heads_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::koinos::rpc::chain::get_fork_heads_request* request, ::koinos::rpc::chain::get_fork_heads_response* response) { return this->get_fork_heads(context, request, response); }));}
    void SetMessageAllocatorFor_get_fork_heads(
        ::grpc::experimental::MessageAllocator< ::koinos::rpc::chain::get_fork_heads_request, ::koinos::rpc::chain::get_fork_heads_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::chain::get_fork_heads_request, ::koinos::rpc::chain::get_fork_heads_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_fork_heads() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_fork_heads(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_fork_heads_request* /*request*/, ::koinos::rpc::chain::get_fork_heads_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_fork_heads(
      ::grpc::CallbackServerContext* /*context*/, const ::koinos::rpc::chain::get_fork_heads_request* /*request*/, ::koinos::rpc::chain::get_fork_heads_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_fork_heads(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::koinos::rpc::chain::get_fork_heads_request* /*request*/, ::koinos::rpc::chain::get_fork_heads_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_read_contract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_read_contract() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::chain::read_contract_request, ::koinos::rpc::chain::read_contract_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::koinos::rpc::chain::read_contract_request* request, ::koinos::rpc::chain::read_contract_response* response) { return this->read_contract(context, request, response); }));}
    void SetMessageAllocatorFor_read_contract(
        ::grpc::experimental::MessageAllocator< ::koinos::rpc::chain::read_contract_request, ::koinos::rpc::chain::read_contract_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::chain::read_contract_request, ::koinos::rpc::chain::read_contract_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_read_contract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status read_contract(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::read_contract_request* /*request*/, ::koinos::rpc::chain::read_contract_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* read_contract(
      ::grpc::CallbackServerContext* /*context*/, const ::koinos::rpc::chain::read_contract_request* /*request*/, ::koinos::rpc::chain::read_contract_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* read_contract(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::koinos::rpc::chain::read_contract_request* /*request*/, ::koinos::rpc::chain::read_contract_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_account_nonce : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_get_account_nonce() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::chain::get_account_nonce_request, ::koinos::rpc::chain::get_account_nonce_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::koinos::rpc::chain::get_account_nonce_request* request, ::koinos::rpc::chain::get_account_nonce_response* response) { return this->get_account_nonce(context, request, response); }));}
    void SetMessageAllocatorFor_get_account_nonce(
        ::grpc::experimental::MessageAllocator< ::koinos::rpc::chain::get_account_nonce_request, ::koinos::rpc::chain::get_account_nonce_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::chain::get_account_nonce_request, ::koinos::rpc::chain::get_account_nonce_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_account_nonce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_account_nonce(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_account_nonce_request* /*request*/, ::koinos::rpc::chain::get_account_nonce_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_account_nonce(
      ::grpc::CallbackServerContext* /*context*/, const ::koinos::rpc::chain::get_account_nonce_request* /*request*/, ::koinos::rpc::chain::get_account_nonce_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_account_nonce(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::koinos::rpc::chain::get_account_nonce_request* /*request*/, ::koinos::rpc::chain::get_account_nonce_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_account_rc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_get_account_rc() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::chain::get_account_rc_request, ::koinos::rpc::chain::get_account_rc_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::koinos::rpc::chain::get_account_rc_request* request, ::koinos::rpc::chain::get_account_rc_response* response) { return this->get_account_rc(context, request, response); }));}
    void SetMessageAllocatorFor_get_account_rc(
        ::grpc::experimental::MessageAllocator< ::koinos::rpc::chain::get_account_rc_request, ::koinos::rpc::chain::get_account_rc_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::chain::get_account_rc_request, ::koinos::rpc::chain::get_account_rc_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_account_rc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_account_rc(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_account_rc_request* /*request*/, ::koinos::rpc::chain::get_account_rc_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_account_rc(
      ::grpc::CallbackServerContext* /*context*/, const ::koinos::rpc::chain::get_account_rc_request* /*request*/, ::koinos::rpc::chain::get_account_rc_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_account_rc(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::koinos::rpc::chain::get_account_rc_request* /*request*/, ::koinos::rpc::chain::get_account_rc_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_resource_limits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_get_resource_limits() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::chain::get_resource_limits_request, ::koinos::rpc::chain::get_resource_limits_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::koinos::rpc::chain::get_resource_limits_request* request, ::koinos::rpc::chain::get_resource_limits_response* response) { return this->get_resource_limits(context, request, response); }));}
    void SetMessageAllocatorFor_get_resource_limits(
        ::grpc::experimental::MessageAllocator< ::koinos::rpc::chain::get_resource_limits_request, ::koinos::rpc::chain::get_resource_limits_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::chain::get_resource_limits_request, ::koinos::rpc::chain::get_resource_limits_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_resource_limits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_resource_limits(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_resource_limits_request* /*request*/, ::koinos::rpc::chain::get_resource_limits_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_resource_limits(
      ::grpc::CallbackServerContext* /*context*/, const ::koinos::rpc::chain::get_resource_limits_request* /*request*/, ::koinos::rpc::chain::get_resource_limits_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_resource_limits(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::koinos::rpc::chain::get_resource_limits_request* /*request*/, ::koinos::rpc::chain::get_resource_limits_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_contract_meta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_get_contract_meta() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::contract_meta_store::get_contract_meta_request, ::koinos::rpc::contract_meta_store::get_contract_meta_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request* request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response) { return this->get_contract_meta(context, request, response); }));}
    void SetMessageAllocatorFor_get_contract_meta(
        ::grpc::experimental::MessageAllocator< ::koinos::rpc::contract_meta_store::get_contract_meta_request, ::koinos::rpc::contract_meta_store::get_contract_meta_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::contract_meta_store::get_contract_meta_request, ::koinos::rpc::contract_meta_store::get_contract_meta_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_contract_meta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_contract_meta(::grpc::ServerContext* /*context*/, const ::koinos::rpc::contract_meta_store::get_contract_meta_request* /*request*/, ::koinos::rpc::contract_meta_store::get_contract_meta_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_contract_meta(
      ::grpc::CallbackServerContext* /*context*/, const ::koinos::rpc::contract_meta_store::get_contract_meta_request* /*request*/, ::koinos::rpc::contract_meta_store::get_contract_meta_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_contract_meta(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::koinos::rpc::contract_meta_store::get_contract_meta_request* /*request*/, ::koinos::rpc::contract_meta_store::get_contract_meta_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_pending_transactions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_get_pending_transactions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::mempool::get_pending_transactions_request, ::koinos::rpc::mempool::get_pending_transactions_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::koinos::rpc::mempool::get_pending_transactions_request* request, ::koinos::rpc::mempool::get_pending_transactions_response* response) { return this->get_pending_transactions(context, request, response); }));}
    void SetMessageAllocatorFor_get_pending_transactions(
        ::grpc::experimental::MessageAllocator< ::koinos::rpc::mempool::get_pending_transactions_request, ::koinos::rpc::mempool::get_pending_transactions_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::mempool::get_pending_transactions_request, ::koinos::rpc::mempool::get_pending_transactions_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_pending_transactions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_pending_transactions(::grpc::ServerContext* /*context*/, const ::koinos::rpc::mempool::get_pending_transactions_request* /*request*/, ::koinos::rpc::mempool::get_pending_transactions_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_pending_transactions(
      ::grpc::CallbackServerContext* /*context*/, const ::koinos::rpc::mempool::get_pending_transactions_request* /*request*/, ::koinos::rpc::mempool::get_pending_transactions_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_pending_transactions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::koinos::rpc::mempool::get_pending_transactions_request* /*request*/, ::koinos::rpc::mempool::get_pending_transactions_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_check_pending_account_resources : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_check_pending_account_resources() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::mempool::check_pending_account_resources_request, ::koinos::rpc::mempool::check_pending_account_resources_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::koinos::rpc::mempool::check_pending_account_resources_request* request, ::koinos::rpc::mempool::check_pending_account_resources_response* response) { return this->check_pending_account_resources(context, request, response); }));}
    void SetMessageAllocatorFor_check_pending_account_resources(
        ::grpc::experimental::MessageAllocator< ::koinos::rpc::mempool::check_pending_account_resources_request, ::koinos::rpc::mempool::check_pending_account_resources_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::mempool::check_pending_account_resources_request, ::koinos::rpc::mempool::check_pending_account_resources_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_check_pending_account_resources() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status check_pending_account_resources(::grpc::ServerContext* /*context*/, const ::koinos::rpc::mempool::check_pending_account_resources_request* /*request*/, ::koinos::rpc::mempool::check_pending_account_resources_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* check_pending_account_resources(
      ::grpc::CallbackServerContext* /*context*/, const ::koinos::rpc::mempool::check_pending_account_resources_request* /*request*/, ::koinos::rpc::mempool::check_pending_account_resources_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* check_pending_account_resources(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::koinos::rpc::mempool::check_pending_account_resources_request* /*request*/, ::koinos::rpc::mempool::check_pending_account_resources_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_gossip_status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_get_gossip_status() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::p2p::get_gossip_status_request, ::koinos::rpc::p2p::get_gossip_status_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::koinos::rpc::p2p::get_gossip_status_request* request, ::koinos::rpc::p2p::get_gossip_status_response* response) { return this->get_gossip_status(context, request, response); }));}
    void SetMessageAllocatorFor_get_gossip_status(
        ::grpc::experimental::MessageAllocator< ::koinos::rpc::p2p::get_gossip_status_request, ::koinos::rpc::p2p::get_gossip_status_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::p2p::get_gossip_status_request, ::koinos::rpc::p2p::get_gossip_status_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_gossip_status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_gossip_status(::grpc::ServerContext* /*context*/, const ::koinos::rpc::p2p::get_gossip_status_request* /*request*/, ::koinos::rpc::p2p::get_gossip_status_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_gossip_status(
      ::grpc::CallbackServerContext* /*context*/, const ::koinos::rpc::p2p::get_gossip_status_request* /*request*/, ::koinos::rpc::p2p::get_gossip_status_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_gossip_status(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::koinos::rpc::p2p::get_gossip_status_request* /*request*/, ::koinos::rpc::p2p::get_gossip_status_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_transactions_by_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_get_transactions_by_id() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(17,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::transaction_store::get_transactions_by_id_request, ::koinos::rpc::transaction_store::get_transactions_by_id_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request* request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response) { return this->get_transactions_by_id(context, request, response); }));}
    void SetMessageAllocatorFor_get_transactions_by_id(
        ::grpc::experimental::MessageAllocator< ::koinos::rpc::transaction_store::get_transactions_by_id_request, ::koinos::rpc::transaction_store::get_transactions_by_id_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(17);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::koinos::rpc::transaction_store::get_transactions_by_id_request, ::koinos::rpc::transaction_store::get_transactions_by_id_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_transactions_by_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_transactions_by_id(::grpc::ServerContext* /*context*/, const ::koinos::rpc::transaction_store::get_transactions_by_id_request* /*request*/, ::koinos::rpc::transaction_store::get_transactions_by_id_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_transactions_by_id(
      ::grpc::CallbackServerContext* /*context*/, const ::koinos::rpc::transaction_store::get_transactions_by_id_request* /*request*/, ::koinos::rpc::transaction_store::get_transactions_by_id_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_transactions_by_id(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::koinos::rpc::transaction_store::get_transactions_by_id_request* /*request*/, ::koinos::rpc::transaction_store::get_transactions_by_id_response* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_get_account_history<ExperimentalWithCallbackMethod_get_blocks_by_id<ExperimentalWithCallbackMethod_get_blocks_by_height<ExperimentalWithCallbackMethod_get_highest_block<ExperimentalWithCallbackMethod_submit_block<ExperimentalWithCallbackMethod_submit_transaction<ExperimentalWithCallbackMethod_get_head_info<ExperimentalWithCallbackMethod_get_chain_id<ExperimentalWithCallbackMethod_get_fork_heads<ExperimentalWithCallbackMethod_read_contract<ExperimentalWithCallbackMethod_get_account_nonce<ExperimentalWithCallbackMethod_get_account_rc<ExperimentalWithCallbackMethod_get_resource_limits<ExperimentalWithCallbackMethod_get_contract_meta<ExperimentalWithCallbackMethod_get_pending_transactions<ExperimentalWithCallbackMethod_check_pending_account_resources<ExperimentalWithCallbackMethod_get_gossip_status<ExperimentalWithCallbackMethod_get_transactions_by_id<Service > > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_get_account_history<ExperimentalWithCallbackMethod_get_blocks_by_id<ExperimentalWithCallbackMethod_get_blocks_by_height<ExperimentalWithCallbackMethod_get_highest_block<ExperimentalWithCallbackMethod_submit_block<ExperimentalWithCallbackMethod_submit_transaction<ExperimentalWithCallbackMethod_get_head_info<ExperimentalWithCallbackMethod_get_chain_id<ExperimentalWithCallbackMethod_get_fork_heads<ExperimentalWithCallbackMethod_read_contract<ExperimentalWithCallbackMethod_get_account_nonce<ExperimentalWithCallbackMethod_get_account_rc<ExperimentalWithCallbackMethod_get_resource_limits<ExperimentalWithCallbackMethod_get_contract_meta<ExperimentalWithCallbackMethod_get_pending_transactions<ExperimentalWithCallbackMethod_check_pending_account_resources<ExperimentalWithCallbackMethod_get_gossip_status<ExperimentalWithCallbackMethod_get_transactions_by_id<Service > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_get_account_history : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_account_history() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_get_account_history() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_account_history(::grpc::ServerContext* /*context*/, const ::koinos::rpc::account_history::get_account_history_request* /*request*/, ::koinos::rpc::account_history::get_account_history_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_blocks_by_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_blocks_by_id() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_get_blocks_by_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_blocks_by_id(::grpc::ServerContext* /*context*/, const ::koinos::rpc::block_store::get_blocks_by_id_request* /*request*/, ::koinos::rpc::block_store::get_blocks_by_id_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_blocks_by_height : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_blocks_by_height() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_get_blocks_by_height() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_blocks_by_height(::grpc::ServerContext* /*context*/, const ::koinos::rpc::block_store::get_blocks_by_height_request* /*request*/, ::koinos::rpc::block_store::get_blocks_by_height_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_highest_block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_highest_block() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_get_highest_block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_highest_block(::grpc::ServerContext* /*context*/, const ::koinos::rpc::block_store::get_highest_block_request* /*request*/, ::koinos::rpc::block_store::get_highest_block_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_submit_block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_submit_block() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_submit_block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status submit_block(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::submit_block_request* /*request*/, ::koinos::rpc::chain::submit_block_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_submit_transaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_submit_transaction() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_submit_transaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status submit_transaction(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::submit_transaction_request* /*request*/, ::koinos::rpc::chain::submit_transaction_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_head_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_head_info() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_get_head_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_head_info(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_head_info_request* /*request*/, ::koinos::rpc::chain::get_head_info_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_chain_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_chain_id() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_get_chain_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_chain_id(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_chain_id_request* /*request*/, ::koinos::rpc::chain::get_chain_id_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_fork_heads : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_fork_heads() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_get_fork_heads() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_fork_heads(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_fork_heads_request* /*request*/, ::koinos::rpc::chain::get_fork_heads_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_read_contract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_read_contract() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_read_contract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status read_contract(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::read_contract_request* /*request*/, ::koinos::rpc::chain::read_contract_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_account_nonce : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_account_nonce() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_get_account_nonce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_account_nonce(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_account_nonce_request* /*request*/, ::koinos::rpc::chain::get_account_nonce_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_account_rc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_account_rc() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_get_account_rc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_account_rc(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_account_rc_request* /*request*/, ::koinos::rpc::chain::get_account_rc_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_resource_limits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_resource_limits() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_get_resource_limits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_resource_limits(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_resource_limits_request* /*request*/, ::koinos::rpc::chain::get_resource_limits_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_contract_meta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_contract_meta() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_get_contract_meta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_contract_meta(::grpc::ServerContext* /*context*/, const ::koinos::rpc::contract_meta_store::get_contract_meta_request* /*request*/, ::koinos::rpc::contract_meta_store::get_contract_meta_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_pending_transactions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_pending_transactions() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_get_pending_transactions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_pending_transactions(::grpc::ServerContext* /*context*/, const ::koinos::rpc::mempool::get_pending_transactions_request* /*request*/, ::koinos::rpc::mempool::get_pending_transactions_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_check_pending_account_resources : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_check_pending_account_resources() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_check_pending_account_resources() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status check_pending_account_resources(::grpc::ServerContext* /*context*/, const ::koinos::rpc::mempool::check_pending_account_resources_request* /*request*/, ::koinos::rpc::mempool::check_pending_account_resources_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_gossip_status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_gossip_status() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_get_gossip_status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_gossip_status(::grpc::ServerContext* /*context*/, const ::koinos::rpc::p2p::get_gossip_status_request* /*request*/, ::koinos::rpc::p2p::get_gossip_status_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_transactions_by_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_transactions_by_id() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_get_transactions_by_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_transactions_by_id(::grpc::ServerContext* /*context*/, const ::koinos::rpc::transaction_store::get_transactions_by_id_request* /*request*/, ::koinos::rpc::transaction_store::get_transactions_by_id_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_account_history : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_account_history() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_get_account_history() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_account_history(::grpc::ServerContext* /*context*/, const ::koinos::rpc::account_history::get_account_history_request* /*request*/, ::koinos::rpc::account_history::get_account_history_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_account_history(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_blocks_by_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_blocks_by_id() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_get_blocks_by_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_blocks_by_id(::grpc::ServerContext* /*context*/, const ::koinos::rpc::block_store::get_blocks_by_id_request* /*request*/, ::koinos::rpc::block_store::get_blocks_by_id_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_blocks_by_id(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_blocks_by_height : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_blocks_by_height() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_get_blocks_by_height() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_blocks_by_height(::grpc::ServerContext* /*context*/, const ::koinos::rpc::block_store::get_blocks_by_height_request* /*request*/, ::koinos::rpc::block_store::get_blocks_by_height_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_blocks_by_height(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_highest_block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_highest_block() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_get_highest_block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_highest_block(::grpc::ServerContext* /*context*/, const ::koinos::rpc::block_store::get_highest_block_request* /*request*/, ::koinos::rpc::block_store::get_highest_block_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_highest_block(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_submit_block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_submit_block() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_submit_block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status submit_block(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::submit_block_request* /*request*/, ::koinos::rpc::chain::submit_block_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsubmit_block(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_submit_transaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_submit_transaction() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_submit_transaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status submit_transaction(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::submit_transaction_request* /*request*/, ::koinos::rpc::chain::submit_transaction_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsubmit_transaction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_head_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_head_info() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_get_head_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_head_info(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_head_info_request* /*request*/, ::koinos::rpc::chain::get_head_info_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_head_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_chain_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_chain_id() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_get_chain_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_chain_id(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_chain_id_request* /*request*/, ::koinos::rpc::chain::get_chain_id_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_chain_id(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_fork_heads : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_fork_heads() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_get_fork_heads() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_fork_heads(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_fork_heads_request* /*request*/, ::koinos::rpc::chain::get_fork_heads_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_fork_heads(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_read_contract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_read_contract() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_read_contract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status read_contract(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::read_contract_request* /*request*/, ::koinos::rpc::chain::read_contract_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestread_contract(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_account_nonce : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_account_nonce() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_get_account_nonce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_account_nonce(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_account_nonce_request* /*request*/, ::koinos::rpc::chain::get_account_nonce_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_account_nonce(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_account_rc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_account_rc() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_get_account_rc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_account_rc(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_account_rc_request* /*request*/, ::koinos::rpc::chain::get_account_rc_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_account_rc(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_resource_limits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_resource_limits() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_get_resource_limits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_resource_limits(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_resource_limits_request* /*request*/, ::koinos::rpc::chain::get_resource_limits_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_resource_limits(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_contract_meta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_contract_meta() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_get_contract_meta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_contract_meta(::grpc::ServerContext* /*context*/, const ::koinos::rpc::contract_meta_store::get_contract_meta_request* /*request*/, ::koinos::rpc::contract_meta_store::get_contract_meta_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_contract_meta(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_pending_transactions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_pending_transactions() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_get_pending_transactions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_pending_transactions(::grpc::ServerContext* /*context*/, const ::koinos::rpc::mempool::get_pending_transactions_request* /*request*/, ::koinos::rpc::mempool::get_pending_transactions_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_pending_transactions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_check_pending_account_resources : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_check_pending_account_resources() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_check_pending_account_resources() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status check_pending_account_resources(::grpc::ServerContext* /*context*/, const ::koinos::rpc::mempool::check_pending_account_resources_request* /*request*/, ::koinos::rpc::mempool::check_pending_account_resources_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcheck_pending_account_resources(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_gossip_status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_gossip_status() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_get_gossip_status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_gossip_status(::grpc::ServerContext* /*context*/, const ::koinos::rpc::p2p::get_gossip_status_request* /*request*/, ::koinos::rpc::p2p::get_gossip_status_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_gossip_status(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_transactions_by_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_transactions_by_id() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_get_transactions_by_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_transactions_by_id(::grpc::ServerContext* /*context*/, const ::koinos::rpc::transaction_store::get_transactions_by_id_request* /*request*/, ::koinos::rpc::transaction_store::get_transactions_by_id_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_transactions_by_id(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_account_history : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_get_account_history() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_account_history(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_get_account_history() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_account_history(::grpc::ServerContext* /*context*/, const ::koinos::rpc::account_history::get_account_history_request* /*request*/, ::koinos::rpc::account_history::get_account_history_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_account_history(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_account_history(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_blocks_by_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_get_blocks_by_id() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_blocks_by_id(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_get_blocks_by_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_blocks_by_id(::grpc::ServerContext* /*context*/, const ::koinos::rpc::block_store::get_blocks_by_id_request* /*request*/, ::koinos::rpc::block_store::get_blocks_by_id_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_blocks_by_id(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_blocks_by_id(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_blocks_by_height : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_get_blocks_by_height() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_blocks_by_height(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_get_blocks_by_height() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_blocks_by_height(::grpc::ServerContext* /*context*/, const ::koinos::rpc::block_store::get_blocks_by_height_request* /*request*/, ::koinos::rpc::block_store::get_blocks_by_height_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_blocks_by_height(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_blocks_by_height(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_highest_block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_get_highest_block() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_highest_block(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_get_highest_block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_highest_block(::grpc::ServerContext* /*context*/, const ::koinos::rpc::block_store::get_highest_block_request* /*request*/, ::koinos::rpc::block_store::get_highest_block_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_highest_block(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_highest_block(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_submit_block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_submit_block() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->submit_block(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_submit_block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status submit_block(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::submit_block_request* /*request*/, ::koinos::rpc::chain::submit_block_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* submit_block(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* submit_block(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_submit_transaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_submit_transaction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->submit_transaction(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_submit_transaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status submit_transaction(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::submit_transaction_request* /*request*/, ::koinos::rpc::chain::submit_transaction_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* submit_transaction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* submit_transaction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_head_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_get_head_info() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_head_info(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_get_head_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_head_info(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_head_info_request* /*request*/, ::koinos::rpc::chain::get_head_info_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_head_info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_head_info(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_chain_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_get_chain_id() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_chain_id(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_get_chain_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_chain_id(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_chain_id_request* /*request*/, ::koinos::rpc::chain::get_chain_id_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_chain_id(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_chain_id(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_fork_heads : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_get_fork_heads() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_fork_heads(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_get_fork_heads() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_fork_heads(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_fork_heads_request* /*request*/, ::koinos::rpc::chain::get_fork_heads_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_fork_heads(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_fork_heads(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_read_contract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_read_contract() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->read_contract(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_read_contract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status read_contract(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::read_contract_request* /*request*/, ::koinos::rpc::chain::read_contract_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* read_contract(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* read_contract(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_account_nonce : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_get_account_nonce() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_account_nonce(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_get_account_nonce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_account_nonce(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_account_nonce_request* /*request*/, ::koinos::rpc::chain::get_account_nonce_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_account_nonce(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_account_nonce(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_account_rc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_get_account_rc() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_account_rc(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_get_account_rc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_account_rc(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_account_rc_request* /*request*/, ::koinos::rpc::chain::get_account_rc_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_account_rc(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_account_rc(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_resource_limits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_get_resource_limits() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_resource_limits(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_get_resource_limits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_resource_limits(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_resource_limits_request* /*request*/, ::koinos::rpc::chain::get_resource_limits_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_resource_limits(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_resource_limits(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_contract_meta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_get_contract_meta() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_contract_meta(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_get_contract_meta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_contract_meta(::grpc::ServerContext* /*context*/, const ::koinos::rpc::contract_meta_store::get_contract_meta_request* /*request*/, ::koinos::rpc::contract_meta_store::get_contract_meta_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_contract_meta(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_contract_meta(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_pending_transactions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_get_pending_transactions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_pending_transactions(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_get_pending_transactions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_pending_transactions(::grpc::ServerContext* /*context*/, const ::koinos::rpc::mempool::get_pending_transactions_request* /*request*/, ::koinos::rpc::mempool::get_pending_transactions_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_pending_transactions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_pending_transactions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_check_pending_account_resources : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_check_pending_account_resources() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->check_pending_account_resources(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_check_pending_account_resources() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status check_pending_account_resources(::grpc::ServerContext* /*context*/, const ::koinos::rpc::mempool::check_pending_account_resources_request* /*request*/, ::koinos::rpc::mempool::check_pending_account_resources_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* check_pending_account_resources(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* check_pending_account_resources(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_gossip_status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_get_gossip_status() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_gossip_status(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_get_gossip_status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_gossip_status(::grpc::ServerContext* /*context*/, const ::koinos::rpc::p2p::get_gossip_status_request* /*request*/, ::koinos::rpc::p2p::get_gossip_status_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_gossip_status(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_gossip_status(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_transactions_by_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_get_transactions_by_id() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(17,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_transactions_by_id(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_get_transactions_by_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_transactions_by_id(::grpc::ServerContext* /*context*/, const ::koinos::rpc::transaction_store::get_transactions_by_id_request* /*request*/, ::koinos::rpc::transaction_store::get_transactions_by_id_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_transactions_by_id(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_transactions_by_id(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_account_history : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_account_history() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::koinos::rpc::account_history::get_account_history_request, ::koinos::rpc::account_history::get_account_history_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::koinos::rpc::account_history::get_account_history_request, ::koinos::rpc::account_history::get_account_history_response>* streamer) {
                       return this->Streamedget_account_history(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_account_history() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_account_history(::grpc::ServerContext* /*context*/, const ::koinos::rpc::account_history::get_account_history_request* /*request*/, ::koinos::rpc::account_history::get_account_history_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_account_history(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::koinos::rpc::account_history::get_account_history_request,::koinos::rpc::account_history::get_account_history_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_blocks_by_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_blocks_by_id() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::koinos::rpc::block_store::get_blocks_by_id_request, ::koinos::rpc::block_store::get_blocks_by_id_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::koinos::rpc::block_store::get_blocks_by_id_request, ::koinos::rpc::block_store::get_blocks_by_id_response>* streamer) {
                       return this->Streamedget_blocks_by_id(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_blocks_by_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_blocks_by_id(::grpc::ServerContext* /*context*/, const ::koinos::rpc::block_store::get_blocks_by_id_request* /*request*/, ::koinos::rpc::block_store::get_blocks_by_id_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_blocks_by_id(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::koinos::rpc::block_store::get_blocks_by_id_request,::koinos::rpc::block_store::get_blocks_by_id_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_blocks_by_height : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_blocks_by_height() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::koinos::rpc::block_store::get_blocks_by_height_request, ::koinos::rpc::block_store::get_blocks_by_height_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::koinos::rpc::block_store::get_blocks_by_height_request, ::koinos::rpc::block_store::get_blocks_by_height_response>* streamer) {
                       return this->Streamedget_blocks_by_height(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_blocks_by_height() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_blocks_by_height(::grpc::ServerContext* /*context*/, const ::koinos::rpc::block_store::get_blocks_by_height_request* /*request*/, ::koinos::rpc::block_store::get_blocks_by_height_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_blocks_by_height(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::koinos::rpc::block_store::get_blocks_by_height_request,::koinos::rpc::block_store::get_blocks_by_height_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_highest_block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_highest_block() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::koinos::rpc::block_store::get_highest_block_request, ::koinos::rpc::block_store::get_highest_block_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::koinos::rpc::block_store::get_highest_block_request, ::koinos::rpc::block_store::get_highest_block_response>* streamer) {
                       return this->Streamedget_highest_block(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_highest_block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_highest_block(::grpc::ServerContext* /*context*/, const ::koinos::rpc::block_store::get_highest_block_request* /*request*/, ::koinos::rpc::block_store::get_highest_block_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_highest_block(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::koinos::rpc::block_store::get_highest_block_request,::koinos::rpc::block_store::get_highest_block_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_submit_block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_submit_block() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::koinos::rpc::chain::submit_block_request, ::koinos::rpc::chain::submit_block_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::koinos::rpc::chain::submit_block_request, ::koinos::rpc::chain::submit_block_response>* streamer) {
                       return this->Streamedsubmit_block(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_submit_block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status submit_block(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::submit_block_request* /*request*/, ::koinos::rpc::chain::submit_block_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedsubmit_block(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::koinos::rpc::chain::submit_block_request,::koinos::rpc::chain::submit_block_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_submit_transaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_submit_transaction() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::koinos::rpc::chain::submit_transaction_request, ::koinos::rpc::chain::submit_transaction_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::koinos::rpc::chain::submit_transaction_request, ::koinos::rpc::chain::submit_transaction_response>* streamer) {
                       return this->Streamedsubmit_transaction(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_submit_transaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status submit_transaction(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::submit_transaction_request* /*request*/, ::koinos::rpc::chain::submit_transaction_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedsubmit_transaction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::koinos::rpc::chain::submit_transaction_request,::koinos::rpc::chain::submit_transaction_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_head_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_head_info() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::koinos::rpc::chain::get_head_info_request, ::koinos::rpc::chain::get_head_info_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::koinos::rpc::chain::get_head_info_request, ::koinos::rpc::chain::get_head_info_response>* streamer) {
                       return this->Streamedget_head_info(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_head_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_head_info(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_head_info_request* /*request*/, ::koinos::rpc::chain::get_head_info_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_head_info(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::koinos::rpc::chain::get_head_info_request,::koinos::rpc::chain::get_head_info_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_chain_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_chain_id() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::koinos::rpc::chain::get_chain_id_request, ::koinos::rpc::chain::get_chain_id_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::koinos::rpc::chain::get_chain_id_request, ::koinos::rpc::chain::get_chain_id_response>* streamer) {
                       return this->Streamedget_chain_id(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_chain_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_chain_id(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_chain_id_request* /*request*/, ::koinos::rpc::chain::get_chain_id_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_chain_id(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::koinos::rpc::chain::get_chain_id_request,::koinos::rpc::chain::get_chain_id_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_fork_heads : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_fork_heads() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::koinos::rpc::chain::get_fork_heads_request, ::koinos::rpc::chain::get_fork_heads_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::koinos::rpc::chain::get_fork_heads_request, ::koinos::rpc::chain::get_fork_heads_response>* streamer) {
                       return this->Streamedget_fork_heads(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_fork_heads() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_fork_heads(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_fork_heads_request* /*request*/, ::koinos::rpc::chain::get_fork_heads_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_fork_heads(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::koinos::rpc::chain::get_fork_heads_request,::koinos::rpc::chain::get_fork_heads_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_read_contract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_read_contract() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::koinos::rpc::chain::read_contract_request, ::koinos::rpc::chain::read_contract_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::koinos::rpc::chain::read_contract_request, ::koinos::rpc::chain::read_contract_response>* streamer) {
                       return this->Streamedread_contract(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_read_contract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status read_contract(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::read_contract_request* /*request*/, ::koinos::rpc::chain::read_contract_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedread_contract(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::koinos::rpc::chain::read_contract_request,::koinos::rpc::chain::read_contract_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_account_nonce : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_account_nonce() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::koinos::rpc::chain::get_account_nonce_request, ::koinos::rpc::chain::get_account_nonce_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::koinos::rpc::chain::get_account_nonce_request, ::koinos::rpc::chain::get_account_nonce_response>* streamer) {
                       return this->Streamedget_account_nonce(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_account_nonce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_account_nonce(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_account_nonce_request* /*request*/, ::koinos::rpc::chain::get_account_nonce_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_account_nonce(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::koinos::rpc::chain::get_account_nonce_request,::koinos::rpc::chain::get_account_nonce_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_account_rc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_account_rc() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::koinos::rpc::chain::get_account_rc_request, ::koinos::rpc::chain::get_account_rc_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::koinos::rpc::chain::get_account_rc_request, ::koinos::rpc::chain::get_account_rc_response>* streamer) {
                       return this->Streamedget_account_rc(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_account_rc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_account_rc(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_account_rc_request* /*request*/, ::koinos::rpc::chain::get_account_rc_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_account_rc(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::koinos::rpc::chain::get_account_rc_request,::koinos::rpc::chain::get_account_rc_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_resource_limits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_resource_limits() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::koinos::rpc::chain::get_resource_limits_request, ::koinos::rpc::chain::get_resource_limits_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::koinos::rpc::chain::get_resource_limits_request, ::koinos::rpc::chain::get_resource_limits_response>* streamer) {
                       return this->Streamedget_resource_limits(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_resource_limits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_resource_limits(::grpc::ServerContext* /*context*/, const ::koinos::rpc::chain::get_resource_limits_request* /*request*/, ::koinos::rpc::chain::get_resource_limits_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_resource_limits(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::koinos::rpc::chain::get_resource_limits_request,::koinos::rpc::chain::get_resource_limits_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_contract_meta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_contract_meta() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::koinos::rpc::contract_meta_store::get_contract_meta_request, ::koinos::rpc::contract_meta_store::get_contract_meta_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::koinos::rpc::contract_meta_store::get_contract_meta_request, ::koinos::rpc::contract_meta_store::get_contract_meta_response>* streamer) {
                       return this->Streamedget_contract_meta(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_contract_meta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_contract_meta(::grpc::ServerContext* /*context*/, const ::koinos::rpc::contract_meta_store::get_contract_meta_request* /*request*/, ::koinos::rpc::contract_meta_store::get_contract_meta_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_contract_meta(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::koinos::rpc::contract_meta_store::get_contract_meta_request,::koinos::rpc::contract_meta_store::get_contract_meta_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_pending_transactions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_pending_transactions() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::koinos::rpc::mempool::get_pending_transactions_request, ::koinos::rpc::mempool::get_pending_transactions_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::koinos::rpc::mempool::get_pending_transactions_request, ::koinos::rpc::mempool::get_pending_transactions_response>* streamer) {
                       return this->Streamedget_pending_transactions(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_pending_transactions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_pending_transactions(::grpc::ServerContext* /*context*/, const ::koinos::rpc::mempool::get_pending_transactions_request* /*request*/, ::koinos::rpc::mempool::get_pending_transactions_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_pending_transactions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::koinos::rpc::mempool::get_pending_transactions_request,::koinos::rpc::mempool::get_pending_transactions_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_check_pending_account_resources : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_check_pending_account_resources() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::koinos::rpc::mempool::check_pending_account_resources_request, ::koinos::rpc::mempool::check_pending_account_resources_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::koinos::rpc::mempool::check_pending_account_resources_request, ::koinos::rpc::mempool::check_pending_account_resources_response>* streamer) {
                       return this->Streamedcheck_pending_account_resources(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_check_pending_account_resources() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status check_pending_account_resources(::grpc::ServerContext* /*context*/, const ::koinos::rpc::mempool::check_pending_account_resources_request* /*request*/, ::koinos::rpc::mempool::check_pending_account_resources_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcheck_pending_account_resources(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::koinos::rpc::mempool::check_pending_account_resources_request,::koinos::rpc::mempool::check_pending_account_resources_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_gossip_status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_gossip_status() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::koinos::rpc::p2p::get_gossip_status_request, ::koinos::rpc::p2p::get_gossip_status_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::koinos::rpc::p2p::get_gossip_status_request, ::koinos::rpc::p2p::get_gossip_status_response>* streamer) {
                       return this->Streamedget_gossip_status(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_gossip_status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_gossip_status(::grpc::ServerContext* /*context*/, const ::koinos::rpc::p2p::get_gossip_status_request* /*request*/, ::koinos::rpc::p2p::get_gossip_status_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_gossip_status(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::koinos::rpc::p2p::get_gossip_status_request,::koinos::rpc::p2p::get_gossip_status_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_transactions_by_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_transactions_by_id() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::koinos::rpc::transaction_store::get_transactions_by_id_request, ::koinos::rpc::transaction_store::get_transactions_by_id_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::koinos::rpc::transaction_store::get_transactions_by_id_request, ::koinos::rpc::transaction_store::get_transactions_by_id_response>* streamer) {
                       return this->Streamedget_transactions_by_id(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_transactions_by_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_transactions_by_id(::grpc::ServerContext* /*context*/, const ::koinos::rpc::transaction_store::get_transactions_by_id_request* /*request*/, ::koinos::rpc::transaction_store::get_transactions_by_id_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_transactions_by_id(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::koinos::rpc::transaction_store::get_transactions_by_id_request,::koinos::rpc::transaction_store::get_transactions_by_id_response>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_get_account_history<WithStreamedUnaryMethod_get_blocks_by_id<WithStreamedUnaryMethod_get_blocks_by_height<WithStreamedUnaryMethod_get_highest_block<WithStreamedUnaryMethod_submit_block<WithStreamedUnaryMethod_submit_transaction<WithStreamedUnaryMethod_get_head_info<WithStreamedUnaryMethod_get_chain_id<WithStreamedUnaryMethod_get_fork_heads<WithStreamedUnaryMethod_read_contract<WithStreamedUnaryMethod_get_account_nonce<WithStreamedUnaryMethod_get_account_rc<WithStreamedUnaryMethod_get_resource_limits<WithStreamedUnaryMethod_get_contract_meta<WithStreamedUnaryMethod_get_pending_transactions<WithStreamedUnaryMethod_check_pending_account_resources<WithStreamedUnaryMethod_get_gossip_status<WithStreamedUnaryMethod_get_transactions_by_id<Service > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_get_account_history<WithStreamedUnaryMethod_get_blocks_by_id<WithStreamedUnaryMethod_get_blocks_by_height<WithStreamedUnaryMethod_get_highest_block<WithStreamedUnaryMethod_submit_block<WithStreamedUnaryMethod_submit_transaction<WithStreamedUnaryMethod_get_head_info<WithStreamedUnaryMethod_get_chain_id<WithStreamedUnaryMethod_get_fork_heads<WithStreamedUnaryMethod_read_contract<WithStreamedUnaryMethod_get_account_nonce<WithStreamedUnaryMethod_get_account_rc<WithStreamedUnaryMethod_get_resource_limits<WithStreamedUnaryMethod_get_contract_meta<WithStreamedUnaryMethod_get_pending_transactions<WithStreamedUnaryMethod_check_pending_account_resources<WithStreamedUnaryMethod_get_gossip_status<WithStreamedUnaryMethod_get_transactions_by_id<Service > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace services
}  // namespace koinos


#endif  // GRPC_koinos_2frpc_2fservices_2eproto__INCLUDED
