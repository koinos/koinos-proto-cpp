// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: koinos/chain/system_calls.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_koinos_2fchain_2fsystem_5fcalls_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_koinos_2fchain_2fsystem_5fcalls_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "koinos/options.pb.h"
#include "koinos/protocol/protocol.pb.h"
#include "koinos/chain/authority.pb.h"
#include "koinos/chain/chain.pb.h"
#include "koinos/chain/value.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_koinos_2fchain_2fsystem_5fcalls_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[93]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_koinos_2fchain_2fsystem_5fcalls_2eproto;
namespace koinos {
namespace chain {
class apply_block_arguments;
struct apply_block_argumentsDefaultTypeInternal;
extern apply_block_argumentsDefaultTypeInternal _apply_block_arguments_default_instance_;
class apply_block_result;
struct apply_block_resultDefaultTypeInternal;
extern apply_block_resultDefaultTypeInternal _apply_block_result_default_instance_;
class apply_call_contract_operation_arguments;
struct apply_call_contract_operation_argumentsDefaultTypeInternal;
extern apply_call_contract_operation_argumentsDefaultTypeInternal _apply_call_contract_operation_arguments_default_instance_;
class apply_call_contract_operation_result;
struct apply_call_contract_operation_resultDefaultTypeInternal;
extern apply_call_contract_operation_resultDefaultTypeInternal _apply_call_contract_operation_result_default_instance_;
class apply_set_system_call_operation_arguments;
struct apply_set_system_call_operation_argumentsDefaultTypeInternal;
extern apply_set_system_call_operation_argumentsDefaultTypeInternal _apply_set_system_call_operation_arguments_default_instance_;
class apply_set_system_call_operation_result;
struct apply_set_system_call_operation_resultDefaultTypeInternal;
extern apply_set_system_call_operation_resultDefaultTypeInternal _apply_set_system_call_operation_result_default_instance_;
class apply_set_system_contract_operation_arguments;
struct apply_set_system_contract_operation_argumentsDefaultTypeInternal;
extern apply_set_system_contract_operation_argumentsDefaultTypeInternal _apply_set_system_contract_operation_arguments_default_instance_;
class apply_set_system_contract_operation_result;
struct apply_set_system_contract_operation_resultDefaultTypeInternal;
extern apply_set_system_contract_operation_resultDefaultTypeInternal _apply_set_system_contract_operation_result_default_instance_;
class apply_transaction_arguments;
struct apply_transaction_argumentsDefaultTypeInternal;
extern apply_transaction_argumentsDefaultTypeInternal _apply_transaction_arguments_default_instance_;
class apply_transaction_result;
struct apply_transaction_resultDefaultTypeInternal;
extern apply_transaction_resultDefaultTypeInternal _apply_transaction_result_default_instance_;
class apply_upload_contract_operation_arguments;
struct apply_upload_contract_operation_argumentsDefaultTypeInternal;
extern apply_upload_contract_operation_argumentsDefaultTypeInternal _apply_upload_contract_operation_arguments_default_instance_;
class apply_upload_contract_operation_result;
struct apply_upload_contract_operation_resultDefaultTypeInternal;
extern apply_upload_contract_operation_resultDefaultTypeInternal _apply_upload_contract_operation_result_default_instance_;
class call_arguments;
struct call_argumentsDefaultTypeInternal;
extern call_argumentsDefaultTypeInternal _call_arguments_default_instance_;
class call_result;
struct call_resultDefaultTypeInternal;
extern call_resultDefaultTypeInternal _call_result_default_instance_;
class check_authority_arguments;
struct check_authority_argumentsDefaultTypeInternal;
extern check_authority_argumentsDefaultTypeInternal _check_authority_arguments_default_instance_;
class check_authority_result;
struct check_authority_resultDefaultTypeInternal;
extern check_authority_resultDefaultTypeInternal _check_authority_result_default_instance_;
class check_system_authority_arguments;
struct check_system_authority_argumentsDefaultTypeInternal;
extern check_system_authority_argumentsDefaultTypeInternal _check_system_authority_arguments_default_instance_;
class check_system_authority_result;
struct check_system_authority_resultDefaultTypeInternal;
extern check_system_authority_resultDefaultTypeInternal _check_system_authority_result_default_instance_;
class consume_account_rc_arguments;
struct consume_account_rc_argumentsDefaultTypeInternal;
extern consume_account_rc_argumentsDefaultTypeInternal _consume_account_rc_arguments_default_instance_;
class consume_account_rc_result;
struct consume_account_rc_resultDefaultTypeInternal;
extern consume_account_rc_resultDefaultTypeInternal _consume_account_rc_result_default_instance_;
class consume_block_resources_arguments;
struct consume_block_resources_argumentsDefaultTypeInternal;
extern consume_block_resources_argumentsDefaultTypeInternal _consume_block_resources_arguments_default_instance_;
class consume_block_resources_result;
struct consume_block_resources_resultDefaultTypeInternal;
extern consume_block_resources_resultDefaultTypeInternal _consume_block_resources_result_default_instance_;
class database_object;
struct database_objectDefaultTypeInternal;
extern database_objectDefaultTypeInternal _database_object_default_instance_;
class event_arguments;
struct event_argumentsDefaultTypeInternal;
extern event_argumentsDefaultTypeInternal _event_arguments_default_instance_;
class event_result;
struct event_resultDefaultTypeInternal;
extern event_resultDefaultTypeInternal _event_result_default_instance_;
class exit_arguments;
struct exit_argumentsDefaultTypeInternal;
extern exit_argumentsDefaultTypeInternal _exit_arguments_default_instance_;
class exit_result;
struct exit_resultDefaultTypeInternal;
extern exit_resultDefaultTypeInternal _exit_result_default_instance_;
class get_account_nonce_arguments;
struct get_account_nonce_argumentsDefaultTypeInternal;
extern get_account_nonce_argumentsDefaultTypeInternal _get_account_nonce_arguments_default_instance_;
class get_account_nonce_result;
struct get_account_nonce_resultDefaultTypeInternal;
extern get_account_nonce_resultDefaultTypeInternal _get_account_nonce_result_default_instance_;
class get_account_rc_arguments;
struct get_account_rc_argumentsDefaultTypeInternal;
extern get_account_rc_argumentsDefaultTypeInternal _get_account_rc_arguments_default_instance_;
class get_account_rc_result;
struct get_account_rc_resultDefaultTypeInternal;
extern get_account_rc_resultDefaultTypeInternal _get_account_rc_result_default_instance_;
class get_arguments_arguments;
struct get_arguments_argumentsDefaultTypeInternal;
extern get_arguments_argumentsDefaultTypeInternal _get_arguments_arguments_default_instance_;
class get_arguments_result;
struct get_arguments_resultDefaultTypeInternal;
extern get_arguments_resultDefaultTypeInternal _get_arguments_result_default_instance_;
class get_block_arguments;
struct get_block_argumentsDefaultTypeInternal;
extern get_block_argumentsDefaultTypeInternal _get_block_arguments_default_instance_;
class get_block_field_arguments;
struct get_block_field_argumentsDefaultTypeInternal;
extern get_block_field_argumentsDefaultTypeInternal _get_block_field_arguments_default_instance_;
class get_block_field_result;
struct get_block_field_resultDefaultTypeInternal;
extern get_block_field_resultDefaultTypeInternal _get_block_field_result_default_instance_;
class get_block_result;
struct get_block_resultDefaultTypeInternal;
extern get_block_resultDefaultTypeInternal _get_block_result_default_instance_;
class get_caller_arguments;
struct get_caller_argumentsDefaultTypeInternal;
extern get_caller_argumentsDefaultTypeInternal _get_caller_arguments_default_instance_;
class get_caller_result;
struct get_caller_resultDefaultTypeInternal;
extern get_caller_resultDefaultTypeInternal _get_caller_result_default_instance_;
class get_chain_id_arguments;
struct get_chain_id_argumentsDefaultTypeInternal;
extern get_chain_id_argumentsDefaultTypeInternal _get_chain_id_arguments_default_instance_;
class get_chain_id_result;
struct get_chain_id_resultDefaultTypeInternal;
extern get_chain_id_resultDefaultTypeInternal _get_chain_id_result_default_instance_;
class get_contract_id_arguments;
struct get_contract_id_argumentsDefaultTypeInternal;
extern get_contract_id_argumentsDefaultTypeInternal _get_contract_id_arguments_default_instance_;
class get_contract_id_result;
struct get_contract_id_resultDefaultTypeInternal;
extern get_contract_id_resultDefaultTypeInternal _get_contract_id_result_default_instance_;
class get_head_info_arguments;
struct get_head_info_argumentsDefaultTypeInternal;
extern get_head_info_argumentsDefaultTypeInternal _get_head_info_arguments_default_instance_;
class get_head_info_result;
struct get_head_info_resultDefaultTypeInternal;
extern get_head_info_resultDefaultTypeInternal _get_head_info_result_default_instance_;
class get_last_irreversible_block_arguments;
struct get_last_irreversible_block_argumentsDefaultTypeInternal;
extern get_last_irreversible_block_argumentsDefaultTypeInternal _get_last_irreversible_block_arguments_default_instance_;
class get_last_irreversible_block_result;
struct get_last_irreversible_block_resultDefaultTypeInternal;
extern get_last_irreversible_block_resultDefaultTypeInternal _get_last_irreversible_block_result_default_instance_;
class get_next_object_arguments;
struct get_next_object_argumentsDefaultTypeInternal;
extern get_next_object_argumentsDefaultTypeInternal _get_next_object_arguments_default_instance_;
class get_next_object_result;
struct get_next_object_resultDefaultTypeInternal;
extern get_next_object_resultDefaultTypeInternal _get_next_object_result_default_instance_;
class get_object_arguments;
struct get_object_argumentsDefaultTypeInternal;
extern get_object_argumentsDefaultTypeInternal _get_object_arguments_default_instance_;
class get_object_result;
struct get_object_resultDefaultTypeInternal;
extern get_object_resultDefaultTypeInternal _get_object_result_default_instance_;
class get_operation_arguments;
struct get_operation_argumentsDefaultTypeInternal;
extern get_operation_argumentsDefaultTypeInternal _get_operation_arguments_default_instance_;
class get_operation_result;
struct get_operation_resultDefaultTypeInternal;
extern get_operation_resultDefaultTypeInternal _get_operation_result_default_instance_;
class get_prev_object_arguments;
struct get_prev_object_argumentsDefaultTypeInternal;
extern get_prev_object_argumentsDefaultTypeInternal _get_prev_object_arguments_default_instance_;
class get_prev_object_result;
struct get_prev_object_resultDefaultTypeInternal;
extern get_prev_object_resultDefaultTypeInternal _get_prev_object_result_default_instance_;
class get_resource_limits_arguments;
struct get_resource_limits_argumentsDefaultTypeInternal;
extern get_resource_limits_argumentsDefaultTypeInternal _get_resource_limits_arguments_default_instance_;
class get_resource_limits_result;
struct get_resource_limits_resultDefaultTypeInternal;
extern get_resource_limits_resultDefaultTypeInternal _get_resource_limits_result_default_instance_;
class get_transaction_arguments;
struct get_transaction_argumentsDefaultTypeInternal;
extern get_transaction_argumentsDefaultTypeInternal _get_transaction_arguments_default_instance_;
class get_transaction_field_arguments;
struct get_transaction_field_argumentsDefaultTypeInternal;
extern get_transaction_field_argumentsDefaultTypeInternal _get_transaction_field_arguments_default_instance_;
class get_transaction_field_result;
struct get_transaction_field_resultDefaultTypeInternal;
extern get_transaction_field_resultDefaultTypeInternal _get_transaction_field_result_default_instance_;
class get_transaction_result;
struct get_transaction_resultDefaultTypeInternal;
extern get_transaction_resultDefaultTypeInternal _get_transaction_result_default_instance_;
class hash_arguments;
struct hash_argumentsDefaultTypeInternal;
extern hash_argumentsDefaultTypeInternal _hash_arguments_default_instance_;
class hash_result;
struct hash_resultDefaultTypeInternal;
extern hash_resultDefaultTypeInternal _hash_result_default_instance_;
class log_arguments;
struct log_argumentsDefaultTypeInternal;
extern log_argumentsDefaultTypeInternal _log_arguments_default_instance_;
class log_result;
struct log_resultDefaultTypeInternal;
extern log_resultDefaultTypeInternal _log_result_default_instance_;
class nop_arguments;
struct nop_argumentsDefaultTypeInternal;
extern nop_argumentsDefaultTypeInternal _nop_arguments_default_instance_;
class nop_result;
struct nop_resultDefaultTypeInternal;
extern nop_resultDefaultTypeInternal _nop_result_default_instance_;
class post_block_callback_arguments;
struct post_block_callback_argumentsDefaultTypeInternal;
extern post_block_callback_argumentsDefaultTypeInternal _post_block_callback_arguments_default_instance_;
class post_block_callback_result;
struct post_block_callback_resultDefaultTypeInternal;
extern post_block_callback_resultDefaultTypeInternal _post_block_callback_result_default_instance_;
class post_transaction_callback_arguments;
struct post_transaction_callback_argumentsDefaultTypeInternal;
extern post_transaction_callback_argumentsDefaultTypeInternal _post_transaction_callback_arguments_default_instance_;
class post_transaction_callback_result;
struct post_transaction_callback_resultDefaultTypeInternal;
extern post_transaction_callback_resultDefaultTypeInternal _post_transaction_callback_result_default_instance_;
class pre_block_callback_arguments;
struct pre_block_callback_argumentsDefaultTypeInternal;
extern pre_block_callback_argumentsDefaultTypeInternal _pre_block_callback_arguments_default_instance_;
class pre_block_callback_result;
struct pre_block_callback_resultDefaultTypeInternal;
extern pre_block_callback_resultDefaultTypeInternal _pre_block_callback_result_default_instance_;
class pre_transaction_callback_arguments;
struct pre_transaction_callback_argumentsDefaultTypeInternal;
extern pre_transaction_callback_argumentsDefaultTypeInternal _pre_transaction_callback_arguments_default_instance_;
class pre_transaction_callback_result;
struct pre_transaction_callback_resultDefaultTypeInternal;
extern pre_transaction_callback_resultDefaultTypeInternal _pre_transaction_callback_result_default_instance_;
class process_block_signature_arguments;
struct process_block_signature_argumentsDefaultTypeInternal;
extern process_block_signature_argumentsDefaultTypeInternal _process_block_signature_arguments_default_instance_;
class process_block_signature_result;
struct process_block_signature_resultDefaultTypeInternal;
extern process_block_signature_resultDefaultTypeInternal _process_block_signature_result_default_instance_;
class put_object_arguments;
struct put_object_argumentsDefaultTypeInternal;
extern put_object_argumentsDefaultTypeInternal _put_object_arguments_default_instance_;
class put_object_result;
struct put_object_resultDefaultTypeInternal;
extern put_object_resultDefaultTypeInternal _put_object_result_default_instance_;
class recover_public_key_arguments;
struct recover_public_key_argumentsDefaultTypeInternal;
extern recover_public_key_argumentsDefaultTypeInternal _recover_public_key_arguments_default_instance_;
class recover_public_key_result;
struct recover_public_key_resultDefaultTypeInternal;
extern recover_public_key_resultDefaultTypeInternal _recover_public_key_result_default_instance_;
class remove_object_arguments;
struct remove_object_argumentsDefaultTypeInternal;
extern remove_object_argumentsDefaultTypeInternal _remove_object_arguments_default_instance_;
class remove_object_result;
struct remove_object_resultDefaultTypeInternal;
extern remove_object_resultDefaultTypeInternal _remove_object_result_default_instance_;
class set_account_nonce_arguments;
struct set_account_nonce_argumentsDefaultTypeInternal;
extern set_account_nonce_argumentsDefaultTypeInternal _set_account_nonce_arguments_default_instance_;
class set_account_nonce_result;
struct set_account_nonce_resultDefaultTypeInternal;
extern set_account_nonce_resultDefaultTypeInternal _set_account_nonce_result_default_instance_;
class verify_account_nonce_arguments;
struct verify_account_nonce_argumentsDefaultTypeInternal;
extern verify_account_nonce_argumentsDefaultTypeInternal _verify_account_nonce_arguments_default_instance_;
class verify_account_nonce_result;
struct verify_account_nonce_resultDefaultTypeInternal;
extern verify_account_nonce_resultDefaultTypeInternal _verify_account_nonce_result_default_instance_;
class verify_merkle_root_arguments;
struct verify_merkle_root_argumentsDefaultTypeInternal;
extern verify_merkle_root_argumentsDefaultTypeInternal _verify_merkle_root_arguments_default_instance_;
class verify_merkle_root_result;
struct verify_merkle_root_resultDefaultTypeInternal;
extern verify_merkle_root_resultDefaultTypeInternal _verify_merkle_root_result_default_instance_;
class verify_signature_arguments;
struct verify_signature_argumentsDefaultTypeInternal;
extern verify_signature_argumentsDefaultTypeInternal _verify_signature_arguments_default_instance_;
class verify_signature_result;
struct verify_signature_resultDefaultTypeInternal;
extern verify_signature_resultDefaultTypeInternal _verify_signature_result_default_instance_;
class verify_vrf_proof_arguments;
struct verify_vrf_proof_argumentsDefaultTypeInternal;
extern verify_vrf_proof_argumentsDefaultTypeInternal _verify_vrf_proof_arguments_default_instance_;
class verify_vrf_proof_result;
struct verify_vrf_proof_resultDefaultTypeInternal;
extern verify_vrf_proof_resultDefaultTypeInternal _verify_vrf_proof_result_default_instance_;
}  // namespace chain
}  // namespace koinos
PROTOBUF_NAMESPACE_OPEN
template<> ::koinos::chain::apply_block_arguments* Arena::CreateMaybeMessage<::koinos::chain::apply_block_arguments>(Arena*);
template<> ::koinos::chain::apply_block_result* Arena::CreateMaybeMessage<::koinos::chain::apply_block_result>(Arena*);
template<> ::koinos::chain::apply_call_contract_operation_arguments* Arena::CreateMaybeMessage<::koinos::chain::apply_call_contract_operation_arguments>(Arena*);
template<> ::koinos::chain::apply_call_contract_operation_result* Arena::CreateMaybeMessage<::koinos::chain::apply_call_contract_operation_result>(Arena*);
template<> ::koinos::chain::apply_set_system_call_operation_arguments* Arena::CreateMaybeMessage<::koinos::chain::apply_set_system_call_operation_arguments>(Arena*);
template<> ::koinos::chain::apply_set_system_call_operation_result* Arena::CreateMaybeMessage<::koinos::chain::apply_set_system_call_operation_result>(Arena*);
template<> ::koinos::chain::apply_set_system_contract_operation_arguments* Arena::CreateMaybeMessage<::koinos::chain::apply_set_system_contract_operation_arguments>(Arena*);
template<> ::koinos::chain::apply_set_system_contract_operation_result* Arena::CreateMaybeMessage<::koinos::chain::apply_set_system_contract_operation_result>(Arena*);
template<> ::koinos::chain::apply_transaction_arguments* Arena::CreateMaybeMessage<::koinos::chain::apply_transaction_arguments>(Arena*);
template<> ::koinos::chain::apply_transaction_result* Arena::CreateMaybeMessage<::koinos::chain::apply_transaction_result>(Arena*);
template<> ::koinos::chain::apply_upload_contract_operation_arguments* Arena::CreateMaybeMessage<::koinos::chain::apply_upload_contract_operation_arguments>(Arena*);
template<> ::koinos::chain::apply_upload_contract_operation_result* Arena::CreateMaybeMessage<::koinos::chain::apply_upload_contract_operation_result>(Arena*);
template<> ::koinos::chain::call_arguments* Arena::CreateMaybeMessage<::koinos::chain::call_arguments>(Arena*);
template<> ::koinos::chain::call_result* Arena::CreateMaybeMessage<::koinos::chain::call_result>(Arena*);
template<> ::koinos::chain::check_authority_arguments* Arena::CreateMaybeMessage<::koinos::chain::check_authority_arguments>(Arena*);
template<> ::koinos::chain::check_authority_result* Arena::CreateMaybeMessage<::koinos::chain::check_authority_result>(Arena*);
template<> ::koinos::chain::check_system_authority_arguments* Arena::CreateMaybeMessage<::koinos::chain::check_system_authority_arguments>(Arena*);
template<> ::koinos::chain::check_system_authority_result* Arena::CreateMaybeMessage<::koinos::chain::check_system_authority_result>(Arena*);
template<> ::koinos::chain::consume_account_rc_arguments* Arena::CreateMaybeMessage<::koinos::chain::consume_account_rc_arguments>(Arena*);
template<> ::koinos::chain::consume_account_rc_result* Arena::CreateMaybeMessage<::koinos::chain::consume_account_rc_result>(Arena*);
template<> ::koinos::chain::consume_block_resources_arguments* Arena::CreateMaybeMessage<::koinos::chain::consume_block_resources_arguments>(Arena*);
template<> ::koinos::chain::consume_block_resources_result* Arena::CreateMaybeMessage<::koinos::chain::consume_block_resources_result>(Arena*);
template<> ::koinos::chain::database_object* Arena::CreateMaybeMessage<::koinos::chain::database_object>(Arena*);
template<> ::koinos::chain::event_arguments* Arena::CreateMaybeMessage<::koinos::chain::event_arguments>(Arena*);
template<> ::koinos::chain::event_result* Arena::CreateMaybeMessage<::koinos::chain::event_result>(Arena*);
template<> ::koinos::chain::exit_arguments* Arena::CreateMaybeMessage<::koinos::chain::exit_arguments>(Arena*);
template<> ::koinos::chain::exit_result* Arena::CreateMaybeMessage<::koinos::chain::exit_result>(Arena*);
template<> ::koinos::chain::get_account_nonce_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_account_nonce_arguments>(Arena*);
template<> ::koinos::chain::get_account_nonce_result* Arena::CreateMaybeMessage<::koinos::chain::get_account_nonce_result>(Arena*);
template<> ::koinos::chain::get_account_rc_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_account_rc_arguments>(Arena*);
template<> ::koinos::chain::get_account_rc_result* Arena::CreateMaybeMessage<::koinos::chain::get_account_rc_result>(Arena*);
template<> ::koinos::chain::get_arguments_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_arguments_arguments>(Arena*);
template<> ::koinos::chain::get_arguments_result* Arena::CreateMaybeMessage<::koinos::chain::get_arguments_result>(Arena*);
template<> ::koinos::chain::get_block_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_block_arguments>(Arena*);
template<> ::koinos::chain::get_block_field_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_block_field_arguments>(Arena*);
template<> ::koinos::chain::get_block_field_result* Arena::CreateMaybeMessage<::koinos::chain::get_block_field_result>(Arena*);
template<> ::koinos::chain::get_block_result* Arena::CreateMaybeMessage<::koinos::chain::get_block_result>(Arena*);
template<> ::koinos::chain::get_caller_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_caller_arguments>(Arena*);
template<> ::koinos::chain::get_caller_result* Arena::CreateMaybeMessage<::koinos::chain::get_caller_result>(Arena*);
template<> ::koinos::chain::get_chain_id_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_chain_id_arguments>(Arena*);
template<> ::koinos::chain::get_chain_id_result* Arena::CreateMaybeMessage<::koinos::chain::get_chain_id_result>(Arena*);
template<> ::koinos::chain::get_contract_id_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_contract_id_arguments>(Arena*);
template<> ::koinos::chain::get_contract_id_result* Arena::CreateMaybeMessage<::koinos::chain::get_contract_id_result>(Arena*);
template<> ::koinos::chain::get_head_info_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_head_info_arguments>(Arena*);
template<> ::koinos::chain::get_head_info_result* Arena::CreateMaybeMessage<::koinos::chain::get_head_info_result>(Arena*);
template<> ::koinos::chain::get_last_irreversible_block_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_last_irreversible_block_arguments>(Arena*);
template<> ::koinos::chain::get_last_irreversible_block_result* Arena::CreateMaybeMessage<::koinos::chain::get_last_irreversible_block_result>(Arena*);
template<> ::koinos::chain::get_next_object_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_next_object_arguments>(Arena*);
template<> ::koinos::chain::get_next_object_result* Arena::CreateMaybeMessage<::koinos::chain::get_next_object_result>(Arena*);
template<> ::koinos::chain::get_object_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_object_arguments>(Arena*);
template<> ::koinos::chain::get_object_result* Arena::CreateMaybeMessage<::koinos::chain::get_object_result>(Arena*);
template<> ::koinos::chain::get_operation_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_operation_arguments>(Arena*);
template<> ::koinos::chain::get_operation_result* Arena::CreateMaybeMessage<::koinos::chain::get_operation_result>(Arena*);
template<> ::koinos::chain::get_prev_object_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_prev_object_arguments>(Arena*);
template<> ::koinos::chain::get_prev_object_result* Arena::CreateMaybeMessage<::koinos::chain::get_prev_object_result>(Arena*);
template<> ::koinos::chain::get_resource_limits_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_resource_limits_arguments>(Arena*);
template<> ::koinos::chain::get_resource_limits_result* Arena::CreateMaybeMessage<::koinos::chain::get_resource_limits_result>(Arena*);
template<> ::koinos::chain::get_transaction_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_transaction_arguments>(Arena*);
template<> ::koinos::chain::get_transaction_field_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_transaction_field_arguments>(Arena*);
template<> ::koinos::chain::get_transaction_field_result* Arena::CreateMaybeMessage<::koinos::chain::get_transaction_field_result>(Arena*);
template<> ::koinos::chain::get_transaction_result* Arena::CreateMaybeMessage<::koinos::chain::get_transaction_result>(Arena*);
template<> ::koinos::chain::hash_arguments* Arena::CreateMaybeMessage<::koinos::chain::hash_arguments>(Arena*);
template<> ::koinos::chain::hash_result* Arena::CreateMaybeMessage<::koinos::chain::hash_result>(Arena*);
template<> ::koinos::chain::log_arguments* Arena::CreateMaybeMessage<::koinos::chain::log_arguments>(Arena*);
template<> ::koinos::chain::log_result* Arena::CreateMaybeMessage<::koinos::chain::log_result>(Arena*);
template<> ::koinos::chain::nop_arguments* Arena::CreateMaybeMessage<::koinos::chain::nop_arguments>(Arena*);
template<> ::koinos::chain::nop_result* Arena::CreateMaybeMessage<::koinos::chain::nop_result>(Arena*);
template<> ::koinos::chain::post_block_callback_arguments* Arena::CreateMaybeMessage<::koinos::chain::post_block_callback_arguments>(Arena*);
template<> ::koinos::chain::post_block_callback_result* Arena::CreateMaybeMessage<::koinos::chain::post_block_callback_result>(Arena*);
template<> ::koinos::chain::post_transaction_callback_arguments* Arena::CreateMaybeMessage<::koinos::chain::post_transaction_callback_arguments>(Arena*);
template<> ::koinos::chain::post_transaction_callback_result* Arena::CreateMaybeMessage<::koinos::chain::post_transaction_callback_result>(Arena*);
template<> ::koinos::chain::pre_block_callback_arguments* Arena::CreateMaybeMessage<::koinos::chain::pre_block_callback_arguments>(Arena*);
template<> ::koinos::chain::pre_block_callback_result* Arena::CreateMaybeMessage<::koinos::chain::pre_block_callback_result>(Arena*);
template<> ::koinos::chain::pre_transaction_callback_arguments* Arena::CreateMaybeMessage<::koinos::chain::pre_transaction_callback_arguments>(Arena*);
template<> ::koinos::chain::pre_transaction_callback_result* Arena::CreateMaybeMessage<::koinos::chain::pre_transaction_callback_result>(Arena*);
template<> ::koinos::chain::process_block_signature_arguments* Arena::CreateMaybeMessage<::koinos::chain::process_block_signature_arguments>(Arena*);
template<> ::koinos::chain::process_block_signature_result* Arena::CreateMaybeMessage<::koinos::chain::process_block_signature_result>(Arena*);
template<> ::koinos::chain::put_object_arguments* Arena::CreateMaybeMessage<::koinos::chain::put_object_arguments>(Arena*);
template<> ::koinos::chain::put_object_result* Arena::CreateMaybeMessage<::koinos::chain::put_object_result>(Arena*);
template<> ::koinos::chain::recover_public_key_arguments* Arena::CreateMaybeMessage<::koinos::chain::recover_public_key_arguments>(Arena*);
template<> ::koinos::chain::recover_public_key_result* Arena::CreateMaybeMessage<::koinos::chain::recover_public_key_result>(Arena*);
template<> ::koinos::chain::remove_object_arguments* Arena::CreateMaybeMessage<::koinos::chain::remove_object_arguments>(Arena*);
template<> ::koinos::chain::remove_object_result* Arena::CreateMaybeMessage<::koinos::chain::remove_object_result>(Arena*);
template<> ::koinos::chain::set_account_nonce_arguments* Arena::CreateMaybeMessage<::koinos::chain::set_account_nonce_arguments>(Arena*);
template<> ::koinos::chain::set_account_nonce_result* Arena::CreateMaybeMessage<::koinos::chain::set_account_nonce_result>(Arena*);
template<> ::koinos::chain::verify_account_nonce_arguments* Arena::CreateMaybeMessage<::koinos::chain::verify_account_nonce_arguments>(Arena*);
template<> ::koinos::chain::verify_account_nonce_result* Arena::CreateMaybeMessage<::koinos::chain::verify_account_nonce_result>(Arena*);
template<> ::koinos::chain::verify_merkle_root_arguments* Arena::CreateMaybeMessage<::koinos::chain::verify_merkle_root_arguments>(Arena*);
template<> ::koinos::chain::verify_merkle_root_result* Arena::CreateMaybeMessage<::koinos::chain::verify_merkle_root_result>(Arena*);
template<> ::koinos::chain::verify_signature_arguments* Arena::CreateMaybeMessage<::koinos::chain::verify_signature_arguments>(Arena*);
template<> ::koinos::chain::verify_signature_result* Arena::CreateMaybeMessage<::koinos::chain::verify_signature_result>(Arena*);
template<> ::koinos::chain::verify_vrf_proof_arguments* Arena::CreateMaybeMessage<::koinos::chain::verify_vrf_proof_arguments>(Arena*);
template<> ::koinos::chain::verify_vrf_proof_result* Arena::CreateMaybeMessage<::koinos::chain::verify_vrf_proof_result>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace koinos {
namespace chain {

enum system_authorization_type : int {
  set_system_contract = 0,
  set_system_call = 1,
  system_authorization_type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  system_authorization_type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool system_authorization_type_IsValid(int value);
constexpr system_authorization_type system_authorization_type_MIN = set_system_contract;
constexpr system_authorization_type system_authorization_type_MAX = set_system_call;
constexpr int system_authorization_type_ARRAYSIZE = system_authorization_type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* system_authorization_type_descriptor();
template<typename T>
inline const std::string& system_authorization_type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, system_authorization_type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function system_authorization_type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    system_authorization_type_descriptor(), enum_t_value);
}
inline bool system_authorization_type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, system_authorization_type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<system_authorization_type>(
    system_authorization_type_descriptor(), name, value);
}
// ===================================================================

class nop_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.nop_arguments) */ {
 public:
  inline nop_arguments() : nop_arguments(nullptr) {}
  ~nop_arguments() override;
  explicit constexpr nop_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  nop_arguments(const nop_arguments& from);
  nop_arguments(nop_arguments&& from) noexcept
    : nop_arguments() {
    *this = ::std::move(from);
  }

  inline nop_arguments& operator=(const nop_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline nop_arguments& operator=(nop_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const nop_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const nop_arguments* internal_default_instance() {
    return reinterpret_cast<const nop_arguments*>(
               &_nop_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(nop_arguments& a, nop_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(nop_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(nop_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline nop_arguments* New() const final {
    return new nop_arguments();
  }

  nop_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<nop_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const nop_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const nop_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(nop_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.nop_arguments";
  }
  protected:
  explicit nop_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.nop_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class nop_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.nop_result) */ {
 public:
  inline nop_result() : nop_result(nullptr) {}
  ~nop_result() override;
  explicit constexpr nop_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  nop_result(const nop_result& from);
  nop_result(nop_result&& from) noexcept
    : nop_result() {
    *this = ::std::move(from);
  }

  inline nop_result& operator=(const nop_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline nop_result& operator=(nop_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const nop_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const nop_result* internal_default_instance() {
    return reinterpret_cast<const nop_result*>(
               &_nop_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(nop_result& a, nop_result& b) {
    a.Swap(&b);
  }
  inline void Swap(nop_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(nop_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline nop_result* New() const final {
    return new nop_result();
  }

  nop_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<nop_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const nop_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const nop_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(nop_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.nop_result";
  }
  protected:
  explicit nop_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.nop_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_head_info_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_head_info_arguments) */ {
 public:
  inline get_head_info_arguments() : get_head_info_arguments(nullptr) {}
  ~get_head_info_arguments() override;
  explicit constexpr get_head_info_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_head_info_arguments(const get_head_info_arguments& from);
  get_head_info_arguments(get_head_info_arguments&& from) noexcept
    : get_head_info_arguments() {
    *this = ::std::move(from);
  }

  inline get_head_info_arguments& operator=(const get_head_info_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_head_info_arguments& operator=(get_head_info_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_head_info_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_head_info_arguments* internal_default_instance() {
    return reinterpret_cast<const get_head_info_arguments*>(
               &_get_head_info_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(get_head_info_arguments& a, get_head_info_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_head_info_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_head_info_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_head_info_arguments* New() const final {
    return new get_head_info_arguments();
  }

  get_head_info_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_head_info_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_head_info_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_head_info_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_head_info_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_head_info_arguments";
  }
  protected:
  explicit get_head_info_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.get_head_info_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_head_info_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_head_info_result) */ {
 public:
  inline get_head_info_result() : get_head_info_result(nullptr) {}
  ~get_head_info_result() override;
  explicit constexpr get_head_info_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_head_info_result(const get_head_info_result& from);
  get_head_info_result(get_head_info_result&& from) noexcept
    : get_head_info_result() {
    *this = ::std::move(from);
  }

  inline get_head_info_result& operator=(const get_head_info_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_head_info_result& operator=(get_head_info_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_head_info_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_head_info_result* internal_default_instance() {
    return reinterpret_cast<const get_head_info_result*>(
               &_get_head_info_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(get_head_info_result& a, get_head_info_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_head_info_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_head_info_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_head_info_result* New() const final {
    return new get_head_info_result();
  }

  get_head_info_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_head_info_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_head_info_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_head_info_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_head_info_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_head_info_result";
  }
  protected:
  explicit get_head_info_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .koinos.chain.head_info value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::koinos::chain::head_info& value() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::head_info* release_value();
  ::koinos::chain::head_info* mutable_value();
  void set_allocated_value(::koinos::chain::head_info* value);
  private:
  const ::koinos::chain::head_info& _internal_value() const;
  ::koinos::chain::head_info* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::koinos::chain::head_info* value);
  ::koinos::chain::head_info* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:koinos.chain.get_head_info_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::chain::head_info* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class apply_block_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_block_arguments) */ {
 public:
  inline apply_block_arguments() : apply_block_arguments(nullptr) {}
  ~apply_block_arguments() override;
  explicit constexpr apply_block_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_block_arguments(const apply_block_arguments& from);
  apply_block_arguments(apply_block_arguments&& from) noexcept
    : apply_block_arguments() {
    *this = ::std::move(from);
  }

  inline apply_block_arguments& operator=(const apply_block_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_block_arguments& operator=(apply_block_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_block_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_block_arguments* internal_default_instance() {
    return reinterpret_cast<const apply_block_arguments*>(
               &_apply_block_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(apply_block_arguments& a, apply_block_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_block_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_block_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_block_arguments* New() const final {
    return new apply_block_arguments();
  }

  apply_block_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_block_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_block_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_block_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_block_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_block_arguments";
  }
  protected:
  explicit apply_block_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 1,
  };
  // .koinos.protocol.block block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::koinos::protocol::block& block() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::protocol::block* release_block();
  ::koinos::protocol::block* mutable_block();
  void set_allocated_block(::koinos::protocol::block* block);
  private:
  const ::koinos::protocol::block& _internal_block() const;
  ::koinos::protocol::block* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::koinos::protocol::block* block);
  ::koinos::protocol::block* unsafe_arena_release_block();

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_block_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::protocol::block* block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class apply_block_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_block_result) */ {
 public:
  inline apply_block_result() : apply_block_result(nullptr) {}
  ~apply_block_result() override;
  explicit constexpr apply_block_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_block_result(const apply_block_result& from);
  apply_block_result(apply_block_result&& from) noexcept
    : apply_block_result() {
    *this = ::std::move(from);
  }

  inline apply_block_result& operator=(const apply_block_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_block_result& operator=(apply_block_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_block_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_block_result* internal_default_instance() {
    return reinterpret_cast<const apply_block_result*>(
               &_apply_block_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(apply_block_result& a, apply_block_result& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_block_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_block_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_block_result* New() const final {
    return new apply_block_result();
  }

  apply_block_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_block_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_block_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_block_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_block_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_block_result";
  }
  protected:
  explicit apply_block_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_block_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class apply_transaction_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_transaction_arguments) */ {
 public:
  inline apply_transaction_arguments() : apply_transaction_arguments(nullptr) {}
  ~apply_transaction_arguments() override;
  explicit constexpr apply_transaction_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_transaction_arguments(const apply_transaction_arguments& from);
  apply_transaction_arguments(apply_transaction_arguments&& from) noexcept
    : apply_transaction_arguments() {
    *this = ::std::move(from);
  }

  inline apply_transaction_arguments& operator=(const apply_transaction_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_transaction_arguments& operator=(apply_transaction_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_transaction_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_transaction_arguments* internal_default_instance() {
    return reinterpret_cast<const apply_transaction_arguments*>(
               &_apply_transaction_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(apply_transaction_arguments& a, apply_transaction_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_transaction_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_transaction_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_transaction_arguments* New() const final {
    return new apply_transaction_arguments();
  }

  apply_transaction_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_transaction_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_transaction_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_transaction_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_transaction_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_transaction_arguments";
  }
  protected:
  explicit apply_transaction_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionFieldNumber = 1,
  };
  // .koinos.protocol.transaction transaction = 1;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::koinos::protocol::transaction& transaction() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::protocol::transaction* release_transaction();
  ::koinos::protocol::transaction* mutable_transaction();
  void set_allocated_transaction(::koinos::protocol::transaction* transaction);
  private:
  const ::koinos::protocol::transaction& _internal_transaction() const;
  ::koinos::protocol::transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::koinos::protocol::transaction* transaction);
  ::koinos::protocol::transaction* unsafe_arena_release_transaction();

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_transaction_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::protocol::transaction* transaction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class apply_transaction_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_transaction_result) */ {
 public:
  inline apply_transaction_result() : apply_transaction_result(nullptr) {}
  ~apply_transaction_result() override;
  explicit constexpr apply_transaction_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_transaction_result(const apply_transaction_result& from);
  apply_transaction_result(apply_transaction_result&& from) noexcept
    : apply_transaction_result() {
    *this = ::std::move(from);
  }

  inline apply_transaction_result& operator=(const apply_transaction_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_transaction_result& operator=(apply_transaction_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_transaction_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_transaction_result* internal_default_instance() {
    return reinterpret_cast<const apply_transaction_result*>(
               &_apply_transaction_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(apply_transaction_result& a, apply_transaction_result& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_transaction_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_transaction_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_transaction_result* New() const final {
    return new apply_transaction_result();
  }

  apply_transaction_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_transaction_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_transaction_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_transaction_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_transaction_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_transaction_result";
  }
  protected:
  explicit apply_transaction_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_transaction_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class apply_upload_contract_operation_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_upload_contract_operation_arguments) */ {
 public:
  inline apply_upload_contract_operation_arguments() : apply_upload_contract_operation_arguments(nullptr) {}
  ~apply_upload_contract_operation_arguments() override;
  explicit constexpr apply_upload_contract_operation_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_upload_contract_operation_arguments(const apply_upload_contract_operation_arguments& from);
  apply_upload_contract_operation_arguments(apply_upload_contract_operation_arguments&& from) noexcept
    : apply_upload_contract_operation_arguments() {
    *this = ::std::move(from);
  }

  inline apply_upload_contract_operation_arguments& operator=(const apply_upload_contract_operation_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_upload_contract_operation_arguments& operator=(apply_upload_contract_operation_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_upload_contract_operation_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_upload_contract_operation_arguments* internal_default_instance() {
    return reinterpret_cast<const apply_upload_contract_operation_arguments*>(
               &_apply_upload_contract_operation_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(apply_upload_contract_operation_arguments& a, apply_upload_contract_operation_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_upload_contract_operation_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_upload_contract_operation_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_upload_contract_operation_arguments* New() const final {
    return new apply_upload_contract_operation_arguments();
  }

  apply_upload_contract_operation_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_upload_contract_operation_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_upload_contract_operation_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_upload_contract_operation_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_upload_contract_operation_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_upload_contract_operation_arguments";
  }
  protected:
  explicit apply_upload_contract_operation_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpFieldNumber = 1,
  };
  // .koinos.protocol.upload_contract_operation op = 1;
  bool has_op() const;
  private:
  bool _internal_has_op() const;
  public:
  void clear_op();
  const ::koinos::protocol::upload_contract_operation& op() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::protocol::upload_contract_operation* release_op();
  ::koinos::protocol::upload_contract_operation* mutable_op();
  void set_allocated_op(::koinos::protocol::upload_contract_operation* op);
  private:
  const ::koinos::protocol::upload_contract_operation& _internal_op() const;
  ::koinos::protocol::upload_contract_operation* _internal_mutable_op();
  public:
  void unsafe_arena_set_allocated_op(
      ::koinos::protocol::upload_contract_operation* op);
  ::koinos::protocol::upload_contract_operation* unsafe_arena_release_op();

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_upload_contract_operation_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::protocol::upload_contract_operation* op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class apply_upload_contract_operation_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_upload_contract_operation_result) */ {
 public:
  inline apply_upload_contract_operation_result() : apply_upload_contract_operation_result(nullptr) {}
  ~apply_upload_contract_operation_result() override;
  explicit constexpr apply_upload_contract_operation_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_upload_contract_operation_result(const apply_upload_contract_operation_result& from);
  apply_upload_contract_operation_result(apply_upload_contract_operation_result&& from) noexcept
    : apply_upload_contract_operation_result() {
    *this = ::std::move(from);
  }

  inline apply_upload_contract_operation_result& operator=(const apply_upload_contract_operation_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_upload_contract_operation_result& operator=(apply_upload_contract_operation_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_upload_contract_operation_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_upload_contract_operation_result* internal_default_instance() {
    return reinterpret_cast<const apply_upload_contract_operation_result*>(
               &_apply_upload_contract_operation_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(apply_upload_contract_operation_result& a, apply_upload_contract_operation_result& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_upload_contract_operation_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_upload_contract_operation_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_upload_contract_operation_result* New() const final {
    return new apply_upload_contract_operation_result();
  }

  apply_upload_contract_operation_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_upload_contract_operation_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_upload_contract_operation_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_upload_contract_operation_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_upload_contract_operation_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_upload_contract_operation_result";
  }
  protected:
  explicit apply_upload_contract_operation_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_upload_contract_operation_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class apply_call_contract_operation_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_call_contract_operation_arguments) */ {
 public:
  inline apply_call_contract_operation_arguments() : apply_call_contract_operation_arguments(nullptr) {}
  ~apply_call_contract_operation_arguments() override;
  explicit constexpr apply_call_contract_operation_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_call_contract_operation_arguments(const apply_call_contract_operation_arguments& from);
  apply_call_contract_operation_arguments(apply_call_contract_operation_arguments&& from) noexcept
    : apply_call_contract_operation_arguments() {
    *this = ::std::move(from);
  }

  inline apply_call_contract_operation_arguments& operator=(const apply_call_contract_operation_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_call_contract_operation_arguments& operator=(apply_call_contract_operation_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_call_contract_operation_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_call_contract_operation_arguments* internal_default_instance() {
    return reinterpret_cast<const apply_call_contract_operation_arguments*>(
               &_apply_call_contract_operation_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(apply_call_contract_operation_arguments& a, apply_call_contract_operation_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_call_contract_operation_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_call_contract_operation_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_call_contract_operation_arguments* New() const final {
    return new apply_call_contract_operation_arguments();
  }

  apply_call_contract_operation_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_call_contract_operation_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_call_contract_operation_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_call_contract_operation_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_call_contract_operation_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_call_contract_operation_arguments";
  }
  protected:
  explicit apply_call_contract_operation_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpFieldNumber = 1,
  };
  // .koinos.protocol.call_contract_operation op = 1;
  bool has_op() const;
  private:
  bool _internal_has_op() const;
  public:
  void clear_op();
  const ::koinos::protocol::call_contract_operation& op() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::protocol::call_contract_operation* release_op();
  ::koinos::protocol::call_contract_operation* mutable_op();
  void set_allocated_op(::koinos::protocol::call_contract_operation* op);
  private:
  const ::koinos::protocol::call_contract_operation& _internal_op() const;
  ::koinos::protocol::call_contract_operation* _internal_mutable_op();
  public:
  void unsafe_arena_set_allocated_op(
      ::koinos::protocol::call_contract_operation* op);
  ::koinos::protocol::call_contract_operation* unsafe_arena_release_op();

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_call_contract_operation_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::protocol::call_contract_operation* op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class apply_call_contract_operation_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_call_contract_operation_result) */ {
 public:
  inline apply_call_contract_operation_result() : apply_call_contract_operation_result(nullptr) {}
  ~apply_call_contract_operation_result() override;
  explicit constexpr apply_call_contract_operation_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_call_contract_operation_result(const apply_call_contract_operation_result& from);
  apply_call_contract_operation_result(apply_call_contract_operation_result&& from) noexcept
    : apply_call_contract_operation_result() {
    *this = ::std::move(from);
  }

  inline apply_call_contract_operation_result& operator=(const apply_call_contract_operation_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_call_contract_operation_result& operator=(apply_call_contract_operation_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_call_contract_operation_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_call_contract_operation_result* internal_default_instance() {
    return reinterpret_cast<const apply_call_contract_operation_result*>(
               &_apply_call_contract_operation_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(apply_call_contract_operation_result& a, apply_call_contract_operation_result& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_call_contract_operation_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_call_contract_operation_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_call_contract_operation_result* New() const final {
    return new apply_call_contract_operation_result();
  }

  apply_call_contract_operation_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_call_contract_operation_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_call_contract_operation_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_call_contract_operation_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_call_contract_operation_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_call_contract_operation_result";
  }
  protected:
  explicit apply_call_contract_operation_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_call_contract_operation_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class apply_set_system_call_operation_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_set_system_call_operation_arguments) */ {
 public:
  inline apply_set_system_call_operation_arguments() : apply_set_system_call_operation_arguments(nullptr) {}
  ~apply_set_system_call_operation_arguments() override;
  explicit constexpr apply_set_system_call_operation_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_set_system_call_operation_arguments(const apply_set_system_call_operation_arguments& from);
  apply_set_system_call_operation_arguments(apply_set_system_call_operation_arguments&& from) noexcept
    : apply_set_system_call_operation_arguments() {
    *this = ::std::move(from);
  }

  inline apply_set_system_call_operation_arguments& operator=(const apply_set_system_call_operation_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_set_system_call_operation_arguments& operator=(apply_set_system_call_operation_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_set_system_call_operation_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_set_system_call_operation_arguments* internal_default_instance() {
    return reinterpret_cast<const apply_set_system_call_operation_arguments*>(
               &_apply_set_system_call_operation_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(apply_set_system_call_operation_arguments& a, apply_set_system_call_operation_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_set_system_call_operation_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_set_system_call_operation_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_set_system_call_operation_arguments* New() const final {
    return new apply_set_system_call_operation_arguments();
  }

  apply_set_system_call_operation_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_set_system_call_operation_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_set_system_call_operation_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_set_system_call_operation_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_set_system_call_operation_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_set_system_call_operation_arguments";
  }
  protected:
  explicit apply_set_system_call_operation_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpFieldNumber = 1,
  };
  // .koinos.protocol.set_system_call_operation op = 1;
  bool has_op() const;
  private:
  bool _internal_has_op() const;
  public:
  void clear_op();
  const ::koinos::protocol::set_system_call_operation& op() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::protocol::set_system_call_operation* release_op();
  ::koinos::protocol::set_system_call_operation* mutable_op();
  void set_allocated_op(::koinos::protocol::set_system_call_operation* op);
  private:
  const ::koinos::protocol::set_system_call_operation& _internal_op() const;
  ::koinos::protocol::set_system_call_operation* _internal_mutable_op();
  public:
  void unsafe_arena_set_allocated_op(
      ::koinos::protocol::set_system_call_operation* op);
  ::koinos::protocol::set_system_call_operation* unsafe_arena_release_op();

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_set_system_call_operation_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::protocol::set_system_call_operation* op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class apply_set_system_call_operation_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_set_system_call_operation_result) */ {
 public:
  inline apply_set_system_call_operation_result() : apply_set_system_call_operation_result(nullptr) {}
  ~apply_set_system_call_operation_result() override;
  explicit constexpr apply_set_system_call_operation_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_set_system_call_operation_result(const apply_set_system_call_operation_result& from);
  apply_set_system_call_operation_result(apply_set_system_call_operation_result&& from) noexcept
    : apply_set_system_call_operation_result() {
    *this = ::std::move(from);
  }

  inline apply_set_system_call_operation_result& operator=(const apply_set_system_call_operation_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_set_system_call_operation_result& operator=(apply_set_system_call_operation_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_set_system_call_operation_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_set_system_call_operation_result* internal_default_instance() {
    return reinterpret_cast<const apply_set_system_call_operation_result*>(
               &_apply_set_system_call_operation_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(apply_set_system_call_operation_result& a, apply_set_system_call_operation_result& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_set_system_call_operation_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_set_system_call_operation_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_set_system_call_operation_result* New() const final {
    return new apply_set_system_call_operation_result();
  }

  apply_set_system_call_operation_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_set_system_call_operation_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_set_system_call_operation_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_set_system_call_operation_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_set_system_call_operation_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_set_system_call_operation_result";
  }
  protected:
  explicit apply_set_system_call_operation_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_set_system_call_operation_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class apply_set_system_contract_operation_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_set_system_contract_operation_arguments) */ {
 public:
  inline apply_set_system_contract_operation_arguments() : apply_set_system_contract_operation_arguments(nullptr) {}
  ~apply_set_system_contract_operation_arguments() override;
  explicit constexpr apply_set_system_contract_operation_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_set_system_contract_operation_arguments(const apply_set_system_contract_operation_arguments& from);
  apply_set_system_contract_operation_arguments(apply_set_system_contract_operation_arguments&& from) noexcept
    : apply_set_system_contract_operation_arguments() {
    *this = ::std::move(from);
  }

  inline apply_set_system_contract_operation_arguments& operator=(const apply_set_system_contract_operation_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_set_system_contract_operation_arguments& operator=(apply_set_system_contract_operation_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_set_system_contract_operation_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_set_system_contract_operation_arguments* internal_default_instance() {
    return reinterpret_cast<const apply_set_system_contract_operation_arguments*>(
               &_apply_set_system_contract_operation_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(apply_set_system_contract_operation_arguments& a, apply_set_system_contract_operation_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_set_system_contract_operation_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_set_system_contract_operation_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_set_system_contract_operation_arguments* New() const final {
    return new apply_set_system_contract_operation_arguments();
  }

  apply_set_system_contract_operation_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_set_system_contract_operation_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_set_system_contract_operation_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_set_system_contract_operation_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_set_system_contract_operation_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_set_system_contract_operation_arguments";
  }
  protected:
  explicit apply_set_system_contract_operation_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpFieldNumber = 1,
  };
  // .koinos.protocol.set_system_contract_operation op = 1;
  bool has_op() const;
  private:
  bool _internal_has_op() const;
  public:
  void clear_op();
  const ::koinos::protocol::set_system_contract_operation& op() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::protocol::set_system_contract_operation* release_op();
  ::koinos::protocol::set_system_contract_operation* mutable_op();
  void set_allocated_op(::koinos::protocol::set_system_contract_operation* op);
  private:
  const ::koinos::protocol::set_system_contract_operation& _internal_op() const;
  ::koinos::protocol::set_system_contract_operation* _internal_mutable_op();
  public:
  void unsafe_arena_set_allocated_op(
      ::koinos::protocol::set_system_contract_operation* op);
  ::koinos::protocol::set_system_contract_operation* unsafe_arena_release_op();

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_set_system_contract_operation_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::protocol::set_system_contract_operation* op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class apply_set_system_contract_operation_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_set_system_contract_operation_result) */ {
 public:
  inline apply_set_system_contract_operation_result() : apply_set_system_contract_operation_result(nullptr) {}
  ~apply_set_system_contract_operation_result() override;
  explicit constexpr apply_set_system_contract_operation_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_set_system_contract_operation_result(const apply_set_system_contract_operation_result& from);
  apply_set_system_contract_operation_result(apply_set_system_contract_operation_result&& from) noexcept
    : apply_set_system_contract_operation_result() {
    *this = ::std::move(from);
  }

  inline apply_set_system_contract_operation_result& operator=(const apply_set_system_contract_operation_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_set_system_contract_operation_result& operator=(apply_set_system_contract_operation_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_set_system_contract_operation_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_set_system_contract_operation_result* internal_default_instance() {
    return reinterpret_cast<const apply_set_system_contract_operation_result*>(
               &_apply_set_system_contract_operation_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(apply_set_system_contract_operation_result& a, apply_set_system_contract_operation_result& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_set_system_contract_operation_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_set_system_contract_operation_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_set_system_contract_operation_result* New() const final {
    return new apply_set_system_contract_operation_result();
  }

  apply_set_system_contract_operation_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_set_system_contract_operation_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_set_system_contract_operation_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_set_system_contract_operation_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_set_system_contract_operation_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_set_system_contract_operation_result";
  }
  protected:
  explicit apply_set_system_contract_operation_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_set_system_contract_operation_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class pre_block_callback_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.pre_block_callback_arguments) */ {
 public:
  inline pre_block_callback_arguments() : pre_block_callback_arguments(nullptr) {}
  ~pre_block_callback_arguments() override;
  explicit constexpr pre_block_callback_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  pre_block_callback_arguments(const pre_block_callback_arguments& from);
  pre_block_callback_arguments(pre_block_callback_arguments&& from) noexcept
    : pre_block_callback_arguments() {
    *this = ::std::move(from);
  }

  inline pre_block_callback_arguments& operator=(const pre_block_callback_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline pre_block_callback_arguments& operator=(pre_block_callback_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const pre_block_callback_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const pre_block_callback_arguments* internal_default_instance() {
    return reinterpret_cast<const pre_block_callback_arguments*>(
               &_pre_block_callback_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(pre_block_callback_arguments& a, pre_block_callback_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(pre_block_callback_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(pre_block_callback_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline pre_block_callback_arguments* New() const final {
    return new pre_block_callback_arguments();
  }

  pre_block_callback_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<pre_block_callback_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const pre_block_callback_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const pre_block_callback_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(pre_block_callback_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.pre_block_callback_arguments";
  }
  protected:
  explicit pre_block_callback_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.pre_block_callback_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class pre_block_callback_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.pre_block_callback_result) */ {
 public:
  inline pre_block_callback_result() : pre_block_callback_result(nullptr) {}
  ~pre_block_callback_result() override;
  explicit constexpr pre_block_callback_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  pre_block_callback_result(const pre_block_callback_result& from);
  pre_block_callback_result(pre_block_callback_result&& from) noexcept
    : pre_block_callback_result() {
    *this = ::std::move(from);
  }

  inline pre_block_callback_result& operator=(const pre_block_callback_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline pre_block_callback_result& operator=(pre_block_callback_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const pre_block_callback_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const pre_block_callback_result* internal_default_instance() {
    return reinterpret_cast<const pre_block_callback_result*>(
               &_pre_block_callback_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(pre_block_callback_result& a, pre_block_callback_result& b) {
    a.Swap(&b);
  }
  inline void Swap(pre_block_callback_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(pre_block_callback_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline pre_block_callback_result* New() const final {
    return new pre_block_callback_result();
  }

  pre_block_callback_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<pre_block_callback_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const pre_block_callback_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const pre_block_callback_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(pre_block_callback_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.pre_block_callback_result";
  }
  protected:
  explicit pre_block_callback_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.pre_block_callback_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class post_block_callback_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.post_block_callback_arguments) */ {
 public:
  inline post_block_callback_arguments() : post_block_callback_arguments(nullptr) {}
  ~post_block_callback_arguments() override;
  explicit constexpr post_block_callback_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  post_block_callback_arguments(const post_block_callback_arguments& from);
  post_block_callback_arguments(post_block_callback_arguments&& from) noexcept
    : post_block_callback_arguments() {
    *this = ::std::move(from);
  }

  inline post_block_callback_arguments& operator=(const post_block_callback_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline post_block_callback_arguments& operator=(post_block_callback_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const post_block_callback_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const post_block_callback_arguments* internal_default_instance() {
    return reinterpret_cast<const post_block_callback_arguments*>(
               &_post_block_callback_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(post_block_callback_arguments& a, post_block_callback_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(post_block_callback_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(post_block_callback_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline post_block_callback_arguments* New() const final {
    return new post_block_callback_arguments();
  }

  post_block_callback_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<post_block_callback_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const post_block_callback_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const post_block_callback_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(post_block_callback_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.post_block_callback_arguments";
  }
  protected:
  explicit post_block_callback_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.post_block_callback_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class post_block_callback_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.post_block_callback_result) */ {
 public:
  inline post_block_callback_result() : post_block_callback_result(nullptr) {}
  ~post_block_callback_result() override;
  explicit constexpr post_block_callback_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  post_block_callback_result(const post_block_callback_result& from);
  post_block_callback_result(post_block_callback_result&& from) noexcept
    : post_block_callback_result() {
    *this = ::std::move(from);
  }

  inline post_block_callback_result& operator=(const post_block_callback_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline post_block_callback_result& operator=(post_block_callback_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const post_block_callback_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const post_block_callback_result* internal_default_instance() {
    return reinterpret_cast<const post_block_callback_result*>(
               &_post_block_callback_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(post_block_callback_result& a, post_block_callback_result& b) {
    a.Swap(&b);
  }
  inline void Swap(post_block_callback_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(post_block_callback_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline post_block_callback_result* New() const final {
    return new post_block_callback_result();
  }

  post_block_callback_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<post_block_callback_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const post_block_callback_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const post_block_callback_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(post_block_callback_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.post_block_callback_result";
  }
  protected:
  explicit post_block_callback_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.post_block_callback_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class pre_transaction_callback_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.pre_transaction_callback_arguments) */ {
 public:
  inline pre_transaction_callback_arguments() : pre_transaction_callback_arguments(nullptr) {}
  ~pre_transaction_callback_arguments() override;
  explicit constexpr pre_transaction_callback_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  pre_transaction_callback_arguments(const pre_transaction_callback_arguments& from);
  pre_transaction_callback_arguments(pre_transaction_callback_arguments&& from) noexcept
    : pre_transaction_callback_arguments() {
    *this = ::std::move(from);
  }

  inline pre_transaction_callback_arguments& operator=(const pre_transaction_callback_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline pre_transaction_callback_arguments& operator=(pre_transaction_callback_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const pre_transaction_callback_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const pre_transaction_callback_arguments* internal_default_instance() {
    return reinterpret_cast<const pre_transaction_callback_arguments*>(
               &_pre_transaction_callback_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(pre_transaction_callback_arguments& a, pre_transaction_callback_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(pre_transaction_callback_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(pre_transaction_callback_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline pre_transaction_callback_arguments* New() const final {
    return new pre_transaction_callback_arguments();
  }

  pre_transaction_callback_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<pre_transaction_callback_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const pre_transaction_callback_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const pre_transaction_callback_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(pre_transaction_callback_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.pre_transaction_callback_arguments";
  }
  protected:
  explicit pre_transaction_callback_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.pre_transaction_callback_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class pre_transaction_callback_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.pre_transaction_callback_result) */ {
 public:
  inline pre_transaction_callback_result() : pre_transaction_callback_result(nullptr) {}
  ~pre_transaction_callback_result() override;
  explicit constexpr pre_transaction_callback_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  pre_transaction_callback_result(const pre_transaction_callback_result& from);
  pre_transaction_callback_result(pre_transaction_callback_result&& from) noexcept
    : pre_transaction_callback_result() {
    *this = ::std::move(from);
  }

  inline pre_transaction_callback_result& operator=(const pre_transaction_callback_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline pre_transaction_callback_result& operator=(pre_transaction_callback_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const pre_transaction_callback_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const pre_transaction_callback_result* internal_default_instance() {
    return reinterpret_cast<const pre_transaction_callback_result*>(
               &_pre_transaction_callback_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(pre_transaction_callback_result& a, pre_transaction_callback_result& b) {
    a.Swap(&b);
  }
  inline void Swap(pre_transaction_callback_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(pre_transaction_callback_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline pre_transaction_callback_result* New() const final {
    return new pre_transaction_callback_result();
  }

  pre_transaction_callback_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<pre_transaction_callback_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const pre_transaction_callback_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const pre_transaction_callback_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(pre_transaction_callback_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.pre_transaction_callback_result";
  }
  protected:
  explicit pre_transaction_callback_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.pre_transaction_callback_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class post_transaction_callback_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.post_transaction_callback_arguments) */ {
 public:
  inline post_transaction_callback_arguments() : post_transaction_callback_arguments(nullptr) {}
  ~post_transaction_callback_arguments() override;
  explicit constexpr post_transaction_callback_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  post_transaction_callback_arguments(const post_transaction_callback_arguments& from);
  post_transaction_callback_arguments(post_transaction_callback_arguments&& from) noexcept
    : post_transaction_callback_arguments() {
    *this = ::std::move(from);
  }

  inline post_transaction_callback_arguments& operator=(const post_transaction_callback_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline post_transaction_callback_arguments& operator=(post_transaction_callback_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const post_transaction_callback_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const post_transaction_callback_arguments* internal_default_instance() {
    return reinterpret_cast<const post_transaction_callback_arguments*>(
               &_post_transaction_callback_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(post_transaction_callback_arguments& a, post_transaction_callback_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(post_transaction_callback_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(post_transaction_callback_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline post_transaction_callback_arguments* New() const final {
    return new post_transaction_callback_arguments();
  }

  post_transaction_callback_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<post_transaction_callback_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const post_transaction_callback_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const post_transaction_callback_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(post_transaction_callback_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.post_transaction_callback_arguments";
  }
  protected:
  explicit post_transaction_callback_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.post_transaction_callback_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class post_transaction_callback_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.post_transaction_callback_result) */ {
 public:
  inline post_transaction_callback_result() : post_transaction_callback_result(nullptr) {}
  ~post_transaction_callback_result() override;
  explicit constexpr post_transaction_callback_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  post_transaction_callback_result(const post_transaction_callback_result& from);
  post_transaction_callback_result(post_transaction_callback_result&& from) noexcept
    : post_transaction_callback_result() {
    *this = ::std::move(from);
  }

  inline post_transaction_callback_result& operator=(const post_transaction_callback_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline post_transaction_callback_result& operator=(post_transaction_callback_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const post_transaction_callback_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const post_transaction_callback_result* internal_default_instance() {
    return reinterpret_cast<const post_transaction_callback_result*>(
               &_post_transaction_callback_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(post_transaction_callback_result& a, post_transaction_callback_result& b) {
    a.Swap(&b);
  }
  inline void Swap(post_transaction_callback_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(post_transaction_callback_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline post_transaction_callback_result* New() const final {
    return new post_transaction_callback_result();
  }

  post_transaction_callback_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<post_transaction_callback_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const post_transaction_callback_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const post_transaction_callback_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(post_transaction_callback_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.post_transaction_callback_result";
  }
  protected:
  explicit post_transaction_callback_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.post_transaction_callback_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_chain_id_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_chain_id_arguments) */ {
 public:
  inline get_chain_id_arguments() : get_chain_id_arguments(nullptr) {}
  ~get_chain_id_arguments() override;
  explicit constexpr get_chain_id_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_chain_id_arguments(const get_chain_id_arguments& from);
  get_chain_id_arguments(get_chain_id_arguments&& from) noexcept
    : get_chain_id_arguments() {
    *this = ::std::move(from);
  }

  inline get_chain_id_arguments& operator=(const get_chain_id_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_chain_id_arguments& operator=(get_chain_id_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_chain_id_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_chain_id_arguments* internal_default_instance() {
    return reinterpret_cast<const get_chain_id_arguments*>(
               &_get_chain_id_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(get_chain_id_arguments& a, get_chain_id_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_chain_id_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_chain_id_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_chain_id_arguments* New() const final {
    return new get_chain_id_arguments();
  }

  get_chain_id_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_chain_id_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_chain_id_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_chain_id_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_chain_id_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_chain_id_arguments";
  }
  protected:
  explicit get_chain_id_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.get_chain_id_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_chain_id_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_chain_id_result) */ {
 public:
  inline get_chain_id_result() : get_chain_id_result(nullptr) {}
  ~get_chain_id_result() override;
  explicit constexpr get_chain_id_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_chain_id_result(const get_chain_id_result& from);
  get_chain_id_result(get_chain_id_result&& from) noexcept
    : get_chain_id_result() {
    *this = ::std::move(from);
  }

  inline get_chain_id_result& operator=(const get_chain_id_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_chain_id_result& operator=(get_chain_id_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_chain_id_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_chain_id_result* internal_default_instance() {
    return reinterpret_cast<const get_chain_id_result*>(
               &_get_chain_id_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(get_chain_id_result& a, get_chain_id_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_chain_id_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_chain_id_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_chain_id_result* New() const final {
    return new get_chain_id_result();
  }

  get_chain_id_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_chain_id_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_chain_id_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_chain_id_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_chain_id_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_chain_id_result";
  }
  protected:
  explicit get_chain_id_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_chain_id_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class process_block_signature_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.process_block_signature_arguments) */ {
 public:
  inline process_block_signature_arguments() : process_block_signature_arguments(nullptr) {}
  ~process_block_signature_arguments() override;
  explicit constexpr process_block_signature_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  process_block_signature_arguments(const process_block_signature_arguments& from);
  process_block_signature_arguments(process_block_signature_arguments&& from) noexcept
    : process_block_signature_arguments() {
    *this = ::std::move(from);
  }

  inline process_block_signature_arguments& operator=(const process_block_signature_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline process_block_signature_arguments& operator=(process_block_signature_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const process_block_signature_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const process_block_signature_arguments* internal_default_instance() {
    return reinterpret_cast<const process_block_signature_arguments*>(
               &_process_block_signature_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(process_block_signature_arguments& a, process_block_signature_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(process_block_signature_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(process_block_signature_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline process_block_signature_arguments* New() const final {
    return new process_block_signature_arguments();
  }

  process_block_signature_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<process_block_signature_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const process_block_signature_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const process_block_signature_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(process_block_signature_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.process_block_signature_arguments";
  }
  protected:
  explicit process_block_signature_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDigestFieldNumber = 1,
    kSignatureFieldNumber = 3,
    kHeaderFieldNumber = 2,
  };
  // bytes digest = 1;
  void clear_digest();
  const std::string& digest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_digest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_digest();
  PROTOBUF_MUST_USE_RESULT std::string* release_digest();
  void set_allocated_digest(std::string* digest);
  private:
  const std::string& _internal_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_digest(const std::string& value);
  std::string* _internal_mutable_digest();
  public:

  // bytes signature = 3;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_MUST_USE_RESULT std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // .koinos.protocol.block_header header = 2;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::koinos::protocol::block_header& header() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::protocol::block_header* release_header();
  ::koinos::protocol::block_header* mutable_header();
  void set_allocated_header(::koinos::protocol::block_header* header);
  private:
  const ::koinos::protocol::block_header& _internal_header() const;
  ::koinos::protocol::block_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::koinos::protocol::block_header* header);
  ::koinos::protocol::block_header* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:koinos.chain.process_block_signature_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::koinos::protocol::block_header* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class process_block_signature_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.process_block_signature_result) */ {
 public:
  inline process_block_signature_result() : process_block_signature_result(nullptr) {}
  ~process_block_signature_result() override;
  explicit constexpr process_block_signature_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  process_block_signature_result(const process_block_signature_result& from);
  process_block_signature_result(process_block_signature_result&& from) noexcept
    : process_block_signature_result() {
    *this = ::std::move(from);
  }

  inline process_block_signature_result& operator=(const process_block_signature_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline process_block_signature_result& operator=(process_block_signature_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const process_block_signature_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const process_block_signature_result* internal_default_instance() {
    return reinterpret_cast<const process_block_signature_result*>(
               &_process_block_signature_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(process_block_signature_result& a, process_block_signature_result& b) {
    a.Swap(&b);
  }
  inline void Swap(process_block_signature_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(process_block_signature_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline process_block_signature_result* New() const final {
    return new process_block_signature_result();
  }

  process_block_signature_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<process_block_signature_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const process_block_signature_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const process_block_signature_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(process_block_signature_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.process_block_signature_result";
  }
  protected:
  explicit process_block_signature_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.process_block_signature_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_transaction_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_transaction_arguments) */ {
 public:
  inline get_transaction_arguments() : get_transaction_arguments(nullptr) {}
  ~get_transaction_arguments() override;
  explicit constexpr get_transaction_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_transaction_arguments(const get_transaction_arguments& from);
  get_transaction_arguments(get_transaction_arguments&& from) noexcept
    : get_transaction_arguments() {
    *this = ::std::move(from);
  }

  inline get_transaction_arguments& operator=(const get_transaction_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_transaction_arguments& operator=(get_transaction_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_transaction_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_transaction_arguments* internal_default_instance() {
    return reinterpret_cast<const get_transaction_arguments*>(
               &_get_transaction_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(get_transaction_arguments& a, get_transaction_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_transaction_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_transaction_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_transaction_arguments* New() const final {
    return new get_transaction_arguments();
  }

  get_transaction_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_transaction_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_transaction_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_transaction_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_transaction_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_transaction_arguments";
  }
  protected:
  explicit get_transaction_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.get_transaction_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_transaction_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_transaction_result) */ {
 public:
  inline get_transaction_result() : get_transaction_result(nullptr) {}
  ~get_transaction_result() override;
  explicit constexpr get_transaction_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_transaction_result(const get_transaction_result& from);
  get_transaction_result(get_transaction_result&& from) noexcept
    : get_transaction_result() {
    *this = ::std::move(from);
  }

  inline get_transaction_result& operator=(const get_transaction_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_transaction_result& operator=(get_transaction_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_transaction_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_transaction_result* internal_default_instance() {
    return reinterpret_cast<const get_transaction_result*>(
               &_get_transaction_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(get_transaction_result& a, get_transaction_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_transaction_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_transaction_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_transaction_result* New() const final {
    return new get_transaction_result();
  }

  get_transaction_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_transaction_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_transaction_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_transaction_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_transaction_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_transaction_result";
  }
  protected:
  explicit get_transaction_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .koinos.protocol.transaction value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::koinos::protocol::transaction& value() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::protocol::transaction* release_value();
  ::koinos::protocol::transaction* mutable_value();
  void set_allocated_value(::koinos::protocol::transaction* value);
  private:
  const ::koinos::protocol::transaction& _internal_value() const;
  ::koinos::protocol::transaction* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::koinos::protocol::transaction* value);
  ::koinos::protocol::transaction* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:koinos.chain.get_transaction_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::protocol::transaction* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_transaction_field_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_transaction_field_arguments) */ {
 public:
  inline get_transaction_field_arguments() : get_transaction_field_arguments(nullptr) {}
  ~get_transaction_field_arguments() override;
  explicit constexpr get_transaction_field_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_transaction_field_arguments(const get_transaction_field_arguments& from);
  get_transaction_field_arguments(get_transaction_field_arguments&& from) noexcept
    : get_transaction_field_arguments() {
    *this = ::std::move(from);
  }

  inline get_transaction_field_arguments& operator=(const get_transaction_field_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_transaction_field_arguments& operator=(get_transaction_field_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_transaction_field_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_transaction_field_arguments* internal_default_instance() {
    return reinterpret_cast<const get_transaction_field_arguments*>(
               &_get_transaction_field_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(get_transaction_field_arguments& a, get_transaction_field_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_transaction_field_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_transaction_field_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_transaction_field_arguments* New() const final {
    return new get_transaction_field_arguments();
  }

  get_transaction_field_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_transaction_field_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_transaction_field_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_transaction_field_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_transaction_field_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_transaction_field_arguments";
  }
  protected:
  explicit get_transaction_field_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
  };
  // string field = 1;
  void clear_field();
  const std::string& field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field();
  PROTOBUF_MUST_USE_RESULT std::string* release_field();
  void set_allocated_field(std::string* field);
  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(const std::string& value);
  std::string* _internal_mutable_field();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_transaction_field_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_transaction_field_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_transaction_field_result) */ {
 public:
  inline get_transaction_field_result() : get_transaction_field_result(nullptr) {}
  ~get_transaction_field_result() override;
  explicit constexpr get_transaction_field_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_transaction_field_result(const get_transaction_field_result& from);
  get_transaction_field_result(get_transaction_field_result&& from) noexcept
    : get_transaction_field_result() {
    *this = ::std::move(from);
  }

  inline get_transaction_field_result& operator=(const get_transaction_field_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_transaction_field_result& operator=(get_transaction_field_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_transaction_field_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_transaction_field_result* internal_default_instance() {
    return reinterpret_cast<const get_transaction_field_result*>(
               &_get_transaction_field_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(get_transaction_field_result& a, get_transaction_field_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_transaction_field_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_transaction_field_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_transaction_field_result* New() const final {
    return new get_transaction_field_result();
  }

  get_transaction_field_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_transaction_field_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_transaction_field_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_transaction_field_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_transaction_field_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_transaction_field_result";
  }
  protected:
  explicit get_transaction_field_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .koinos.chain.value_type value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::koinos::chain::value_type& value() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::value_type* release_value();
  ::koinos::chain::value_type* mutable_value();
  void set_allocated_value(::koinos::chain::value_type* value);
  private:
  const ::koinos::chain::value_type& _internal_value() const;
  ::koinos::chain::value_type* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::koinos::chain::value_type* value);
  ::koinos::chain::value_type* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:koinos.chain.get_transaction_field_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::chain::value_type* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_block_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_block_arguments) */ {
 public:
  inline get_block_arguments() : get_block_arguments(nullptr) {}
  ~get_block_arguments() override;
  explicit constexpr get_block_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_block_arguments(const get_block_arguments& from);
  get_block_arguments(get_block_arguments&& from) noexcept
    : get_block_arguments() {
    *this = ::std::move(from);
  }

  inline get_block_arguments& operator=(const get_block_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_block_arguments& operator=(get_block_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_block_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_block_arguments* internal_default_instance() {
    return reinterpret_cast<const get_block_arguments*>(
               &_get_block_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(get_block_arguments& a, get_block_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_block_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_block_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_block_arguments* New() const final {
    return new get_block_arguments();
  }

  get_block_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_block_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_block_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_block_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_block_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_block_arguments";
  }
  protected:
  explicit get_block_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.get_block_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_block_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_block_result) */ {
 public:
  inline get_block_result() : get_block_result(nullptr) {}
  ~get_block_result() override;
  explicit constexpr get_block_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_block_result(const get_block_result& from);
  get_block_result(get_block_result&& from) noexcept
    : get_block_result() {
    *this = ::std::move(from);
  }

  inline get_block_result& operator=(const get_block_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_block_result& operator=(get_block_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_block_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_block_result* internal_default_instance() {
    return reinterpret_cast<const get_block_result*>(
               &_get_block_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(get_block_result& a, get_block_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_block_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_block_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_block_result* New() const final {
    return new get_block_result();
  }

  get_block_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_block_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_block_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_block_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_block_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_block_result";
  }
  protected:
  explicit get_block_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .koinos.protocol.block value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::koinos::protocol::block& value() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::protocol::block* release_value();
  ::koinos::protocol::block* mutable_value();
  void set_allocated_value(::koinos::protocol::block* value);
  private:
  const ::koinos::protocol::block& _internal_value() const;
  ::koinos::protocol::block* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::koinos::protocol::block* value);
  ::koinos::protocol::block* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:koinos.chain.get_block_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::protocol::block* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_block_field_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_block_field_arguments) */ {
 public:
  inline get_block_field_arguments() : get_block_field_arguments(nullptr) {}
  ~get_block_field_arguments() override;
  explicit constexpr get_block_field_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_block_field_arguments(const get_block_field_arguments& from);
  get_block_field_arguments(get_block_field_arguments&& from) noexcept
    : get_block_field_arguments() {
    *this = ::std::move(from);
  }

  inline get_block_field_arguments& operator=(const get_block_field_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_block_field_arguments& operator=(get_block_field_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_block_field_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_block_field_arguments* internal_default_instance() {
    return reinterpret_cast<const get_block_field_arguments*>(
               &_get_block_field_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(get_block_field_arguments& a, get_block_field_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_block_field_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_block_field_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_block_field_arguments* New() const final {
    return new get_block_field_arguments();
  }

  get_block_field_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_block_field_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_block_field_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_block_field_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_block_field_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_block_field_arguments";
  }
  protected:
  explicit get_block_field_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
  };
  // string field = 1;
  void clear_field();
  const std::string& field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field();
  PROTOBUF_MUST_USE_RESULT std::string* release_field();
  void set_allocated_field(std::string* field);
  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(const std::string& value);
  std::string* _internal_mutable_field();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_block_field_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_block_field_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_block_field_result) */ {
 public:
  inline get_block_field_result() : get_block_field_result(nullptr) {}
  ~get_block_field_result() override;
  explicit constexpr get_block_field_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_block_field_result(const get_block_field_result& from);
  get_block_field_result(get_block_field_result&& from) noexcept
    : get_block_field_result() {
    *this = ::std::move(from);
  }

  inline get_block_field_result& operator=(const get_block_field_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_block_field_result& operator=(get_block_field_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_block_field_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_block_field_result* internal_default_instance() {
    return reinterpret_cast<const get_block_field_result*>(
               &_get_block_field_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(get_block_field_result& a, get_block_field_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_block_field_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_block_field_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_block_field_result* New() const final {
    return new get_block_field_result();
  }

  get_block_field_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_block_field_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_block_field_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_block_field_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_block_field_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_block_field_result";
  }
  protected:
  explicit get_block_field_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .koinos.chain.value_type value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::koinos::chain::value_type& value() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::value_type* release_value();
  ::koinos::chain::value_type* mutable_value();
  void set_allocated_value(::koinos::chain::value_type* value);
  private:
  const ::koinos::chain::value_type& _internal_value() const;
  ::koinos::chain::value_type* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::koinos::chain::value_type* value);
  ::koinos::chain::value_type* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:koinos.chain.get_block_field_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::chain::value_type* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_last_irreversible_block_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_last_irreversible_block_arguments) */ {
 public:
  inline get_last_irreversible_block_arguments() : get_last_irreversible_block_arguments(nullptr) {}
  ~get_last_irreversible_block_arguments() override;
  explicit constexpr get_last_irreversible_block_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_last_irreversible_block_arguments(const get_last_irreversible_block_arguments& from);
  get_last_irreversible_block_arguments(get_last_irreversible_block_arguments&& from) noexcept
    : get_last_irreversible_block_arguments() {
    *this = ::std::move(from);
  }

  inline get_last_irreversible_block_arguments& operator=(const get_last_irreversible_block_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_last_irreversible_block_arguments& operator=(get_last_irreversible_block_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_last_irreversible_block_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_last_irreversible_block_arguments* internal_default_instance() {
    return reinterpret_cast<const get_last_irreversible_block_arguments*>(
               &_get_last_irreversible_block_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(get_last_irreversible_block_arguments& a, get_last_irreversible_block_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_last_irreversible_block_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_last_irreversible_block_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_last_irreversible_block_arguments* New() const final {
    return new get_last_irreversible_block_arguments();
  }

  get_last_irreversible_block_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_last_irreversible_block_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_last_irreversible_block_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_last_irreversible_block_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_last_irreversible_block_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_last_irreversible_block_arguments";
  }
  protected:
  explicit get_last_irreversible_block_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.get_last_irreversible_block_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_last_irreversible_block_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_last_irreversible_block_result) */ {
 public:
  inline get_last_irreversible_block_result() : get_last_irreversible_block_result(nullptr) {}
  ~get_last_irreversible_block_result() override;
  explicit constexpr get_last_irreversible_block_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_last_irreversible_block_result(const get_last_irreversible_block_result& from);
  get_last_irreversible_block_result(get_last_irreversible_block_result&& from) noexcept
    : get_last_irreversible_block_result() {
    *this = ::std::move(from);
  }

  inline get_last_irreversible_block_result& operator=(const get_last_irreversible_block_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_last_irreversible_block_result& operator=(get_last_irreversible_block_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_last_irreversible_block_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_last_irreversible_block_result* internal_default_instance() {
    return reinterpret_cast<const get_last_irreversible_block_result*>(
               &_get_last_irreversible_block_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(get_last_irreversible_block_result& a, get_last_irreversible_block_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_last_irreversible_block_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_last_irreversible_block_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_last_irreversible_block_result* New() const final {
    return new get_last_irreversible_block_result();
  }

  get_last_irreversible_block_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_last_irreversible_block_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_last_irreversible_block_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_last_irreversible_block_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_last_irreversible_block_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_last_irreversible_block_result";
  }
  protected:
  explicit get_last_irreversible_block_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint64 value = 1 [jstype = JS_STRING];
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_last_irreversible_block_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_account_nonce_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_account_nonce_arguments) */ {
 public:
  inline get_account_nonce_arguments() : get_account_nonce_arguments(nullptr) {}
  ~get_account_nonce_arguments() override;
  explicit constexpr get_account_nonce_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_account_nonce_arguments(const get_account_nonce_arguments& from);
  get_account_nonce_arguments(get_account_nonce_arguments&& from) noexcept
    : get_account_nonce_arguments() {
    *this = ::std::move(from);
  }

  inline get_account_nonce_arguments& operator=(const get_account_nonce_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_account_nonce_arguments& operator=(get_account_nonce_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_account_nonce_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_account_nonce_arguments* internal_default_instance() {
    return reinterpret_cast<const get_account_nonce_arguments*>(
               &_get_account_nonce_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(get_account_nonce_arguments& a, get_account_nonce_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_account_nonce_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_account_nonce_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_account_nonce_arguments* New() const final {
    return new get_account_nonce_arguments();
  }

  get_account_nonce_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_account_nonce_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_account_nonce_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_account_nonce_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_account_nonce_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_account_nonce_arguments";
  }
  protected:
  explicit get_account_nonce_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
  };
  // bytes account = 1 [(.koinos.btype) = ADDRESS];
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_MUST_USE_RESULT std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_account_nonce_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_account_nonce_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_account_nonce_result) */ {
 public:
  inline get_account_nonce_result() : get_account_nonce_result(nullptr) {}
  ~get_account_nonce_result() override;
  explicit constexpr get_account_nonce_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_account_nonce_result(const get_account_nonce_result& from);
  get_account_nonce_result(get_account_nonce_result&& from) noexcept
    : get_account_nonce_result() {
    *this = ::std::move(from);
  }

  inline get_account_nonce_result& operator=(const get_account_nonce_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_account_nonce_result& operator=(get_account_nonce_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_account_nonce_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_account_nonce_result* internal_default_instance() {
    return reinterpret_cast<const get_account_nonce_result*>(
               &_get_account_nonce_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(get_account_nonce_result& a, get_account_nonce_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_account_nonce_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_account_nonce_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_account_nonce_result* New() const final {
    return new get_account_nonce_result();
  }

  get_account_nonce_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_account_nonce_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_account_nonce_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_account_nonce_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_account_nonce_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_account_nonce_result";
  }
  protected:
  explicit get_account_nonce_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_account_nonce_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class verify_account_nonce_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.verify_account_nonce_arguments) */ {
 public:
  inline verify_account_nonce_arguments() : verify_account_nonce_arguments(nullptr) {}
  ~verify_account_nonce_arguments() override;
  explicit constexpr verify_account_nonce_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  verify_account_nonce_arguments(const verify_account_nonce_arguments& from);
  verify_account_nonce_arguments(verify_account_nonce_arguments&& from) noexcept
    : verify_account_nonce_arguments() {
    *this = ::std::move(from);
  }

  inline verify_account_nonce_arguments& operator=(const verify_account_nonce_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline verify_account_nonce_arguments& operator=(verify_account_nonce_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const verify_account_nonce_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const verify_account_nonce_arguments* internal_default_instance() {
    return reinterpret_cast<const verify_account_nonce_arguments*>(
               &_verify_account_nonce_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(verify_account_nonce_arguments& a, verify_account_nonce_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(verify_account_nonce_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(verify_account_nonce_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline verify_account_nonce_arguments* New() const final {
    return new verify_account_nonce_arguments();
  }

  verify_account_nonce_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<verify_account_nonce_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const verify_account_nonce_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const verify_account_nonce_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(verify_account_nonce_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.verify_account_nonce_arguments";
  }
  protected:
  explicit verify_account_nonce_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
    kNonceFieldNumber = 2,
  };
  // bytes account = 1 [(.koinos.btype) = ADDRESS];
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_MUST_USE_RESULT std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // bytes nonce = 2;
  void clear_nonce();
  const std::string& nonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nonce();
  PROTOBUF_MUST_USE_RESULT std::string* release_nonce();
  void set_allocated_nonce(std::string* nonce);
  private:
  const std::string& _internal_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nonce(const std::string& value);
  std::string* _internal_mutable_nonce();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.verify_account_nonce_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nonce_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class verify_account_nonce_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.verify_account_nonce_result) */ {
 public:
  inline verify_account_nonce_result() : verify_account_nonce_result(nullptr) {}
  ~verify_account_nonce_result() override;
  explicit constexpr verify_account_nonce_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  verify_account_nonce_result(const verify_account_nonce_result& from);
  verify_account_nonce_result(verify_account_nonce_result&& from) noexcept
    : verify_account_nonce_result() {
    *this = ::std::move(from);
  }

  inline verify_account_nonce_result& operator=(const verify_account_nonce_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline verify_account_nonce_result& operator=(verify_account_nonce_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const verify_account_nonce_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const verify_account_nonce_result* internal_default_instance() {
    return reinterpret_cast<const verify_account_nonce_result*>(
               &_verify_account_nonce_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(verify_account_nonce_result& a, verify_account_nonce_result& b) {
    a.Swap(&b);
  }
  inline void Swap(verify_account_nonce_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(verify_account_nonce_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline verify_account_nonce_result* New() const final {
    return new verify_account_nonce_result();
  }

  verify_account_nonce_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<verify_account_nonce_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const verify_account_nonce_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const verify_account_nonce_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(verify_account_nonce_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.verify_account_nonce_result";
  }
  protected:
  explicit verify_account_nonce_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.verify_account_nonce_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class set_account_nonce_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.set_account_nonce_arguments) */ {
 public:
  inline set_account_nonce_arguments() : set_account_nonce_arguments(nullptr) {}
  ~set_account_nonce_arguments() override;
  explicit constexpr set_account_nonce_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  set_account_nonce_arguments(const set_account_nonce_arguments& from);
  set_account_nonce_arguments(set_account_nonce_arguments&& from) noexcept
    : set_account_nonce_arguments() {
    *this = ::std::move(from);
  }

  inline set_account_nonce_arguments& operator=(const set_account_nonce_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline set_account_nonce_arguments& operator=(set_account_nonce_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const set_account_nonce_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const set_account_nonce_arguments* internal_default_instance() {
    return reinterpret_cast<const set_account_nonce_arguments*>(
               &_set_account_nonce_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(set_account_nonce_arguments& a, set_account_nonce_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(set_account_nonce_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(set_account_nonce_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline set_account_nonce_arguments* New() const final {
    return new set_account_nonce_arguments();
  }

  set_account_nonce_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<set_account_nonce_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const set_account_nonce_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const set_account_nonce_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(set_account_nonce_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.set_account_nonce_arguments";
  }
  protected:
  explicit set_account_nonce_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
    kNonceFieldNumber = 2,
  };
  // bytes account = 1 [(.koinos.btype) = ADDRESS];
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_MUST_USE_RESULT std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // bytes nonce = 2;
  void clear_nonce();
  const std::string& nonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nonce();
  PROTOBUF_MUST_USE_RESULT std::string* release_nonce();
  void set_allocated_nonce(std::string* nonce);
  private:
  const std::string& _internal_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nonce(const std::string& value);
  std::string* _internal_mutable_nonce();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.set_account_nonce_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nonce_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class set_account_nonce_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.set_account_nonce_result) */ {
 public:
  inline set_account_nonce_result() : set_account_nonce_result(nullptr) {}
  ~set_account_nonce_result() override;
  explicit constexpr set_account_nonce_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  set_account_nonce_result(const set_account_nonce_result& from);
  set_account_nonce_result(set_account_nonce_result&& from) noexcept
    : set_account_nonce_result() {
    *this = ::std::move(from);
  }

  inline set_account_nonce_result& operator=(const set_account_nonce_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline set_account_nonce_result& operator=(set_account_nonce_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const set_account_nonce_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const set_account_nonce_result* internal_default_instance() {
    return reinterpret_cast<const set_account_nonce_result*>(
               &_set_account_nonce_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(set_account_nonce_result& a, set_account_nonce_result& b) {
    a.Swap(&b);
  }
  inline void Swap(set_account_nonce_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(set_account_nonce_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline set_account_nonce_result* New() const final {
    return new set_account_nonce_result();
  }

  set_account_nonce_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<set_account_nonce_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const set_account_nonce_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const set_account_nonce_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(set_account_nonce_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.set_account_nonce_result";
  }
  protected:
  explicit set_account_nonce_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.set_account_nonce_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class check_system_authority_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.check_system_authority_arguments) */ {
 public:
  inline check_system_authority_arguments() : check_system_authority_arguments(nullptr) {}
  ~check_system_authority_arguments() override;
  explicit constexpr check_system_authority_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  check_system_authority_arguments(const check_system_authority_arguments& from);
  check_system_authority_arguments(check_system_authority_arguments&& from) noexcept
    : check_system_authority_arguments() {
    *this = ::std::move(from);
  }

  inline check_system_authority_arguments& operator=(const check_system_authority_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline check_system_authority_arguments& operator=(check_system_authority_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const check_system_authority_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const check_system_authority_arguments* internal_default_instance() {
    return reinterpret_cast<const check_system_authority_arguments*>(
               &_check_system_authority_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(check_system_authority_arguments& a, check_system_authority_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(check_system_authority_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(check_system_authority_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline check_system_authority_arguments* New() const final {
    return new check_system_authority_arguments();
  }

  check_system_authority_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<check_system_authority_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const check_system_authority_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const check_system_authority_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(check_system_authority_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.check_system_authority_arguments";
  }
  protected:
  explicit check_system_authority_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .koinos.chain.system_authorization_type type = 1;
  void clear_type();
  ::koinos::chain::system_authorization_type type() const;
  void set_type(::koinos::chain::system_authorization_type value);
  private:
  ::koinos::chain::system_authorization_type _internal_type() const;
  void _internal_set_type(::koinos::chain::system_authorization_type value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.check_system_authority_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class check_system_authority_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.check_system_authority_result) */ {
 public:
  inline check_system_authority_result() : check_system_authority_result(nullptr) {}
  ~check_system_authority_result() override;
  explicit constexpr check_system_authority_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  check_system_authority_result(const check_system_authority_result& from);
  check_system_authority_result(check_system_authority_result&& from) noexcept
    : check_system_authority_result() {
    *this = ::std::move(from);
  }

  inline check_system_authority_result& operator=(const check_system_authority_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline check_system_authority_result& operator=(check_system_authority_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const check_system_authority_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const check_system_authority_result* internal_default_instance() {
    return reinterpret_cast<const check_system_authority_result*>(
               &_check_system_authority_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(check_system_authority_result& a, check_system_authority_result& b) {
    a.Swap(&b);
  }
  inline void Swap(check_system_authority_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(check_system_authority_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline check_system_authority_result* New() const final {
    return new check_system_authority_result();
  }

  check_system_authority_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<check_system_authority_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const check_system_authority_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const check_system_authority_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(check_system_authority_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.check_system_authority_result";
  }
  protected:
  explicit check_system_authority_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.check_system_authority_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_operation_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_operation_arguments) */ {
 public:
  inline get_operation_arguments() : get_operation_arguments(nullptr) {}
  ~get_operation_arguments() override;
  explicit constexpr get_operation_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_operation_arguments(const get_operation_arguments& from);
  get_operation_arguments(get_operation_arguments&& from) noexcept
    : get_operation_arguments() {
    *this = ::std::move(from);
  }

  inline get_operation_arguments& operator=(const get_operation_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_operation_arguments& operator=(get_operation_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_operation_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_operation_arguments* internal_default_instance() {
    return reinterpret_cast<const get_operation_arguments*>(
               &_get_operation_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(get_operation_arguments& a, get_operation_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_operation_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_operation_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_operation_arguments* New() const final {
    return new get_operation_arguments();
  }

  get_operation_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_operation_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_operation_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_operation_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_operation_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_operation_arguments";
  }
  protected:
  explicit get_operation_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.get_operation_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_operation_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_operation_result) */ {
 public:
  inline get_operation_result() : get_operation_result(nullptr) {}
  ~get_operation_result() override;
  explicit constexpr get_operation_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_operation_result(const get_operation_result& from);
  get_operation_result(get_operation_result&& from) noexcept
    : get_operation_result() {
    *this = ::std::move(from);
  }

  inline get_operation_result& operator=(const get_operation_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_operation_result& operator=(get_operation_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_operation_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_operation_result* internal_default_instance() {
    return reinterpret_cast<const get_operation_result*>(
               &_get_operation_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(get_operation_result& a, get_operation_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_operation_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_operation_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_operation_result* New() const final {
    return new get_operation_result();
  }

  get_operation_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_operation_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_operation_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_operation_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_operation_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_operation_result";
  }
  protected:
  explicit get_operation_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .koinos.protocol.operation value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::koinos::protocol::operation& value() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::protocol::operation* release_value();
  ::koinos::protocol::operation* mutable_value();
  void set_allocated_value(::koinos::protocol::operation* value);
  private:
  const ::koinos::protocol::operation& _internal_value() const;
  ::koinos::protocol::operation* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::koinos::protocol::operation* value);
  ::koinos::protocol::operation* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:koinos.chain.get_operation_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::protocol::operation* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_account_rc_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_account_rc_arguments) */ {
 public:
  inline get_account_rc_arguments() : get_account_rc_arguments(nullptr) {}
  ~get_account_rc_arguments() override;
  explicit constexpr get_account_rc_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_account_rc_arguments(const get_account_rc_arguments& from);
  get_account_rc_arguments(get_account_rc_arguments&& from) noexcept
    : get_account_rc_arguments() {
    *this = ::std::move(from);
  }

  inline get_account_rc_arguments& operator=(const get_account_rc_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_account_rc_arguments& operator=(get_account_rc_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_account_rc_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_account_rc_arguments* internal_default_instance() {
    return reinterpret_cast<const get_account_rc_arguments*>(
               &_get_account_rc_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(get_account_rc_arguments& a, get_account_rc_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_account_rc_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_account_rc_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_account_rc_arguments* New() const final {
    return new get_account_rc_arguments();
  }

  get_account_rc_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_account_rc_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_account_rc_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_account_rc_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_account_rc_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_account_rc_arguments";
  }
  protected:
  explicit get_account_rc_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
  };
  // bytes account = 1 [(.koinos.btype) = ADDRESS];
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_MUST_USE_RESULT std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_account_rc_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_account_rc_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_account_rc_result) */ {
 public:
  inline get_account_rc_result() : get_account_rc_result(nullptr) {}
  ~get_account_rc_result() override;
  explicit constexpr get_account_rc_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_account_rc_result(const get_account_rc_result& from);
  get_account_rc_result(get_account_rc_result&& from) noexcept
    : get_account_rc_result() {
    *this = ::std::move(from);
  }

  inline get_account_rc_result& operator=(const get_account_rc_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_account_rc_result& operator=(get_account_rc_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_account_rc_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_account_rc_result* internal_default_instance() {
    return reinterpret_cast<const get_account_rc_result*>(
               &_get_account_rc_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(get_account_rc_result& a, get_account_rc_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_account_rc_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_account_rc_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_account_rc_result* New() const final {
    return new get_account_rc_result();
  }

  get_account_rc_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_account_rc_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_account_rc_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_account_rc_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_account_rc_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_account_rc_result";
  }
  protected:
  explicit get_account_rc_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint64 value = 1 [jstype = JS_STRING];
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_account_rc_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class consume_account_rc_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.consume_account_rc_arguments) */ {
 public:
  inline consume_account_rc_arguments() : consume_account_rc_arguments(nullptr) {}
  ~consume_account_rc_arguments() override;
  explicit constexpr consume_account_rc_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  consume_account_rc_arguments(const consume_account_rc_arguments& from);
  consume_account_rc_arguments(consume_account_rc_arguments&& from) noexcept
    : consume_account_rc_arguments() {
    *this = ::std::move(from);
  }

  inline consume_account_rc_arguments& operator=(const consume_account_rc_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline consume_account_rc_arguments& operator=(consume_account_rc_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const consume_account_rc_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const consume_account_rc_arguments* internal_default_instance() {
    return reinterpret_cast<const consume_account_rc_arguments*>(
               &_consume_account_rc_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(consume_account_rc_arguments& a, consume_account_rc_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(consume_account_rc_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(consume_account_rc_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline consume_account_rc_arguments* New() const final {
    return new consume_account_rc_arguments();
  }

  consume_account_rc_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<consume_account_rc_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const consume_account_rc_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const consume_account_rc_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(consume_account_rc_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.consume_account_rc_arguments";
  }
  protected:
  explicit consume_account_rc_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // bytes account = 1 [(.koinos.btype) = ADDRESS];
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_MUST_USE_RESULT std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // uint64 value = 2 [jstype = JS_STRING];
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.consume_account_rc_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class consume_account_rc_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.consume_account_rc_result) */ {
 public:
  inline consume_account_rc_result() : consume_account_rc_result(nullptr) {}
  ~consume_account_rc_result() override;
  explicit constexpr consume_account_rc_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  consume_account_rc_result(const consume_account_rc_result& from);
  consume_account_rc_result(consume_account_rc_result&& from) noexcept
    : consume_account_rc_result() {
    *this = ::std::move(from);
  }

  inline consume_account_rc_result& operator=(const consume_account_rc_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline consume_account_rc_result& operator=(consume_account_rc_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const consume_account_rc_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const consume_account_rc_result* internal_default_instance() {
    return reinterpret_cast<const consume_account_rc_result*>(
               &_consume_account_rc_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(consume_account_rc_result& a, consume_account_rc_result& b) {
    a.Swap(&b);
  }
  inline void Swap(consume_account_rc_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(consume_account_rc_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline consume_account_rc_result* New() const final {
    return new consume_account_rc_result();
  }

  consume_account_rc_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<consume_account_rc_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const consume_account_rc_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const consume_account_rc_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(consume_account_rc_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.consume_account_rc_result";
  }
  protected:
  explicit consume_account_rc_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.consume_account_rc_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_resource_limits_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_resource_limits_arguments) */ {
 public:
  inline get_resource_limits_arguments() : get_resource_limits_arguments(nullptr) {}
  ~get_resource_limits_arguments() override;
  explicit constexpr get_resource_limits_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_resource_limits_arguments(const get_resource_limits_arguments& from);
  get_resource_limits_arguments(get_resource_limits_arguments&& from) noexcept
    : get_resource_limits_arguments() {
    *this = ::std::move(from);
  }

  inline get_resource_limits_arguments& operator=(const get_resource_limits_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_resource_limits_arguments& operator=(get_resource_limits_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_resource_limits_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_resource_limits_arguments* internal_default_instance() {
    return reinterpret_cast<const get_resource_limits_arguments*>(
               &_get_resource_limits_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(get_resource_limits_arguments& a, get_resource_limits_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_resource_limits_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_resource_limits_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_resource_limits_arguments* New() const final {
    return new get_resource_limits_arguments();
  }

  get_resource_limits_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_resource_limits_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_resource_limits_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_resource_limits_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_resource_limits_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_resource_limits_arguments";
  }
  protected:
  explicit get_resource_limits_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.get_resource_limits_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_resource_limits_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_resource_limits_result) */ {
 public:
  inline get_resource_limits_result() : get_resource_limits_result(nullptr) {}
  ~get_resource_limits_result() override;
  explicit constexpr get_resource_limits_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_resource_limits_result(const get_resource_limits_result& from);
  get_resource_limits_result(get_resource_limits_result&& from) noexcept
    : get_resource_limits_result() {
    *this = ::std::move(from);
  }

  inline get_resource_limits_result& operator=(const get_resource_limits_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_resource_limits_result& operator=(get_resource_limits_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_resource_limits_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_resource_limits_result* internal_default_instance() {
    return reinterpret_cast<const get_resource_limits_result*>(
               &_get_resource_limits_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(get_resource_limits_result& a, get_resource_limits_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_resource_limits_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_resource_limits_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_resource_limits_result* New() const final {
    return new get_resource_limits_result();
  }

  get_resource_limits_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_resource_limits_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_resource_limits_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_resource_limits_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_resource_limits_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_resource_limits_result";
  }
  protected:
  explicit get_resource_limits_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .koinos.chain.resource_limit_data value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::koinos::chain::resource_limit_data& value() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::resource_limit_data* release_value();
  ::koinos::chain::resource_limit_data* mutable_value();
  void set_allocated_value(::koinos::chain::resource_limit_data* value);
  private:
  const ::koinos::chain::resource_limit_data& _internal_value() const;
  ::koinos::chain::resource_limit_data* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::koinos::chain::resource_limit_data* value);
  ::koinos::chain::resource_limit_data* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:koinos.chain.get_resource_limits_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::chain::resource_limit_data* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class consume_block_resources_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.consume_block_resources_arguments) */ {
 public:
  inline consume_block_resources_arguments() : consume_block_resources_arguments(nullptr) {}
  ~consume_block_resources_arguments() override;
  explicit constexpr consume_block_resources_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  consume_block_resources_arguments(const consume_block_resources_arguments& from);
  consume_block_resources_arguments(consume_block_resources_arguments&& from) noexcept
    : consume_block_resources_arguments() {
    *this = ::std::move(from);
  }

  inline consume_block_resources_arguments& operator=(const consume_block_resources_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline consume_block_resources_arguments& operator=(consume_block_resources_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const consume_block_resources_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const consume_block_resources_arguments* internal_default_instance() {
    return reinterpret_cast<const consume_block_resources_arguments*>(
               &_consume_block_resources_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(consume_block_resources_arguments& a, consume_block_resources_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(consume_block_resources_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(consume_block_resources_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline consume_block_resources_arguments* New() const final {
    return new consume_block_resources_arguments();
  }

  consume_block_resources_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<consume_block_resources_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const consume_block_resources_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const consume_block_resources_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(consume_block_resources_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.consume_block_resources_arguments";
  }
  protected:
  explicit consume_block_resources_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiskStorageConsumedFieldNumber = 1,
    kNetworkBandwidthConsumedFieldNumber = 2,
    kComputeBandwidthConsumedFieldNumber = 3,
  };
  // uint64 disk_storage_consumed = 1 [jstype = JS_STRING];
  void clear_disk_storage_consumed();
  ::PROTOBUF_NAMESPACE_ID::uint64 disk_storage_consumed() const;
  void set_disk_storage_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_disk_storage_consumed() const;
  void _internal_set_disk_storage_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 network_bandwidth_consumed = 2 [jstype = JS_STRING];
  void clear_network_bandwidth_consumed();
  ::PROTOBUF_NAMESPACE_ID::uint64 network_bandwidth_consumed() const;
  void set_network_bandwidth_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_network_bandwidth_consumed() const;
  void _internal_set_network_bandwidth_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 compute_bandwidth_consumed = 3 [jstype = JS_STRING];
  void clear_compute_bandwidth_consumed();
  ::PROTOBUF_NAMESPACE_ID::uint64 compute_bandwidth_consumed() const;
  void set_compute_bandwidth_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_compute_bandwidth_consumed() const;
  void _internal_set_compute_bandwidth_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.consume_block_resources_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 disk_storage_consumed_;
  ::PROTOBUF_NAMESPACE_ID::uint64 network_bandwidth_consumed_;
  ::PROTOBUF_NAMESPACE_ID::uint64 compute_bandwidth_consumed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class consume_block_resources_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.consume_block_resources_result) */ {
 public:
  inline consume_block_resources_result() : consume_block_resources_result(nullptr) {}
  ~consume_block_resources_result() override;
  explicit constexpr consume_block_resources_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  consume_block_resources_result(const consume_block_resources_result& from);
  consume_block_resources_result(consume_block_resources_result&& from) noexcept
    : consume_block_resources_result() {
    *this = ::std::move(from);
  }

  inline consume_block_resources_result& operator=(const consume_block_resources_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline consume_block_resources_result& operator=(consume_block_resources_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const consume_block_resources_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const consume_block_resources_result* internal_default_instance() {
    return reinterpret_cast<const consume_block_resources_result*>(
               &_consume_block_resources_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(consume_block_resources_result& a, consume_block_resources_result& b) {
    a.Swap(&b);
  }
  inline void Swap(consume_block_resources_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(consume_block_resources_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline consume_block_resources_result* New() const final {
    return new consume_block_resources_result();
  }

  consume_block_resources_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<consume_block_resources_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const consume_block_resources_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const consume_block_resources_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(consume_block_resources_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.consume_block_resources_result";
  }
  protected:
  explicit consume_block_resources_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.consume_block_resources_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class put_object_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.put_object_arguments) */ {
 public:
  inline put_object_arguments() : put_object_arguments(nullptr) {}
  ~put_object_arguments() override;
  explicit constexpr put_object_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  put_object_arguments(const put_object_arguments& from);
  put_object_arguments(put_object_arguments&& from) noexcept
    : put_object_arguments() {
    *this = ::std::move(from);
  }

  inline put_object_arguments& operator=(const put_object_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline put_object_arguments& operator=(put_object_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const put_object_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const put_object_arguments* internal_default_instance() {
    return reinterpret_cast<const put_object_arguments*>(
               &_put_object_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(put_object_arguments& a, put_object_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(put_object_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(put_object_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline put_object_arguments* New() const final {
    return new put_object_arguments();
  }

  put_object_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<put_object_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const put_object_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const put_object_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(put_object_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.put_object_arguments";
  }
  protected:
  explicit put_object_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kObjFieldNumber = 3,
    kSpaceFieldNumber = 1,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes obj = 3;
  void clear_obj();
  const std::string& obj() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_obj(ArgT0&& arg0, ArgT... args);
  std::string* mutable_obj();
  PROTOBUF_MUST_USE_RESULT std::string* release_obj();
  void set_allocated_obj(std::string* obj);
  private:
  const std::string& _internal_obj() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obj(const std::string& value);
  std::string* _internal_mutable_obj();
  public:

  // .koinos.chain.object_space space = 1;
  bool has_space() const;
  private:
  bool _internal_has_space() const;
  public:
  void clear_space();
  const ::koinos::chain::object_space& space() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::object_space* release_space();
  ::koinos::chain::object_space* mutable_space();
  void set_allocated_space(::koinos::chain::object_space* space);
  private:
  const ::koinos::chain::object_space& _internal_space() const;
  ::koinos::chain::object_space* _internal_mutable_space();
  public:
  void unsafe_arena_set_allocated_space(
      ::koinos::chain::object_space* space);
  ::koinos::chain::object_space* unsafe_arena_release_space();

  // @@protoc_insertion_point(class_scope:koinos.chain.put_object_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obj_;
  ::koinos::chain::object_space* space_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class put_object_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.put_object_result) */ {
 public:
  inline put_object_result() : put_object_result(nullptr) {}
  ~put_object_result() override;
  explicit constexpr put_object_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  put_object_result(const put_object_result& from);
  put_object_result(put_object_result&& from) noexcept
    : put_object_result() {
    *this = ::std::move(from);
  }

  inline put_object_result& operator=(const put_object_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline put_object_result& operator=(put_object_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const put_object_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const put_object_result* internal_default_instance() {
    return reinterpret_cast<const put_object_result*>(
               &_put_object_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(put_object_result& a, put_object_result& b) {
    a.Swap(&b);
  }
  inline void Swap(put_object_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(put_object_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline put_object_result* New() const final {
    return new put_object_result();
  }

  put_object_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<put_object_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const put_object_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const put_object_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(put_object_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.put_object_result";
  }
  protected:
  explicit put_object_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.put_object_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class remove_object_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.remove_object_arguments) */ {
 public:
  inline remove_object_arguments() : remove_object_arguments(nullptr) {}
  ~remove_object_arguments() override;
  explicit constexpr remove_object_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  remove_object_arguments(const remove_object_arguments& from);
  remove_object_arguments(remove_object_arguments&& from) noexcept
    : remove_object_arguments() {
    *this = ::std::move(from);
  }

  inline remove_object_arguments& operator=(const remove_object_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline remove_object_arguments& operator=(remove_object_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const remove_object_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const remove_object_arguments* internal_default_instance() {
    return reinterpret_cast<const remove_object_arguments*>(
               &_remove_object_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(remove_object_arguments& a, remove_object_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(remove_object_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(remove_object_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline remove_object_arguments* New() const final {
    return new remove_object_arguments();
  }

  remove_object_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<remove_object_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const remove_object_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const remove_object_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(remove_object_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.remove_object_arguments";
  }
  protected:
  explicit remove_object_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kSpaceFieldNumber = 1,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .koinos.chain.object_space space = 1;
  bool has_space() const;
  private:
  bool _internal_has_space() const;
  public:
  void clear_space();
  const ::koinos::chain::object_space& space() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::object_space* release_space();
  ::koinos::chain::object_space* mutable_space();
  void set_allocated_space(::koinos::chain::object_space* space);
  private:
  const ::koinos::chain::object_space& _internal_space() const;
  ::koinos::chain::object_space* _internal_mutable_space();
  public:
  void unsafe_arena_set_allocated_space(
      ::koinos::chain::object_space* space);
  ::koinos::chain::object_space* unsafe_arena_release_space();

  // @@protoc_insertion_point(class_scope:koinos.chain.remove_object_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::koinos::chain::object_space* space_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class remove_object_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.remove_object_result) */ {
 public:
  inline remove_object_result() : remove_object_result(nullptr) {}
  ~remove_object_result() override;
  explicit constexpr remove_object_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  remove_object_result(const remove_object_result& from);
  remove_object_result(remove_object_result&& from) noexcept
    : remove_object_result() {
    *this = ::std::move(from);
  }

  inline remove_object_result& operator=(const remove_object_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline remove_object_result& operator=(remove_object_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const remove_object_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const remove_object_result* internal_default_instance() {
    return reinterpret_cast<const remove_object_result*>(
               &_remove_object_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(remove_object_result& a, remove_object_result& b) {
    a.Swap(&b);
  }
  inline void Swap(remove_object_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(remove_object_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline remove_object_result* New() const final {
    return new remove_object_result();
  }

  remove_object_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<remove_object_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const remove_object_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const remove_object_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(remove_object_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.remove_object_result";
  }
  protected:
  explicit remove_object_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.remove_object_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_object_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_object_arguments) */ {
 public:
  inline get_object_arguments() : get_object_arguments(nullptr) {}
  ~get_object_arguments() override;
  explicit constexpr get_object_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_object_arguments(const get_object_arguments& from);
  get_object_arguments(get_object_arguments&& from) noexcept
    : get_object_arguments() {
    *this = ::std::move(from);
  }

  inline get_object_arguments& operator=(const get_object_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_object_arguments& operator=(get_object_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_object_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_object_arguments* internal_default_instance() {
    return reinterpret_cast<const get_object_arguments*>(
               &_get_object_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(get_object_arguments& a, get_object_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_object_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_object_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_object_arguments* New() const final {
    return new get_object_arguments();
  }

  get_object_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_object_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_object_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_object_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_object_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_object_arguments";
  }
  protected:
  explicit get_object_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kSpaceFieldNumber = 1,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .koinos.chain.object_space space = 1;
  bool has_space() const;
  private:
  bool _internal_has_space() const;
  public:
  void clear_space();
  const ::koinos::chain::object_space& space() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::object_space* release_space();
  ::koinos::chain::object_space* mutable_space();
  void set_allocated_space(::koinos::chain::object_space* space);
  private:
  const ::koinos::chain::object_space& _internal_space() const;
  ::koinos::chain::object_space* _internal_mutable_space();
  public:
  void unsafe_arena_set_allocated_space(
      ::koinos::chain::object_space* space);
  ::koinos::chain::object_space* unsafe_arena_release_space();

  // @@protoc_insertion_point(class_scope:koinos.chain.get_object_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::koinos::chain::object_space* space_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class database_object final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.database_object) */ {
 public:
  inline database_object() : database_object(nullptr) {}
  ~database_object() override;
  explicit constexpr database_object(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  database_object(const database_object& from);
  database_object(database_object&& from) noexcept
    : database_object() {
    *this = ::std::move(from);
  }

  inline database_object& operator=(const database_object& from) {
    CopyFrom(from);
    return *this;
  }
  inline database_object& operator=(database_object&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const database_object& default_instance() {
    return *internal_default_instance();
  }
  static inline const database_object* internal_default_instance() {
    return reinterpret_cast<const database_object*>(
               &_database_object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(database_object& a, database_object& b) {
    a.Swap(&b);
  }
  inline void Swap(database_object* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(database_object* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline database_object* New() const final {
    return new database_object();
  }

  database_object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<database_object>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const database_object& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const database_object& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(database_object* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.database_object";
  }
  protected:
  explicit database_object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kKeyFieldNumber = 3,
    kExistsFieldNumber = 1,
  };
  // bytes value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // bytes key = 3;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bool exists = 1;
  void clear_exists();
  bool exists() const;
  void set_exists(bool value);
  private:
  bool _internal_exists() const;
  void _internal_set_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.database_object)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  bool exists_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_object_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_object_result) */ {
 public:
  inline get_object_result() : get_object_result(nullptr) {}
  ~get_object_result() override;
  explicit constexpr get_object_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_object_result(const get_object_result& from);
  get_object_result(get_object_result&& from) noexcept
    : get_object_result() {
    *this = ::std::move(from);
  }

  inline get_object_result& operator=(const get_object_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_object_result& operator=(get_object_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_object_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_object_result* internal_default_instance() {
    return reinterpret_cast<const get_object_result*>(
               &_get_object_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(get_object_result& a, get_object_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_object_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_object_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_object_result* New() const final {
    return new get_object_result();
  }

  get_object_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_object_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_object_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_object_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_object_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_object_result";
  }
  protected:
  explicit get_object_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .koinos.chain.database_object value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::koinos::chain::database_object& value() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::database_object* release_value();
  ::koinos::chain::database_object* mutable_value();
  void set_allocated_value(::koinos::chain::database_object* value);
  private:
  const ::koinos::chain::database_object& _internal_value() const;
  ::koinos::chain::database_object* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::koinos::chain::database_object* value);
  ::koinos::chain::database_object* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:koinos.chain.get_object_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::chain::database_object* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_next_object_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_next_object_arguments) */ {
 public:
  inline get_next_object_arguments() : get_next_object_arguments(nullptr) {}
  ~get_next_object_arguments() override;
  explicit constexpr get_next_object_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_next_object_arguments(const get_next_object_arguments& from);
  get_next_object_arguments(get_next_object_arguments&& from) noexcept
    : get_next_object_arguments() {
    *this = ::std::move(from);
  }

  inline get_next_object_arguments& operator=(const get_next_object_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_next_object_arguments& operator=(get_next_object_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_next_object_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_next_object_arguments* internal_default_instance() {
    return reinterpret_cast<const get_next_object_arguments*>(
               &_get_next_object_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(get_next_object_arguments& a, get_next_object_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_next_object_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_next_object_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_next_object_arguments* New() const final {
    return new get_next_object_arguments();
  }

  get_next_object_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_next_object_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_next_object_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_next_object_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_next_object_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_next_object_arguments";
  }
  protected:
  explicit get_next_object_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kSpaceFieldNumber = 1,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .koinos.chain.object_space space = 1;
  bool has_space() const;
  private:
  bool _internal_has_space() const;
  public:
  void clear_space();
  const ::koinos::chain::object_space& space() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::object_space* release_space();
  ::koinos::chain::object_space* mutable_space();
  void set_allocated_space(::koinos::chain::object_space* space);
  private:
  const ::koinos::chain::object_space& _internal_space() const;
  ::koinos::chain::object_space* _internal_mutable_space();
  public:
  void unsafe_arena_set_allocated_space(
      ::koinos::chain::object_space* space);
  ::koinos::chain::object_space* unsafe_arena_release_space();

  // @@protoc_insertion_point(class_scope:koinos.chain.get_next_object_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::koinos::chain::object_space* space_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_next_object_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_next_object_result) */ {
 public:
  inline get_next_object_result() : get_next_object_result(nullptr) {}
  ~get_next_object_result() override;
  explicit constexpr get_next_object_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_next_object_result(const get_next_object_result& from);
  get_next_object_result(get_next_object_result&& from) noexcept
    : get_next_object_result() {
    *this = ::std::move(from);
  }

  inline get_next_object_result& operator=(const get_next_object_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_next_object_result& operator=(get_next_object_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_next_object_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_next_object_result* internal_default_instance() {
    return reinterpret_cast<const get_next_object_result*>(
               &_get_next_object_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(get_next_object_result& a, get_next_object_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_next_object_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_next_object_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_next_object_result* New() const final {
    return new get_next_object_result();
  }

  get_next_object_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_next_object_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_next_object_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_next_object_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_next_object_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_next_object_result";
  }
  protected:
  explicit get_next_object_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .koinos.chain.database_object value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::koinos::chain::database_object& value() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::database_object* release_value();
  ::koinos::chain::database_object* mutable_value();
  void set_allocated_value(::koinos::chain::database_object* value);
  private:
  const ::koinos::chain::database_object& _internal_value() const;
  ::koinos::chain::database_object* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::koinos::chain::database_object* value);
  ::koinos::chain::database_object* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:koinos.chain.get_next_object_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::chain::database_object* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_prev_object_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_prev_object_arguments) */ {
 public:
  inline get_prev_object_arguments() : get_prev_object_arguments(nullptr) {}
  ~get_prev_object_arguments() override;
  explicit constexpr get_prev_object_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_prev_object_arguments(const get_prev_object_arguments& from);
  get_prev_object_arguments(get_prev_object_arguments&& from) noexcept
    : get_prev_object_arguments() {
    *this = ::std::move(from);
  }

  inline get_prev_object_arguments& operator=(const get_prev_object_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_prev_object_arguments& operator=(get_prev_object_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_prev_object_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_prev_object_arguments* internal_default_instance() {
    return reinterpret_cast<const get_prev_object_arguments*>(
               &_get_prev_object_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(get_prev_object_arguments& a, get_prev_object_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_prev_object_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_prev_object_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_prev_object_arguments* New() const final {
    return new get_prev_object_arguments();
  }

  get_prev_object_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_prev_object_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_prev_object_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_prev_object_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_prev_object_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_prev_object_arguments";
  }
  protected:
  explicit get_prev_object_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kSpaceFieldNumber = 1,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .koinos.chain.object_space space = 1;
  bool has_space() const;
  private:
  bool _internal_has_space() const;
  public:
  void clear_space();
  const ::koinos::chain::object_space& space() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::object_space* release_space();
  ::koinos::chain::object_space* mutable_space();
  void set_allocated_space(::koinos::chain::object_space* space);
  private:
  const ::koinos::chain::object_space& _internal_space() const;
  ::koinos::chain::object_space* _internal_mutable_space();
  public:
  void unsafe_arena_set_allocated_space(
      ::koinos::chain::object_space* space);
  ::koinos::chain::object_space* unsafe_arena_release_space();

  // @@protoc_insertion_point(class_scope:koinos.chain.get_prev_object_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::koinos::chain::object_space* space_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_prev_object_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_prev_object_result) */ {
 public:
  inline get_prev_object_result() : get_prev_object_result(nullptr) {}
  ~get_prev_object_result() override;
  explicit constexpr get_prev_object_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_prev_object_result(const get_prev_object_result& from);
  get_prev_object_result(get_prev_object_result&& from) noexcept
    : get_prev_object_result() {
    *this = ::std::move(from);
  }

  inline get_prev_object_result& operator=(const get_prev_object_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_prev_object_result& operator=(get_prev_object_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_prev_object_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_prev_object_result* internal_default_instance() {
    return reinterpret_cast<const get_prev_object_result*>(
               &_get_prev_object_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(get_prev_object_result& a, get_prev_object_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_prev_object_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_prev_object_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_prev_object_result* New() const final {
    return new get_prev_object_result();
  }

  get_prev_object_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_prev_object_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_prev_object_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_prev_object_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_prev_object_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_prev_object_result";
  }
  protected:
  explicit get_prev_object_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .koinos.chain.database_object value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::koinos::chain::database_object& value() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::database_object* release_value();
  ::koinos::chain::database_object* mutable_value();
  void set_allocated_value(::koinos::chain::database_object* value);
  private:
  const ::koinos::chain::database_object& _internal_value() const;
  ::koinos::chain::database_object* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::koinos::chain::database_object* value);
  ::koinos::chain::database_object* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:koinos.chain.get_prev_object_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::chain::database_object* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class log_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.log_arguments) */ {
 public:
  inline log_arguments() : log_arguments(nullptr) {}
  ~log_arguments() override;
  explicit constexpr log_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  log_arguments(const log_arguments& from);
  log_arguments(log_arguments&& from) noexcept
    : log_arguments() {
    *this = ::std::move(from);
  }

  inline log_arguments& operator=(const log_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline log_arguments& operator=(log_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const log_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const log_arguments* internal_default_instance() {
    return reinterpret_cast<const log_arguments*>(
               &_log_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(log_arguments& a, log_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(log_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(log_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline log_arguments* New() const final {
    return new log_arguments();
  }

  log_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<log_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const log_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const log_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(log_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.log_arguments";
  }
  protected:
  explicit log_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.log_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class log_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.log_result) */ {
 public:
  inline log_result() : log_result(nullptr) {}
  ~log_result() override;
  explicit constexpr log_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  log_result(const log_result& from);
  log_result(log_result&& from) noexcept
    : log_result() {
    *this = ::std::move(from);
  }

  inline log_result& operator=(const log_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline log_result& operator=(log_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const log_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const log_result* internal_default_instance() {
    return reinterpret_cast<const log_result*>(
               &_log_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(log_result& a, log_result& b) {
    a.Swap(&b);
  }
  inline void Swap(log_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(log_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline log_result* New() const final {
    return new log_result();
  }

  log_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<log_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const log_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const log_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(log_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.log_result";
  }
  protected:
  explicit log_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.log_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class event_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.event_arguments) */ {
 public:
  inline event_arguments() : event_arguments(nullptr) {}
  ~event_arguments() override;
  explicit constexpr event_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  event_arguments(const event_arguments& from);
  event_arguments(event_arguments&& from) noexcept
    : event_arguments() {
    *this = ::std::move(from);
  }

  inline event_arguments& operator=(const event_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline event_arguments& operator=(event_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const event_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const event_arguments* internal_default_instance() {
    return reinterpret_cast<const event_arguments*>(
               &_event_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(event_arguments& a, event_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(event_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(event_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline event_arguments* New() const final {
    return new event_arguments();
  }

  event_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<event_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const event_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const event_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(event_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.event_arguments";
  }
  protected:
  explicit event_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImpactedFieldNumber = 3,
    kNameFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // repeated bytes impacted = 3 [(.koinos.btype) = ADDRESS];
  int impacted_size() const;
  private:
  int _internal_impacted_size() const;
  public:
  void clear_impacted();
  const std::string& impacted(int index) const;
  std::string* mutable_impacted(int index);
  void set_impacted(int index, const std::string& value);
  void set_impacted(int index, std::string&& value);
  void set_impacted(int index, const char* value);
  void set_impacted(int index, const void* value, size_t size);
  std::string* add_impacted();
  void add_impacted(const std::string& value);
  void add_impacted(std::string&& value);
  void add_impacted(const char* value);
  void add_impacted(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& impacted() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_impacted();
  private:
  const std::string& _internal_impacted(int index) const;
  std::string* _internal_add_impacted();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.event_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> impacted_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class event_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.event_result) */ {
 public:
  inline event_result() : event_result(nullptr) {}
  ~event_result() override;
  explicit constexpr event_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  event_result(const event_result& from);
  event_result(event_result&& from) noexcept
    : event_result() {
    *this = ::std::move(from);
  }

  inline event_result& operator=(const event_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline event_result& operator=(event_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const event_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const event_result* internal_default_instance() {
    return reinterpret_cast<const event_result*>(
               &_event_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(event_result& a, event_result& b) {
    a.Swap(&b);
  }
  inline void Swap(event_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(event_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline event_result* New() const final {
    return new event_result();
  }

  event_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<event_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const event_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const event_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(event_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.event_result";
  }
  protected:
  explicit event_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.event_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class hash_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.hash_arguments) */ {
 public:
  inline hash_arguments() : hash_arguments(nullptr) {}
  ~hash_arguments() override;
  explicit constexpr hash_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  hash_arguments(const hash_arguments& from);
  hash_arguments(hash_arguments&& from) noexcept
    : hash_arguments() {
    *this = ::std::move(from);
  }

  inline hash_arguments& operator=(const hash_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline hash_arguments& operator=(hash_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const hash_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const hash_arguments* internal_default_instance() {
    return reinterpret_cast<const hash_arguments*>(
               &_hash_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(hash_arguments& a, hash_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(hash_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(hash_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline hash_arguments* New() const final {
    return new hash_arguments();
  }

  hash_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<hash_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const hash_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const hash_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(hash_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.hash_arguments";
  }
  protected:
  explicit hash_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjFieldNumber = 2,
    kCodeFieldNumber = 1,
    kSizeFieldNumber = 3,
  };
  // bytes obj = 2;
  void clear_obj();
  const std::string& obj() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_obj(ArgT0&& arg0, ArgT... args);
  std::string* mutable_obj();
  PROTOBUF_MUST_USE_RESULT std::string* release_obj();
  void set_allocated_obj(std::string* obj);
  private:
  const std::string& _internal_obj() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obj(const std::string& value);
  std::string* _internal_mutable_obj();
  public:

  // uint64 code = 1 [jstype = JS_STRING];
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::uint64 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 size = 3 [jstype = JS_STRING];
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.hash_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obj_;
  ::PROTOBUF_NAMESPACE_ID::uint64 code_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class hash_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.hash_result) */ {
 public:
  inline hash_result() : hash_result(nullptr) {}
  ~hash_result() override;
  explicit constexpr hash_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  hash_result(const hash_result& from);
  hash_result(hash_result&& from) noexcept
    : hash_result() {
    *this = ::std::move(from);
  }

  inline hash_result& operator=(const hash_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline hash_result& operator=(hash_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const hash_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const hash_result* internal_default_instance() {
    return reinterpret_cast<const hash_result*>(
               &_hash_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(hash_result& a, hash_result& b) {
    a.Swap(&b);
  }
  inline void Swap(hash_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(hash_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline hash_result* New() const final {
    return new hash_result();
  }

  hash_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<hash_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const hash_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const hash_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(hash_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.hash_result";
  }
  protected:
  explicit hash_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.hash_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class recover_public_key_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.recover_public_key_arguments) */ {
 public:
  inline recover_public_key_arguments() : recover_public_key_arguments(nullptr) {}
  ~recover_public_key_arguments() override;
  explicit constexpr recover_public_key_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  recover_public_key_arguments(const recover_public_key_arguments& from);
  recover_public_key_arguments(recover_public_key_arguments&& from) noexcept
    : recover_public_key_arguments() {
    *this = ::std::move(from);
  }

  inline recover_public_key_arguments& operator=(const recover_public_key_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline recover_public_key_arguments& operator=(recover_public_key_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const recover_public_key_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const recover_public_key_arguments* internal_default_instance() {
    return reinterpret_cast<const recover_public_key_arguments*>(
               &_recover_public_key_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(recover_public_key_arguments& a, recover_public_key_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(recover_public_key_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(recover_public_key_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline recover_public_key_arguments* New() const final {
    return new recover_public_key_arguments();
  }

  recover_public_key_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<recover_public_key_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const recover_public_key_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const recover_public_key_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(recover_public_key_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.recover_public_key_arguments";
  }
  protected:
  explicit recover_public_key_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 2,
    kDigestFieldNumber = 3,
    kTypeFieldNumber = 1,
    kCompressedFieldNumber = 4,
  };
  // bytes signature = 2;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_MUST_USE_RESULT std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // bytes digest = 3;
  void clear_digest();
  const std::string& digest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_digest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_digest();
  PROTOBUF_MUST_USE_RESULT std::string* release_digest();
  void set_allocated_digest(std::string* digest);
  private:
  const std::string& _internal_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_digest(const std::string& value);
  std::string* _internal_mutable_digest();
  public:

  // .koinos.chain.dsa type = 1;
  void clear_type();
  ::koinos::chain::dsa type() const;
  void set_type(::koinos::chain::dsa value);
  private:
  ::koinos::chain::dsa _internal_type() const;
  void _internal_set_type(::koinos::chain::dsa value);
  public:

  // bool compressed = 4;
  void clear_compressed();
  bool compressed() const;
  void set_compressed(bool value);
  private:
  bool _internal_compressed() const;
  void _internal_set_compressed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.recover_public_key_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
  int type_;
  bool compressed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class recover_public_key_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.recover_public_key_result) */ {
 public:
  inline recover_public_key_result() : recover_public_key_result(nullptr) {}
  ~recover_public_key_result() override;
  explicit constexpr recover_public_key_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  recover_public_key_result(const recover_public_key_result& from);
  recover_public_key_result(recover_public_key_result&& from) noexcept
    : recover_public_key_result() {
    *this = ::std::move(from);
  }

  inline recover_public_key_result& operator=(const recover_public_key_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline recover_public_key_result& operator=(recover_public_key_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const recover_public_key_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const recover_public_key_result* internal_default_instance() {
    return reinterpret_cast<const recover_public_key_result*>(
               &_recover_public_key_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(recover_public_key_result& a, recover_public_key_result& b) {
    a.Swap(&b);
  }
  inline void Swap(recover_public_key_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(recover_public_key_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline recover_public_key_result* New() const final {
    return new recover_public_key_result();
  }

  recover_public_key_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<recover_public_key_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const recover_public_key_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const recover_public_key_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(recover_public_key_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.recover_public_key_result";
  }
  protected:
  explicit recover_public_key_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1 [(.koinos.btype) = BASE64];
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.recover_public_key_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class verify_merkle_root_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.verify_merkle_root_arguments) */ {
 public:
  inline verify_merkle_root_arguments() : verify_merkle_root_arguments(nullptr) {}
  ~verify_merkle_root_arguments() override;
  explicit constexpr verify_merkle_root_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  verify_merkle_root_arguments(const verify_merkle_root_arguments& from);
  verify_merkle_root_arguments(verify_merkle_root_arguments&& from) noexcept
    : verify_merkle_root_arguments() {
    *this = ::std::move(from);
  }

  inline verify_merkle_root_arguments& operator=(const verify_merkle_root_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline verify_merkle_root_arguments& operator=(verify_merkle_root_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const verify_merkle_root_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const verify_merkle_root_arguments* internal_default_instance() {
    return reinterpret_cast<const verify_merkle_root_arguments*>(
               &_verify_merkle_root_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(verify_merkle_root_arguments& a, verify_merkle_root_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(verify_merkle_root_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(verify_merkle_root_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline verify_merkle_root_arguments* New() const final {
    return new verify_merkle_root_arguments();
  }

  verify_merkle_root_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<verify_merkle_root_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const verify_merkle_root_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const verify_merkle_root_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(verify_merkle_root_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.verify_merkle_root_arguments";
  }
  protected:
  explicit verify_merkle_root_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashesFieldNumber = 2,
    kRootFieldNumber = 1,
  };
  // repeated bytes hashes = 2;
  int hashes_size() const;
  private:
  int _internal_hashes_size() const;
  public:
  void clear_hashes();
  const std::string& hashes(int index) const;
  std::string* mutable_hashes(int index);
  void set_hashes(int index, const std::string& value);
  void set_hashes(int index, std::string&& value);
  void set_hashes(int index, const char* value);
  void set_hashes(int index, const void* value, size_t size);
  std::string* add_hashes();
  void add_hashes(const std::string& value);
  void add_hashes(std::string&& value);
  void add_hashes(const char* value);
  void add_hashes(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hashes();
  private:
  const std::string& _internal_hashes(int index) const;
  std::string* _internal_add_hashes();
  public:

  // bytes root = 1;
  void clear_root();
  const std::string& root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_root();
  PROTOBUF_MUST_USE_RESULT std::string* release_root();
  void set_allocated_root(std::string* root);
  private:
  const std::string& _internal_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_root(const std::string& value);
  std::string* _internal_mutable_root();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.verify_merkle_root_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hashes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr root_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class verify_merkle_root_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.verify_merkle_root_result) */ {
 public:
  inline verify_merkle_root_result() : verify_merkle_root_result(nullptr) {}
  ~verify_merkle_root_result() override;
  explicit constexpr verify_merkle_root_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  verify_merkle_root_result(const verify_merkle_root_result& from);
  verify_merkle_root_result(verify_merkle_root_result&& from) noexcept
    : verify_merkle_root_result() {
    *this = ::std::move(from);
  }

  inline verify_merkle_root_result& operator=(const verify_merkle_root_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline verify_merkle_root_result& operator=(verify_merkle_root_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const verify_merkle_root_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const verify_merkle_root_result* internal_default_instance() {
    return reinterpret_cast<const verify_merkle_root_result*>(
               &_verify_merkle_root_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(verify_merkle_root_result& a, verify_merkle_root_result& b) {
    a.Swap(&b);
  }
  inline void Swap(verify_merkle_root_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(verify_merkle_root_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline verify_merkle_root_result* New() const final {
    return new verify_merkle_root_result();
  }

  verify_merkle_root_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<verify_merkle_root_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const verify_merkle_root_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const verify_merkle_root_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(verify_merkle_root_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.verify_merkle_root_result";
  }
  protected:
  explicit verify_merkle_root_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.verify_merkle_root_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class verify_signature_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.verify_signature_arguments) */ {
 public:
  inline verify_signature_arguments() : verify_signature_arguments(nullptr) {}
  ~verify_signature_arguments() override;
  explicit constexpr verify_signature_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  verify_signature_arguments(const verify_signature_arguments& from);
  verify_signature_arguments(verify_signature_arguments&& from) noexcept
    : verify_signature_arguments() {
    *this = ::std::move(from);
  }

  inline verify_signature_arguments& operator=(const verify_signature_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline verify_signature_arguments& operator=(verify_signature_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const verify_signature_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const verify_signature_arguments* internal_default_instance() {
    return reinterpret_cast<const verify_signature_arguments*>(
               &_verify_signature_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(verify_signature_arguments& a, verify_signature_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(verify_signature_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(verify_signature_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline verify_signature_arguments* New() const final {
    return new verify_signature_arguments();
  }

  verify_signature_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<verify_signature_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const verify_signature_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const verify_signature_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(verify_signature_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.verify_signature_arguments";
  }
  protected:
  explicit verify_signature_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 2,
    kSignatureFieldNumber = 3,
    kDigestFieldNumber = 4,
    kTypeFieldNumber = 1,
    kCompressedFieldNumber = 5,
  };
  // bytes public_key = 2 [(.koinos.btype) = BASE64];
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // bytes signature = 3 [(.koinos.btype) = BASE64];
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_MUST_USE_RESULT std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // bytes digest = 4 [(.koinos.btype) = BASE64];
  void clear_digest();
  const std::string& digest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_digest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_digest();
  PROTOBUF_MUST_USE_RESULT std::string* release_digest();
  void set_allocated_digest(std::string* digest);
  private:
  const std::string& _internal_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_digest(const std::string& value);
  std::string* _internal_mutable_digest();
  public:

  // .koinos.chain.dsa type = 1;
  void clear_type();
  ::koinos::chain::dsa type() const;
  void set_type(::koinos::chain::dsa value);
  private:
  ::koinos::chain::dsa _internal_type() const;
  void _internal_set_type(::koinos::chain::dsa value);
  public:

  // bool compressed = 5;
  void clear_compressed();
  bool compressed() const;
  void set_compressed(bool value);
  private:
  bool _internal_compressed() const;
  void _internal_set_compressed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.verify_signature_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
  int type_;
  bool compressed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class verify_signature_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.verify_signature_result) */ {
 public:
  inline verify_signature_result() : verify_signature_result(nullptr) {}
  ~verify_signature_result() override;
  explicit constexpr verify_signature_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  verify_signature_result(const verify_signature_result& from);
  verify_signature_result(verify_signature_result&& from) noexcept
    : verify_signature_result() {
    *this = ::std::move(from);
  }

  inline verify_signature_result& operator=(const verify_signature_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline verify_signature_result& operator=(verify_signature_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const verify_signature_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const verify_signature_result* internal_default_instance() {
    return reinterpret_cast<const verify_signature_result*>(
               &_verify_signature_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(verify_signature_result& a, verify_signature_result& b) {
    a.Swap(&b);
  }
  inline void Swap(verify_signature_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(verify_signature_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline verify_signature_result* New() const final {
    return new verify_signature_result();
  }

  verify_signature_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<verify_signature_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const verify_signature_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const verify_signature_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(verify_signature_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.verify_signature_result";
  }
  protected:
  explicit verify_signature_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.verify_signature_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class verify_vrf_proof_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.verify_vrf_proof_arguments) */ {
 public:
  inline verify_vrf_proof_arguments() : verify_vrf_proof_arguments(nullptr) {}
  ~verify_vrf_proof_arguments() override;
  explicit constexpr verify_vrf_proof_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  verify_vrf_proof_arguments(const verify_vrf_proof_arguments& from);
  verify_vrf_proof_arguments(verify_vrf_proof_arguments&& from) noexcept
    : verify_vrf_proof_arguments() {
    *this = ::std::move(from);
  }

  inline verify_vrf_proof_arguments& operator=(const verify_vrf_proof_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline verify_vrf_proof_arguments& operator=(verify_vrf_proof_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const verify_vrf_proof_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const verify_vrf_proof_arguments* internal_default_instance() {
    return reinterpret_cast<const verify_vrf_proof_arguments*>(
               &_verify_vrf_proof_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(verify_vrf_proof_arguments& a, verify_vrf_proof_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(verify_vrf_proof_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(verify_vrf_proof_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline verify_vrf_proof_arguments* New() const final {
    return new verify_vrf_proof_arguments();
  }

  verify_vrf_proof_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<verify_vrf_proof_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const verify_vrf_proof_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const verify_vrf_proof_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(verify_vrf_proof_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.verify_vrf_proof_arguments";
  }
  protected:
  explicit verify_vrf_proof_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 2,
    kProofFieldNumber = 3,
    kHashFieldNumber = 4,
    kMessageFieldNumber = 5,
    kTypeFieldNumber = 1,
  };
  // bytes public_key = 2 [(.koinos.btype) = BASE64];
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // bytes proof = 3 [(.koinos.btype) = BASE64];
  void clear_proof();
  const std::string& proof() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proof(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proof();
  PROTOBUF_MUST_USE_RESULT std::string* release_proof();
  void set_allocated_proof(std::string* proof);
  private:
  const std::string& _internal_proof() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proof(const std::string& value);
  std::string* _internal_mutable_proof();
  public:

  // bytes hash = 4 [(.koinos.btype) = BASE64];
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_MUST_USE_RESULT std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // bytes message = 5 [(.koinos.btype) = BASE64];
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .koinos.chain.dsa type = 1;
  void clear_type();
  ::koinos::chain::dsa type() const;
  void set_type(::koinos::chain::dsa value);
  private:
  ::koinos::chain::dsa _internal_type() const;
  void _internal_set_type(::koinos::chain::dsa value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.verify_vrf_proof_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proof_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class verify_vrf_proof_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.verify_vrf_proof_result) */ {
 public:
  inline verify_vrf_proof_result() : verify_vrf_proof_result(nullptr) {}
  ~verify_vrf_proof_result() override;
  explicit constexpr verify_vrf_proof_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  verify_vrf_proof_result(const verify_vrf_proof_result& from);
  verify_vrf_proof_result(verify_vrf_proof_result&& from) noexcept
    : verify_vrf_proof_result() {
    *this = ::std::move(from);
  }

  inline verify_vrf_proof_result& operator=(const verify_vrf_proof_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline verify_vrf_proof_result& operator=(verify_vrf_proof_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const verify_vrf_proof_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const verify_vrf_proof_result* internal_default_instance() {
    return reinterpret_cast<const verify_vrf_proof_result*>(
               &_verify_vrf_proof_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(verify_vrf_proof_result& a, verify_vrf_proof_result& b) {
    a.Swap(&b);
  }
  inline void Swap(verify_vrf_proof_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(verify_vrf_proof_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline verify_vrf_proof_result* New() const final {
    return new verify_vrf_proof_result();
  }

  verify_vrf_proof_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<verify_vrf_proof_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const verify_vrf_proof_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const verify_vrf_proof_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(verify_vrf_proof_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.verify_vrf_proof_result";
  }
  protected:
  explicit verify_vrf_proof_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.verify_vrf_proof_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class call_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.call_arguments) */ {
 public:
  inline call_arguments() : call_arguments(nullptr) {}
  ~call_arguments() override;
  explicit constexpr call_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  call_arguments(const call_arguments& from);
  call_arguments(call_arguments&& from) noexcept
    : call_arguments() {
    *this = ::std::move(from);
  }

  inline call_arguments& operator=(const call_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline call_arguments& operator=(call_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const call_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const call_arguments* internal_default_instance() {
    return reinterpret_cast<const call_arguments*>(
               &_call_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(call_arguments& a, call_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(call_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(call_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline call_arguments* New() const final {
    return new call_arguments();
  }

  call_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<call_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const call_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const call_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(call_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.call_arguments";
  }
  protected:
  explicit call_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 1,
    kArgsFieldNumber = 3,
    kEntryPointFieldNumber = 2,
  };
  // bytes contract_id = 1 [(.koinos.btype) = CONTRACT_ID];
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // bytes args = 3;
  void clear_args();
  const std::string& args() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_args(ArgT0&& arg0, ArgT... args);
  std::string* mutable_args();
  PROTOBUF_MUST_USE_RESULT std::string* release_args();
  void set_allocated_args(std::string* args);
  private:
  const std::string& _internal_args() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_args(const std::string& value);
  std::string* _internal_mutable_args();
  public:

  // uint32 entry_point = 2;
  void clear_entry_point();
  ::PROTOBUF_NAMESPACE_ID::uint32 entry_point() const;
  void set_entry_point(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_entry_point() const;
  void _internal_set_entry_point(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.call_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr args_;
  ::PROTOBUF_NAMESPACE_ID::uint32 entry_point_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class call_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.call_result) */ {
 public:
  inline call_result() : call_result(nullptr) {}
  ~call_result() override;
  explicit constexpr call_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  call_result(const call_result& from);
  call_result(call_result&& from) noexcept
    : call_result() {
    *this = ::std::move(from);
  }

  inline call_result& operator=(const call_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline call_result& operator=(call_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const call_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const call_result* internal_default_instance() {
    return reinterpret_cast<const call_result*>(
               &_call_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(call_result& a, call_result& b) {
    a.Swap(&b);
  }
  inline void Swap(call_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(call_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline call_result* New() const final {
    return new call_result();
  }

  call_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<call_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const call_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const call_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(call_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.call_result";
  }
  protected:
  explicit call_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.call_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_arguments_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_arguments_arguments) */ {
 public:
  inline get_arguments_arguments() : get_arguments_arguments(nullptr) {}
  ~get_arguments_arguments() override;
  explicit constexpr get_arguments_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_arguments_arguments(const get_arguments_arguments& from);
  get_arguments_arguments(get_arguments_arguments&& from) noexcept
    : get_arguments_arguments() {
    *this = ::std::move(from);
  }

  inline get_arguments_arguments& operator=(const get_arguments_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_arguments_arguments& operator=(get_arguments_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_arguments_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_arguments_arguments* internal_default_instance() {
    return reinterpret_cast<const get_arguments_arguments*>(
               &_get_arguments_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(get_arguments_arguments& a, get_arguments_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_arguments_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_arguments_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_arguments_arguments* New() const final {
    return new get_arguments_arguments();
  }

  get_arguments_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_arguments_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_arguments_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_arguments_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_arguments_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_arguments_arguments";
  }
  protected:
  explicit get_arguments_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.get_arguments_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_arguments_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_arguments_result) */ {
 public:
  inline get_arguments_result() : get_arguments_result(nullptr) {}
  ~get_arguments_result() override;
  explicit constexpr get_arguments_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_arguments_result(const get_arguments_result& from);
  get_arguments_result(get_arguments_result&& from) noexcept
    : get_arguments_result() {
    *this = ::std::move(from);
  }

  inline get_arguments_result& operator=(const get_arguments_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_arguments_result& operator=(get_arguments_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_arguments_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_arguments_result* internal_default_instance() {
    return reinterpret_cast<const get_arguments_result*>(
               &_get_arguments_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(get_arguments_result& a, get_arguments_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_arguments_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_arguments_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_arguments_result* New() const final {
    return new get_arguments_result();
  }

  get_arguments_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_arguments_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_arguments_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_arguments_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_arguments_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_arguments_result";
  }
  protected:
  explicit get_arguments_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .koinos.chain.argument_data value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::koinos::chain::argument_data& value() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::argument_data* release_value();
  ::koinos::chain::argument_data* mutable_value();
  void set_allocated_value(::koinos::chain::argument_data* value);
  private:
  const ::koinos::chain::argument_data& _internal_value() const;
  ::koinos::chain::argument_data* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::koinos::chain::argument_data* value);
  ::koinos::chain::argument_data* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:koinos.chain.get_arguments_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::chain::argument_data* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class exit_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.exit_arguments) */ {
 public:
  inline exit_arguments() : exit_arguments(nullptr) {}
  ~exit_arguments() override;
  explicit constexpr exit_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  exit_arguments(const exit_arguments& from);
  exit_arguments(exit_arguments&& from) noexcept
    : exit_arguments() {
    *this = ::std::move(from);
  }

  inline exit_arguments& operator=(const exit_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline exit_arguments& operator=(exit_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const exit_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const exit_arguments* internal_default_instance() {
    return reinterpret_cast<const exit_arguments*>(
               &_exit_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(exit_arguments& a, exit_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(exit_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(exit_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline exit_arguments* New() const final {
    return new exit_arguments();
  }

  exit_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<exit_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const exit_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const exit_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(exit_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.exit_arguments";
  }
  protected:
  explicit exit_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // .koinos.chain.result res = 2;
  bool has_res() const;
  private:
  bool _internal_has_res() const;
  public:
  void clear_res();
  const ::koinos::chain::result& res() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::result* release_res();
  ::koinos::chain::result* mutable_res();
  void set_allocated_res(::koinos::chain::result* res);
  private:
  const ::koinos::chain::result& _internal_res() const;
  ::koinos::chain::result* _internal_mutable_res();
  public:
  void unsafe_arena_set_allocated_res(
      ::koinos::chain::result* res);
  ::koinos::chain::result* unsafe_arena_release_res();

  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.exit_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::chain::result* res_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class exit_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.exit_result) */ {
 public:
  inline exit_result() : exit_result(nullptr) {}
  ~exit_result() override;
  explicit constexpr exit_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  exit_result(const exit_result& from);
  exit_result(exit_result&& from) noexcept
    : exit_result() {
    *this = ::std::move(from);
  }

  inline exit_result& operator=(const exit_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline exit_result& operator=(exit_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const exit_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const exit_result* internal_default_instance() {
    return reinterpret_cast<const exit_result*>(
               &_exit_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(exit_result& a, exit_result& b) {
    a.Swap(&b);
  }
  inline void Swap(exit_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(exit_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline exit_result* New() const final {
    return new exit_result();
  }

  exit_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<exit_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const exit_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const exit_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(exit_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.exit_result";
  }
  protected:
  explicit exit_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.exit_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_contract_id_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_contract_id_arguments) */ {
 public:
  inline get_contract_id_arguments() : get_contract_id_arguments(nullptr) {}
  ~get_contract_id_arguments() override;
  explicit constexpr get_contract_id_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_contract_id_arguments(const get_contract_id_arguments& from);
  get_contract_id_arguments(get_contract_id_arguments&& from) noexcept
    : get_contract_id_arguments() {
    *this = ::std::move(from);
  }

  inline get_contract_id_arguments& operator=(const get_contract_id_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_contract_id_arguments& operator=(get_contract_id_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_contract_id_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_contract_id_arguments* internal_default_instance() {
    return reinterpret_cast<const get_contract_id_arguments*>(
               &_get_contract_id_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(get_contract_id_arguments& a, get_contract_id_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_contract_id_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_contract_id_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_contract_id_arguments* New() const final {
    return new get_contract_id_arguments();
  }

  get_contract_id_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_contract_id_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_contract_id_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_contract_id_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_contract_id_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_contract_id_arguments";
  }
  protected:
  explicit get_contract_id_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.get_contract_id_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_contract_id_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_contract_id_result) */ {
 public:
  inline get_contract_id_result() : get_contract_id_result(nullptr) {}
  ~get_contract_id_result() override;
  explicit constexpr get_contract_id_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_contract_id_result(const get_contract_id_result& from);
  get_contract_id_result(get_contract_id_result&& from) noexcept
    : get_contract_id_result() {
    *this = ::std::move(from);
  }

  inline get_contract_id_result& operator=(const get_contract_id_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_contract_id_result& operator=(get_contract_id_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_contract_id_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_contract_id_result* internal_default_instance() {
    return reinterpret_cast<const get_contract_id_result*>(
               &_get_contract_id_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(get_contract_id_result& a, get_contract_id_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_contract_id_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_contract_id_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_contract_id_result* New() const final {
    return new get_contract_id_result();
  }

  get_contract_id_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_contract_id_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_contract_id_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_contract_id_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_contract_id_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_contract_id_result";
  }
  protected:
  explicit get_contract_id_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1 [(.koinos.btype) = CONTRACT_ID];
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_contract_id_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_caller_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_caller_arguments) */ {
 public:
  inline get_caller_arguments() : get_caller_arguments(nullptr) {}
  ~get_caller_arguments() override;
  explicit constexpr get_caller_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_caller_arguments(const get_caller_arguments& from);
  get_caller_arguments(get_caller_arguments&& from) noexcept
    : get_caller_arguments() {
    *this = ::std::move(from);
  }

  inline get_caller_arguments& operator=(const get_caller_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_caller_arguments& operator=(get_caller_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_caller_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_caller_arguments* internal_default_instance() {
    return reinterpret_cast<const get_caller_arguments*>(
               &_get_caller_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(get_caller_arguments& a, get_caller_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_caller_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_caller_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_caller_arguments* New() const final {
    return new get_caller_arguments();
  }

  get_caller_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_caller_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_caller_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_caller_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_caller_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_caller_arguments";
  }
  protected:
  explicit get_caller_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.get_caller_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class get_caller_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_caller_result) */ {
 public:
  inline get_caller_result() : get_caller_result(nullptr) {}
  ~get_caller_result() override;
  explicit constexpr get_caller_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_caller_result(const get_caller_result& from);
  get_caller_result(get_caller_result&& from) noexcept
    : get_caller_result() {
    *this = ::std::move(from);
  }

  inline get_caller_result& operator=(const get_caller_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_caller_result& operator=(get_caller_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_caller_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_caller_result* internal_default_instance() {
    return reinterpret_cast<const get_caller_result*>(
               &_get_caller_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(get_caller_result& a, get_caller_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_caller_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_caller_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_caller_result* New() const final {
    return new get_caller_result();
  }

  get_caller_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_caller_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_caller_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_caller_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_caller_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_caller_result";
  }
  protected:
  explicit get_caller_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .koinos.chain.caller_data value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::koinos::chain::caller_data& value() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::caller_data* release_value();
  ::koinos::chain::caller_data* mutable_value();
  void set_allocated_value(::koinos::chain::caller_data* value);
  private:
  const ::koinos::chain::caller_data& _internal_value() const;
  ::koinos::chain::caller_data* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::koinos::chain::caller_data* value);
  ::koinos::chain::caller_data* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:koinos.chain.get_caller_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::chain::caller_data* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class check_authority_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.check_authority_arguments) */ {
 public:
  inline check_authority_arguments() : check_authority_arguments(nullptr) {}
  ~check_authority_arguments() override;
  explicit constexpr check_authority_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  check_authority_arguments(const check_authority_arguments& from);
  check_authority_arguments(check_authority_arguments&& from) noexcept
    : check_authority_arguments() {
    *this = ::std::move(from);
  }

  inline check_authority_arguments& operator=(const check_authority_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline check_authority_arguments& operator=(check_authority_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const check_authority_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const check_authority_arguments* internal_default_instance() {
    return reinterpret_cast<const check_authority_arguments*>(
               &_check_authority_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(check_authority_arguments& a, check_authority_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(check_authority_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(check_authority_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline check_authority_arguments* New() const final {
    return new check_authority_arguments();
  }

  check_authority_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<check_authority_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const check_authority_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const check_authority_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(check_authority_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.check_authority_arguments";
  }
  protected:
  explicit check_authority_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 2,
    kDataFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // bytes account = 2 [(.koinos.btype) = ADDRESS];
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_MUST_USE_RESULT std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .koinos.chain.authorization_type type = 1;
  void clear_type();
  ::koinos::chain::authorization_type type() const;
  void set_type(::koinos::chain::authorization_type value);
  private:
  ::koinos::chain::authorization_type _internal_type() const;
  void _internal_set_type(::koinos::chain::authorization_type value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.check_authority_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// -------------------------------------------------------------------

class check_authority_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.check_authority_result) */ {
 public:
  inline check_authority_result() : check_authority_result(nullptr) {}
  ~check_authority_result() override;
  explicit constexpr check_authority_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  check_authority_result(const check_authority_result& from);
  check_authority_result(check_authority_result&& from) noexcept
    : check_authority_result() {
    *this = ::std::move(from);
  }

  inline check_authority_result& operator=(const check_authority_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline check_authority_result& operator=(check_authority_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const check_authority_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const check_authority_result* internal_default_instance() {
    return reinterpret_cast<const check_authority_result*>(
               &_check_authority_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(check_authority_result& a, check_authority_result& b) {
    a.Swap(&b);
  }
  inline void Swap(check_authority_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(check_authority_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline check_authority_result* New() const final {
    return new check_authority_result();
  }

  check_authority_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<check_authority_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const check_authority_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const check_authority_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(check_authority_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.check_authority_result";
  }
  protected:
  explicit check_authority_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.check_authority_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fsystem_5fcalls_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// nop_arguments

// -------------------------------------------------------------------

// nop_result

// -------------------------------------------------------------------

// get_head_info_arguments

// -------------------------------------------------------------------

// get_head_info_result

// .koinos.chain.head_info value = 1;
inline bool get_head_info_result::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool get_head_info_result::has_value() const {
  return _internal_has_value();
}
inline const ::koinos::chain::head_info& get_head_info_result::_internal_value() const {
  const ::koinos::chain::head_info* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::head_info&>(
      ::koinos::chain::_head_info_default_instance_);
}
inline const ::koinos::chain::head_info& get_head_info_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_head_info_result.value)
  return _internal_value();
}
inline void get_head_info_result::unsafe_arena_set_allocated_value(
    ::koinos::chain::head_info* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_head_info_result.value)
}
inline ::koinos::chain::head_info* get_head_info_result::release_value() {
  
  ::koinos::chain::head_info* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::head_info* get_head_info_result::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_head_info_result.value)
  
  ::koinos::chain::head_info* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::koinos::chain::head_info* get_head_info_result::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::head_info>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::koinos::chain::head_info* get_head_info_result::mutable_value() {
  ::koinos::chain::head_info* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_head_info_result.value)
  return _msg;
}
inline void get_head_info_result::set_allocated_value(::koinos::chain::head_info* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_head_info_result.value)
}

// -------------------------------------------------------------------

// apply_block_arguments

// .koinos.protocol.block block = 1;
inline bool apply_block_arguments::_internal_has_block() const {
  return this != internal_default_instance() && block_ != nullptr;
}
inline bool apply_block_arguments::has_block() const {
  return _internal_has_block();
}
inline const ::koinos::protocol::block& apply_block_arguments::_internal_block() const {
  const ::koinos::protocol::block* p = block_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::protocol::block&>(
      ::koinos::protocol::_block_default_instance_);
}
inline const ::koinos::protocol::block& apply_block_arguments::block() const {
  // @@protoc_insertion_point(field_get:koinos.chain.apply_block_arguments.block)
  return _internal_block();
}
inline void apply_block_arguments::unsafe_arena_set_allocated_block(
    ::koinos::protocol::block* block) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_);
  }
  block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.apply_block_arguments.block)
}
inline ::koinos::protocol::block* apply_block_arguments::release_block() {
  
  ::koinos::protocol::block* temp = block_;
  block_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::protocol::block* apply_block_arguments::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:koinos.chain.apply_block_arguments.block)
  
  ::koinos::protocol::block* temp = block_;
  block_ = nullptr;
  return temp;
}
inline ::koinos::protocol::block* apply_block_arguments::_internal_mutable_block() {
  
  if (block_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::protocol::block>(GetArenaForAllocation());
    block_ = p;
  }
  return block_;
}
inline ::koinos::protocol::block* apply_block_arguments::mutable_block() {
  ::koinos::protocol::block* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:koinos.chain.apply_block_arguments.block)
  return _msg;
}
inline void apply_block_arguments::set_allocated_block(::koinos::protocol::block* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_);
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block));
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.apply_block_arguments.block)
}

// -------------------------------------------------------------------

// apply_block_result

// -------------------------------------------------------------------

// apply_transaction_arguments

// .koinos.protocol.transaction transaction = 1;
inline bool apply_transaction_arguments::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool apply_transaction_arguments::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::koinos::protocol::transaction& apply_transaction_arguments::_internal_transaction() const {
  const ::koinos::protocol::transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::protocol::transaction&>(
      ::koinos::protocol::_transaction_default_instance_);
}
inline const ::koinos::protocol::transaction& apply_transaction_arguments::transaction() const {
  // @@protoc_insertion_point(field_get:koinos.chain.apply_transaction_arguments.transaction)
  return _internal_transaction();
}
inline void apply_transaction_arguments::unsafe_arena_set_allocated_transaction(
    ::koinos::protocol::transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.apply_transaction_arguments.transaction)
}
inline ::koinos::protocol::transaction* apply_transaction_arguments::release_transaction() {
  
  ::koinos::protocol::transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::protocol::transaction* apply_transaction_arguments::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:koinos.chain.apply_transaction_arguments.transaction)
  
  ::koinos::protocol::transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::koinos::protocol::transaction* apply_transaction_arguments::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::protocol::transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::koinos::protocol::transaction* apply_transaction_arguments::mutable_transaction() {
  ::koinos::protocol::transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:koinos.chain.apply_transaction_arguments.transaction)
  return _msg;
}
inline void apply_transaction_arguments::set_allocated_transaction(::koinos::protocol::transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.apply_transaction_arguments.transaction)
}

// -------------------------------------------------------------------

// apply_transaction_result

// -------------------------------------------------------------------

// apply_upload_contract_operation_arguments

// .koinos.protocol.upload_contract_operation op = 1;
inline bool apply_upload_contract_operation_arguments::_internal_has_op() const {
  return this != internal_default_instance() && op_ != nullptr;
}
inline bool apply_upload_contract_operation_arguments::has_op() const {
  return _internal_has_op();
}
inline const ::koinos::protocol::upload_contract_operation& apply_upload_contract_operation_arguments::_internal_op() const {
  const ::koinos::protocol::upload_contract_operation* p = op_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::protocol::upload_contract_operation&>(
      ::koinos::protocol::_upload_contract_operation_default_instance_);
}
inline const ::koinos::protocol::upload_contract_operation& apply_upload_contract_operation_arguments::op() const {
  // @@protoc_insertion_point(field_get:koinos.chain.apply_upload_contract_operation_arguments.op)
  return _internal_op();
}
inline void apply_upload_contract_operation_arguments::unsafe_arena_set_allocated_op(
    ::koinos::protocol::upload_contract_operation* op) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(op_);
  }
  op_ = op;
  if (op) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.apply_upload_contract_operation_arguments.op)
}
inline ::koinos::protocol::upload_contract_operation* apply_upload_contract_operation_arguments::release_op() {
  
  ::koinos::protocol::upload_contract_operation* temp = op_;
  op_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::protocol::upload_contract_operation* apply_upload_contract_operation_arguments::unsafe_arena_release_op() {
  // @@protoc_insertion_point(field_release:koinos.chain.apply_upload_contract_operation_arguments.op)
  
  ::koinos::protocol::upload_contract_operation* temp = op_;
  op_ = nullptr;
  return temp;
}
inline ::koinos::protocol::upload_contract_operation* apply_upload_contract_operation_arguments::_internal_mutable_op() {
  
  if (op_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::protocol::upload_contract_operation>(GetArenaForAllocation());
    op_ = p;
  }
  return op_;
}
inline ::koinos::protocol::upload_contract_operation* apply_upload_contract_operation_arguments::mutable_op() {
  ::koinos::protocol::upload_contract_operation* _msg = _internal_mutable_op();
  // @@protoc_insertion_point(field_mutable:koinos.chain.apply_upload_contract_operation_arguments.op)
  return _msg;
}
inline void apply_upload_contract_operation_arguments::set_allocated_op(::koinos::protocol::upload_contract_operation* op) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(op_);
  }
  if (op) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(op));
    if (message_arena != submessage_arena) {
      op = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, op, submessage_arena);
    }
    
  } else {
    
  }
  op_ = op;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.apply_upload_contract_operation_arguments.op)
}

// -------------------------------------------------------------------

// apply_upload_contract_operation_result

// -------------------------------------------------------------------

// apply_call_contract_operation_arguments

// .koinos.protocol.call_contract_operation op = 1;
inline bool apply_call_contract_operation_arguments::_internal_has_op() const {
  return this != internal_default_instance() && op_ != nullptr;
}
inline bool apply_call_contract_operation_arguments::has_op() const {
  return _internal_has_op();
}
inline const ::koinos::protocol::call_contract_operation& apply_call_contract_operation_arguments::_internal_op() const {
  const ::koinos::protocol::call_contract_operation* p = op_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::protocol::call_contract_operation&>(
      ::koinos::protocol::_call_contract_operation_default_instance_);
}
inline const ::koinos::protocol::call_contract_operation& apply_call_contract_operation_arguments::op() const {
  // @@protoc_insertion_point(field_get:koinos.chain.apply_call_contract_operation_arguments.op)
  return _internal_op();
}
inline void apply_call_contract_operation_arguments::unsafe_arena_set_allocated_op(
    ::koinos::protocol::call_contract_operation* op) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(op_);
  }
  op_ = op;
  if (op) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.apply_call_contract_operation_arguments.op)
}
inline ::koinos::protocol::call_contract_operation* apply_call_contract_operation_arguments::release_op() {
  
  ::koinos::protocol::call_contract_operation* temp = op_;
  op_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::protocol::call_contract_operation* apply_call_contract_operation_arguments::unsafe_arena_release_op() {
  // @@protoc_insertion_point(field_release:koinos.chain.apply_call_contract_operation_arguments.op)
  
  ::koinos::protocol::call_contract_operation* temp = op_;
  op_ = nullptr;
  return temp;
}
inline ::koinos::protocol::call_contract_operation* apply_call_contract_operation_arguments::_internal_mutable_op() {
  
  if (op_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::protocol::call_contract_operation>(GetArenaForAllocation());
    op_ = p;
  }
  return op_;
}
inline ::koinos::protocol::call_contract_operation* apply_call_contract_operation_arguments::mutable_op() {
  ::koinos::protocol::call_contract_operation* _msg = _internal_mutable_op();
  // @@protoc_insertion_point(field_mutable:koinos.chain.apply_call_contract_operation_arguments.op)
  return _msg;
}
inline void apply_call_contract_operation_arguments::set_allocated_op(::koinos::protocol::call_contract_operation* op) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(op_);
  }
  if (op) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(op));
    if (message_arena != submessage_arena) {
      op = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, op, submessage_arena);
    }
    
  } else {
    
  }
  op_ = op;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.apply_call_contract_operation_arguments.op)
}

// -------------------------------------------------------------------

// apply_call_contract_operation_result

// -------------------------------------------------------------------

// apply_set_system_call_operation_arguments

// .koinos.protocol.set_system_call_operation op = 1;
inline bool apply_set_system_call_operation_arguments::_internal_has_op() const {
  return this != internal_default_instance() && op_ != nullptr;
}
inline bool apply_set_system_call_operation_arguments::has_op() const {
  return _internal_has_op();
}
inline const ::koinos::protocol::set_system_call_operation& apply_set_system_call_operation_arguments::_internal_op() const {
  const ::koinos::protocol::set_system_call_operation* p = op_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::protocol::set_system_call_operation&>(
      ::koinos::protocol::_set_system_call_operation_default_instance_);
}
inline const ::koinos::protocol::set_system_call_operation& apply_set_system_call_operation_arguments::op() const {
  // @@protoc_insertion_point(field_get:koinos.chain.apply_set_system_call_operation_arguments.op)
  return _internal_op();
}
inline void apply_set_system_call_operation_arguments::unsafe_arena_set_allocated_op(
    ::koinos::protocol::set_system_call_operation* op) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(op_);
  }
  op_ = op;
  if (op) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.apply_set_system_call_operation_arguments.op)
}
inline ::koinos::protocol::set_system_call_operation* apply_set_system_call_operation_arguments::release_op() {
  
  ::koinos::protocol::set_system_call_operation* temp = op_;
  op_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::protocol::set_system_call_operation* apply_set_system_call_operation_arguments::unsafe_arena_release_op() {
  // @@protoc_insertion_point(field_release:koinos.chain.apply_set_system_call_operation_arguments.op)
  
  ::koinos::protocol::set_system_call_operation* temp = op_;
  op_ = nullptr;
  return temp;
}
inline ::koinos::protocol::set_system_call_operation* apply_set_system_call_operation_arguments::_internal_mutable_op() {
  
  if (op_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::protocol::set_system_call_operation>(GetArenaForAllocation());
    op_ = p;
  }
  return op_;
}
inline ::koinos::protocol::set_system_call_operation* apply_set_system_call_operation_arguments::mutable_op() {
  ::koinos::protocol::set_system_call_operation* _msg = _internal_mutable_op();
  // @@protoc_insertion_point(field_mutable:koinos.chain.apply_set_system_call_operation_arguments.op)
  return _msg;
}
inline void apply_set_system_call_operation_arguments::set_allocated_op(::koinos::protocol::set_system_call_operation* op) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(op_);
  }
  if (op) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(op));
    if (message_arena != submessage_arena) {
      op = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, op, submessage_arena);
    }
    
  } else {
    
  }
  op_ = op;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.apply_set_system_call_operation_arguments.op)
}

// -------------------------------------------------------------------

// apply_set_system_call_operation_result

// -------------------------------------------------------------------

// apply_set_system_contract_operation_arguments

// .koinos.protocol.set_system_contract_operation op = 1;
inline bool apply_set_system_contract_operation_arguments::_internal_has_op() const {
  return this != internal_default_instance() && op_ != nullptr;
}
inline bool apply_set_system_contract_operation_arguments::has_op() const {
  return _internal_has_op();
}
inline const ::koinos::protocol::set_system_contract_operation& apply_set_system_contract_operation_arguments::_internal_op() const {
  const ::koinos::protocol::set_system_contract_operation* p = op_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::protocol::set_system_contract_operation&>(
      ::koinos::protocol::_set_system_contract_operation_default_instance_);
}
inline const ::koinos::protocol::set_system_contract_operation& apply_set_system_contract_operation_arguments::op() const {
  // @@protoc_insertion_point(field_get:koinos.chain.apply_set_system_contract_operation_arguments.op)
  return _internal_op();
}
inline void apply_set_system_contract_operation_arguments::unsafe_arena_set_allocated_op(
    ::koinos::protocol::set_system_contract_operation* op) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(op_);
  }
  op_ = op;
  if (op) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.apply_set_system_contract_operation_arguments.op)
}
inline ::koinos::protocol::set_system_contract_operation* apply_set_system_contract_operation_arguments::release_op() {
  
  ::koinos::protocol::set_system_contract_operation* temp = op_;
  op_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::protocol::set_system_contract_operation* apply_set_system_contract_operation_arguments::unsafe_arena_release_op() {
  // @@protoc_insertion_point(field_release:koinos.chain.apply_set_system_contract_operation_arguments.op)
  
  ::koinos::protocol::set_system_contract_operation* temp = op_;
  op_ = nullptr;
  return temp;
}
inline ::koinos::protocol::set_system_contract_operation* apply_set_system_contract_operation_arguments::_internal_mutable_op() {
  
  if (op_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::protocol::set_system_contract_operation>(GetArenaForAllocation());
    op_ = p;
  }
  return op_;
}
inline ::koinos::protocol::set_system_contract_operation* apply_set_system_contract_operation_arguments::mutable_op() {
  ::koinos::protocol::set_system_contract_operation* _msg = _internal_mutable_op();
  // @@protoc_insertion_point(field_mutable:koinos.chain.apply_set_system_contract_operation_arguments.op)
  return _msg;
}
inline void apply_set_system_contract_operation_arguments::set_allocated_op(::koinos::protocol::set_system_contract_operation* op) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(op_);
  }
  if (op) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(op));
    if (message_arena != submessage_arena) {
      op = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, op, submessage_arena);
    }
    
  } else {
    
  }
  op_ = op;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.apply_set_system_contract_operation_arguments.op)
}

// -------------------------------------------------------------------

// apply_set_system_contract_operation_result

// -------------------------------------------------------------------

// pre_block_callback_arguments

// -------------------------------------------------------------------

// pre_block_callback_result

// -------------------------------------------------------------------

// post_block_callback_arguments

// -------------------------------------------------------------------

// post_block_callback_result

// -------------------------------------------------------------------

// pre_transaction_callback_arguments

// -------------------------------------------------------------------

// pre_transaction_callback_result

// -------------------------------------------------------------------

// post_transaction_callback_arguments

// -------------------------------------------------------------------

// post_transaction_callback_result

// -------------------------------------------------------------------

// get_chain_id_arguments

// -------------------------------------------------------------------

// get_chain_id_result

// bytes value = 1;
inline void get_chain_id_result::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& get_chain_id_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_chain_id_result.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_chain_id_result::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_chain_id_result.value)
}
inline std::string* get_chain_id_result::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_chain_id_result.value)
  return _s;
}
inline const std::string& get_chain_id_result::_internal_value() const {
  return value_.Get();
}
inline void get_chain_id_result::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_chain_id_result::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_chain_id_result::release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_chain_id_result.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_chain_id_result::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_chain_id_result.value)
}

// -------------------------------------------------------------------

// process_block_signature_arguments

// bytes digest = 1;
inline void process_block_signature_arguments::clear_digest() {
  digest_.ClearToEmpty();
}
inline const std::string& process_block_signature_arguments::digest() const {
  // @@protoc_insertion_point(field_get:koinos.chain.process_block_signature_arguments.digest)
  return _internal_digest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void process_block_signature_arguments::set_digest(ArgT0&& arg0, ArgT... args) {
 
 digest_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.process_block_signature_arguments.digest)
}
inline std::string* process_block_signature_arguments::mutable_digest() {
  std::string* _s = _internal_mutable_digest();
  // @@protoc_insertion_point(field_mutable:koinos.chain.process_block_signature_arguments.digest)
  return _s;
}
inline const std::string& process_block_signature_arguments::_internal_digest() const {
  return digest_.Get();
}
inline void process_block_signature_arguments::_internal_set_digest(const std::string& value) {
  
  digest_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* process_block_signature_arguments::_internal_mutable_digest() {
  
  return digest_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* process_block_signature_arguments::release_digest() {
  // @@protoc_insertion_point(field_release:koinos.chain.process_block_signature_arguments.digest)
  return digest_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void process_block_signature_arguments::set_allocated_digest(std::string* digest) {
  if (digest != nullptr) {
    
  } else {
    
  }
  digest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), digest,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.process_block_signature_arguments.digest)
}

// .koinos.protocol.block_header header = 2;
inline bool process_block_signature_arguments::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool process_block_signature_arguments::has_header() const {
  return _internal_has_header();
}
inline const ::koinos::protocol::block_header& process_block_signature_arguments::_internal_header() const {
  const ::koinos::protocol::block_header* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::protocol::block_header&>(
      ::koinos::protocol::_block_header_default_instance_);
}
inline const ::koinos::protocol::block_header& process_block_signature_arguments::header() const {
  // @@protoc_insertion_point(field_get:koinos.chain.process_block_signature_arguments.header)
  return _internal_header();
}
inline void process_block_signature_arguments::unsafe_arena_set_allocated_header(
    ::koinos::protocol::block_header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.process_block_signature_arguments.header)
}
inline ::koinos::protocol::block_header* process_block_signature_arguments::release_header() {
  
  ::koinos::protocol::block_header* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::protocol::block_header* process_block_signature_arguments::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:koinos.chain.process_block_signature_arguments.header)
  
  ::koinos::protocol::block_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::koinos::protocol::block_header* process_block_signature_arguments::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::protocol::block_header>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::koinos::protocol::block_header* process_block_signature_arguments::mutable_header() {
  ::koinos::protocol::block_header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:koinos.chain.process_block_signature_arguments.header)
  return _msg;
}
inline void process_block_signature_arguments::set_allocated_header(::koinos::protocol::block_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.process_block_signature_arguments.header)
}

// bytes signature = 3;
inline void process_block_signature_arguments::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& process_block_signature_arguments::signature() const {
  // @@protoc_insertion_point(field_get:koinos.chain.process_block_signature_arguments.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void process_block_signature_arguments::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.process_block_signature_arguments.signature)
}
inline std::string* process_block_signature_arguments::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:koinos.chain.process_block_signature_arguments.signature)
  return _s;
}
inline const std::string& process_block_signature_arguments::_internal_signature() const {
  return signature_.Get();
}
inline void process_block_signature_arguments::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* process_block_signature_arguments::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* process_block_signature_arguments::release_signature() {
  // @@protoc_insertion_point(field_release:koinos.chain.process_block_signature_arguments.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void process_block_signature_arguments::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.process_block_signature_arguments.signature)
}

// -------------------------------------------------------------------

// process_block_signature_result

// bool value = 1;
inline void process_block_signature_result::clear_value() {
  value_ = false;
}
inline bool process_block_signature_result::_internal_value() const {
  return value_;
}
inline bool process_block_signature_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.process_block_signature_result.value)
  return _internal_value();
}
inline void process_block_signature_result::_internal_set_value(bool value) {
  
  value_ = value;
}
inline void process_block_signature_result::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.process_block_signature_result.value)
}

// -------------------------------------------------------------------

// get_transaction_arguments

// -------------------------------------------------------------------

// get_transaction_result

// .koinos.protocol.transaction value = 1;
inline bool get_transaction_result::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool get_transaction_result::has_value() const {
  return _internal_has_value();
}
inline const ::koinos::protocol::transaction& get_transaction_result::_internal_value() const {
  const ::koinos::protocol::transaction* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::protocol::transaction&>(
      ::koinos::protocol::_transaction_default_instance_);
}
inline const ::koinos::protocol::transaction& get_transaction_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_transaction_result.value)
  return _internal_value();
}
inline void get_transaction_result::unsafe_arena_set_allocated_value(
    ::koinos::protocol::transaction* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_transaction_result.value)
}
inline ::koinos::protocol::transaction* get_transaction_result::release_value() {
  
  ::koinos::protocol::transaction* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::protocol::transaction* get_transaction_result::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_transaction_result.value)
  
  ::koinos::protocol::transaction* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::koinos::protocol::transaction* get_transaction_result::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::protocol::transaction>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::koinos::protocol::transaction* get_transaction_result::mutable_value() {
  ::koinos::protocol::transaction* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_transaction_result.value)
  return _msg;
}
inline void get_transaction_result::set_allocated_value(::koinos::protocol::transaction* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_transaction_result.value)
}

// -------------------------------------------------------------------

// get_transaction_field_arguments

// string field = 1;
inline void get_transaction_field_arguments::clear_field() {
  field_.ClearToEmpty();
}
inline const std::string& get_transaction_field_arguments::field() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_transaction_field_arguments.field)
  return _internal_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_transaction_field_arguments::set_field(ArgT0&& arg0, ArgT... args) {
 
 field_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_transaction_field_arguments.field)
}
inline std::string* get_transaction_field_arguments::mutable_field() {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_transaction_field_arguments.field)
  return _s;
}
inline const std::string& get_transaction_field_arguments::_internal_field() const {
  return field_.Get();
}
inline void get_transaction_field_arguments::_internal_set_field(const std::string& value) {
  
  field_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_transaction_field_arguments::_internal_mutable_field() {
  
  return field_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_transaction_field_arguments::release_field() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_transaction_field_arguments.field)
  return field_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_transaction_field_arguments::set_allocated_field(std::string* field) {
  if (field != nullptr) {
    
  } else {
    
  }
  field_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), field,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_transaction_field_arguments.field)
}

// -------------------------------------------------------------------

// get_transaction_field_result

// .koinos.chain.value_type value = 1;
inline bool get_transaction_field_result::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool get_transaction_field_result::has_value() const {
  return _internal_has_value();
}
inline const ::koinos::chain::value_type& get_transaction_field_result::_internal_value() const {
  const ::koinos::chain::value_type* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::value_type&>(
      ::koinos::chain::_value_type_default_instance_);
}
inline const ::koinos::chain::value_type& get_transaction_field_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_transaction_field_result.value)
  return _internal_value();
}
inline void get_transaction_field_result::unsafe_arena_set_allocated_value(
    ::koinos::chain::value_type* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_transaction_field_result.value)
}
inline ::koinos::chain::value_type* get_transaction_field_result::release_value() {
  
  ::koinos::chain::value_type* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::value_type* get_transaction_field_result::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_transaction_field_result.value)
  
  ::koinos::chain::value_type* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::koinos::chain::value_type* get_transaction_field_result::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::value_type>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::koinos::chain::value_type* get_transaction_field_result::mutable_value() {
  ::koinos::chain::value_type* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_transaction_field_result.value)
  return _msg;
}
inline void get_transaction_field_result::set_allocated_value(::koinos::chain::value_type* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_transaction_field_result.value)
}

// -------------------------------------------------------------------

// get_block_arguments

// -------------------------------------------------------------------

// get_block_result

// .koinos.protocol.block value = 1;
inline bool get_block_result::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool get_block_result::has_value() const {
  return _internal_has_value();
}
inline const ::koinos::protocol::block& get_block_result::_internal_value() const {
  const ::koinos::protocol::block* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::protocol::block&>(
      ::koinos::protocol::_block_default_instance_);
}
inline const ::koinos::protocol::block& get_block_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_block_result.value)
  return _internal_value();
}
inline void get_block_result::unsafe_arena_set_allocated_value(
    ::koinos::protocol::block* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_block_result.value)
}
inline ::koinos::protocol::block* get_block_result::release_value() {
  
  ::koinos::protocol::block* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::protocol::block* get_block_result::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_block_result.value)
  
  ::koinos::protocol::block* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::koinos::protocol::block* get_block_result::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::protocol::block>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::koinos::protocol::block* get_block_result::mutable_value() {
  ::koinos::protocol::block* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_block_result.value)
  return _msg;
}
inline void get_block_result::set_allocated_value(::koinos::protocol::block* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_block_result.value)
}

// -------------------------------------------------------------------

// get_block_field_arguments

// string field = 1;
inline void get_block_field_arguments::clear_field() {
  field_.ClearToEmpty();
}
inline const std::string& get_block_field_arguments::field() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_block_field_arguments.field)
  return _internal_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_block_field_arguments::set_field(ArgT0&& arg0, ArgT... args) {
 
 field_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_block_field_arguments.field)
}
inline std::string* get_block_field_arguments::mutable_field() {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_block_field_arguments.field)
  return _s;
}
inline const std::string& get_block_field_arguments::_internal_field() const {
  return field_.Get();
}
inline void get_block_field_arguments::_internal_set_field(const std::string& value) {
  
  field_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_block_field_arguments::_internal_mutable_field() {
  
  return field_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_block_field_arguments::release_field() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_block_field_arguments.field)
  return field_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_block_field_arguments::set_allocated_field(std::string* field) {
  if (field != nullptr) {
    
  } else {
    
  }
  field_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), field,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_block_field_arguments.field)
}

// -------------------------------------------------------------------

// get_block_field_result

// .koinos.chain.value_type value = 1;
inline bool get_block_field_result::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool get_block_field_result::has_value() const {
  return _internal_has_value();
}
inline const ::koinos::chain::value_type& get_block_field_result::_internal_value() const {
  const ::koinos::chain::value_type* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::value_type&>(
      ::koinos::chain::_value_type_default_instance_);
}
inline const ::koinos::chain::value_type& get_block_field_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_block_field_result.value)
  return _internal_value();
}
inline void get_block_field_result::unsafe_arena_set_allocated_value(
    ::koinos::chain::value_type* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_block_field_result.value)
}
inline ::koinos::chain::value_type* get_block_field_result::release_value() {
  
  ::koinos::chain::value_type* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::value_type* get_block_field_result::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_block_field_result.value)
  
  ::koinos::chain::value_type* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::koinos::chain::value_type* get_block_field_result::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::value_type>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::koinos::chain::value_type* get_block_field_result::mutable_value() {
  ::koinos::chain::value_type* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_block_field_result.value)
  return _msg;
}
inline void get_block_field_result::set_allocated_value(::koinos::chain::value_type* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_block_field_result.value)
}

// -------------------------------------------------------------------

// get_last_irreversible_block_arguments

// -------------------------------------------------------------------

// get_last_irreversible_block_result

// uint64 value = 1 [jstype = JS_STRING];
inline void get_last_irreversible_block_result::clear_value() {
  value_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 get_last_irreversible_block_result::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 get_last_irreversible_block_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_last_irreversible_block_result.value)
  return _internal_value();
}
inline void get_last_irreversible_block_result::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  value_ = value;
}
inline void get_last_irreversible_block_result::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.get_last_irreversible_block_result.value)
}

// -------------------------------------------------------------------

// get_account_nonce_arguments

// bytes account = 1 [(.koinos.btype) = ADDRESS];
inline void get_account_nonce_arguments::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& get_account_nonce_arguments::account() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_account_nonce_arguments.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_account_nonce_arguments::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_account_nonce_arguments.account)
}
inline std::string* get_account_nonce_arguments::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_account_nonce_arguments.account)
  return _s;
}
inline const std::string& get_account_nonce_arguments::_internal_account() const {
  return account_.Get();
}
inline void get_account_nonce_arguments::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_account_nonce_arguments::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_account_nonce_arguments::release_account() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_account_nonce_arguments.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_account_nonce_arguments::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_account_nonce_arguments.account)
}

// -------------------------------------------------------------------

// get_account_nonce_result

// bytes value = 1;
inline void get_account_nonce_result::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& get_account_nonce_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_account_nonce_result.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_account_nonce_result::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_account_nonce_result.value)
}
inline std::string* get_account_nonce_result::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_account_nonce_result.value)
  return _s;
}
inline const std::string& get_account_nonce_result::_internal_value() const {
  return value_.Get();
}
inline void get_account_nonce_result::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_account_nonce_result::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_account_nonce_result::release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_account_nonce_result.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_account_nonce_result::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_account_nonce_result.value)
}

// -------------------------------------------------------------------

// verify_account_nonce_arguments

// bytes account = 1 [(.koinos.btype) = ADDRESS];
inline void verify_account_nonce_arguments::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& verify_account_nonce_arguments::account() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_account_nonce_arguments.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void verify_account_nonce_arguments::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.verify_account_nonce_arguments.account)
}
inline std::string* verify_account_nonce_arguments::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:koinos.chain.verify_account_nonce_arguments.account)
  return _s;
}
inline const std::string& verify_account_nonce_arguments::_internal_account() const {
  return account_.Get();
}
inline void verify_account_nonce_arguments::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* verify_account_nonce_arguments::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* verify_account_nonce_arguments::release_account() {
  // @@protoc_insertion_point(field_release:koinos.chain.verify_account_nonce_arguments.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void verify_account_nonce_arguments::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.verify_account_nonce_arguments.account)
}

// bytes nonce = 2;
inline void verify_account_nonce_arguments::clear_nonce() {
  nonce_.ClearToEmpty();
}
inline const std::string& verify_account_nonce_arguments::nonce() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_account_nonce_arguments.nonce)
  return _internal_nonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void verify_account_nonce_arguments::set_nonce(ArgT0&& arg0, ArgT... args) {
 
 nonce_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.verify_account_nonce_arguments.nonce)
}
inline std::string* verify_account_nonce_arguments::mutable_nonce() {
  std::string* _s = _internal_mutable_nonce();
  // @@protoc_insertion_point(field_mutable:koinos.chain.verify_account_nonce_arguments.nonce)
  return _s;
}
inline const std::string& verify_account_nonce_arguments::_internal_nonce() const {
  return nonce_.Get();
}
inline void verify_account_nonce_arguments::_internal_set_nonce(const std::string& value) {
  
  nonce_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* verify_account_nonce_arguments::_internal_mutable_nonce() {
  
  return nonce_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* verify_account_nonce_arguments::release_nonce() {
  // @@protoc_insertion_point(field_release:koinos.chain.verify_account_nonce_arguments.nonce)
  return nonce_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void verify_account_nonce_arguments::set_allocated_nonce(std::string* nonce) {
  if (nonce != nullptr) {
    
  } else {
    
  }
  nonce_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nonce,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.verify_account_nonce_arguments.nonce)
}

// -------------------------------------------------------------------

// verify_account_nonce_result

// bool value = 1;
inline void verify_account_nonce_result::clear_value() {
  value_ = false;
}
inline bool verify_account_nonce_result::_internal_value() const {
  return value_;
}
inline bool verify_account_nonce_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_account_nonce_result.value)
  return _internal_value();
}
inline void verify_account_nonce_result::_internal_set_value(bool value) {
  
  value_ = value;
}
inline void verify_account_nonce_result::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.verify_account_nonce_result.value)
}

// -------------------------------------------------------------------

// set_account_nonce_arguments

// bytes account = 1 [(.koinos.btype) = ADDRESS];
inline void set_account_nonce_arguments::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& set_account_nonce_arguments::account() const {
  // @@protoc_insertion_point(field_get:koinos.chain.set_account_nonce_arguments.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void set_account_nonce_arguments::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.set_account_nonce_arguments.account)
}
inline std::string* set_account_nonce_arguments::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:koinos.chain.set_account_nonce_arguments.account)
  return _s;
}
inline const std::string& set_account_nonce_arguments::_internal_account() const {
  return account_.Get();
}
inline void set_account_nonce_arguments::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* set_account_nonce_arguments::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* set_account_nonce_arguments::release_account() {
  // @@protoc_insertion_point(field_release:koinos.chain.set_account_nonce_arguments.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void set_account_nonce_arguments::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.set_account_nonce_arguments.account)
}

// bytes nonce = 2;
inline void set_account_nonce_arguments::clear_nonce() {
  nonce_.ClearToEmpty();
}
inline const std::string& set_account_nonce_arguments::nonce() const {
  // @@protoc_insertion_point(field_get:koinos.chain.set_account_nonce_arguments.nonce)
  return _internal_nonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void set_account_nonce_arguments::set_nonce(ArgT0&& arg0, ArgT... args) {
 
 nonce_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.set_account_nonce_arguments.nonce)
}
inline std::string* set_account_nonce_arguments::mutable_nonce() {
  std::string* _s = _internal_mutable_nonce();
  // @@protoc_insertion_point(field_mutable:koinos.chain.set_account_nonce_arguments.nonce)
  return _s;
}
inline const std::string& set_account_nonce_arguments::_internal_nonce() const {
  return nonce_.Get();
}
inline void set_account_nonce_arguments::_internal_set_nonce(const std::string& value) {
  
  nonce_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* set_account_nonce_arguments::_internal_mutable_nonce() {
  
  return nonce_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* set_account_nonce_arguments::release_nonce() {
  // @@protoc_insertion_point(field_release:koinos.chain.set_account_nonce_arguments.nonce)
  return nonce_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void set_account_nonce_arguments::set_allocated_nonce(std::string* nonce) {
  if (nonce != nullptr) {
    
  } else {
    
  }
  nonce_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nonce,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.set_account_nonce_arguments.nonce)
}

// -------------------------------------------------------------------

// set_account_nonce_result

// -------------------------------------------------------------------

// check_system_authority_arguments

// .koinos.chain.system_authorization_type type = 1;
inline void check_system_authority_arguments::clear_type() {
  type_ = 0;
}
inline ::koinos::chain::system_authorization_type check_system_authority_arguments::_internal_type() const {
  return static_cast< ::koinos::chain::system_authorization_type >(type_);
}
inline ::koinos::chain::system_authorization_type check_system_authority_arguments::type() const {
  // @@protoc_insertion_point(field_get:koinos.chain.check_system_authority_arguments.type)
  return _internal_type();
}
inline void check_system_authority_arguments::_internal_set_type(::koinos::chain::system_authorization_type value) {
  
  type_ = value;
}
inline void check_system_authority_arguments::set_type(::koinos::chain::system_authorization_type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:koinos.chain.check_system_authority_arguments.type)
}

// -------------------------------------------------------------------

// check_system_authority_result

// bool value = 1;
inline void check_system_authority_result::clear_value() {
  value_ = false;
}
inline bool check_system_authority_result::_internal_value() const {
  return value_;
}
inline bool check_system_authority_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.check_system_authority_result.value)
  return _internal_value();
}
inline void check_system_authority_result::_internal_set_value(bool value) {
  
  value_ = value;
}
inline void check_system_authority_result::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.check_system_authority_result.value)
}

// -------------------------------------------------------------------

// get_operation_arguments

// -------------------------------------------------------------------

// get_operation_result

// .koinos.protocol.operation value = 1;
inline bool get_operation_result::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool get_operation_result::has_value() const {
  return _internal_has_value();
}
inline const ::koinos::protocol::operation& get_operation_result::_internal_value() const {
  const ::koinos::protocol::operation* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::protocol::operation&>(
      ::koinos::protocol::_operation_default_instance_);
}
inline const ::koinos::protocol::operation& get_operation_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_operation_result.value)
  return _internal_value();
}
inline void get_operation_result::unsafe_arena_set_allocated_value(
    ::koinos::protocol::operation* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_operation_result.value)
}
inline ::koinos::protocol::operation* get_operation_result::release_value() {
  
  ::koinos::protocol::operation* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::protocol::operation* get_operation_result::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_operation_result.value)
  
  ::koinos::protocol::operation* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::koinos::protocol::operation* get_operation_result::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::protocol::operation>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::koinos::protocol::operation* get_operation_result::mutable_value() {
  ::koinos::protocol::operation* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_operation_result.value)
  return _msg;
}
inline void get_operation_result::set_allocated_value(::koinos::protocol::operation* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_operation_result.value)
}

// -------------------------------------------------------------------

// get_account_rc_arguments

// bytes account = 1 [(.koinos.btype) = ADDRESS];
inline void get_account_rc_arguments::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& get_account_rc_arguments::account() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_account_rc_arguments.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_account_rc_arguments::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_account_rc_arguments.account)
}
inline std::string* get_account_rc_arguments::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_account_rc_arguments.account)
  return _s;
}
inline const std::string& get_account_rc_arguments::_internal_account() const {
  return account_.Get();
}
inline void get_account_rc_arguments::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_account_rc_arguments::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_account_rc_arguments::release_account() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_account_rc_arguments.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_account_rc_arguments::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_account_rc_arguments.account)
}

// -------------------------------------------------------------------

// get_account_rc_result

// uint64 value = 1 [jstype = JS_STRING];
inline void get_account_rc_result::clear_value() {
  value_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 get_account_rc_result::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 get_account_rc_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_account_rc_result.value)
  return _internal_value();
}
inline void get_account_rc_result::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  value_ = value;
}
inline void get_account_rc_result::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.get_account_rc_result.value)
}

// -------------------------------------------------------------------

// consume_account_rc_arguments

// bytes account = 1 [(.koinos.btype) = ADDRESS];
inline void consume_account_rc_arguments::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& consume_account_rc_arguments::account() const {
  // @@protoc_insertion_point(field_get:koinos.chain.consume_account_rc_arguments.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void consume_account_rc_arguments::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.consume_account_rc_arguments.account)
}
inline std::string* consume_account_rc_arguments::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:koinos.chain.consume_account_rc_arguments.account)
  return _s;
}
inline const std::string& consume_account_rc_arguments::_internal_account() const {
  return account_.Get();
}
inline void consume_account_rc_arguments::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* consume_account_rc_arguments::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* consume_account_rc_arguments::release_account() {
  // @@protoc_insertion_point(field_release:koinos.chain.consume_account_rc_arguments.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void consume_account_rc_arguments::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.consume_account_rc_arguments.account)
}

// uint64 value = 2 [jstype = JS_STRING];
inline void consume_account_rc_arguments::clear_value() {
  value_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 consume_account_rc_arguments::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 consume_account_rc_arguments::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.consume_account_rc_arguments.value)
  return _internal_value();
}
inline void consume_account_rc_arguments::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  value_ = value;
}
inline void consume_account_rc_arguments::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.consume_account_rc_arguments.value)
}

// -------------------------------------------------------------------

// consume_account_rc_result

// bool value = 1;
inline void consume_account_rc_result::clear_value() {
  value_ = false;
}
inline bool consume_account_rc_result::_internal_value() const {
  return value_;
}
inline bool consume_account_rc_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.consume_account_rc_result.value)
  return _internal_value();
}
inline void consume_account_rc_result::_internal_set_value(bool value) {
  
  value_ = value;
}
inline void consume_account_rc_result::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.consume_account_rc_result.value)
}

// -------------------------------------------------------------------

// get_resource_limits_arguments

// -------------------------------------------------------------------

// get_resource_limits_result

// .koinos.chain.resource_limit_data value = 1;
inline bool get_resource_limits_result::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool get_resource_limits_result::has_value() const {
  return _internal_has_value();
}
inline const ::koinos::chain::resource_limit_data& get_resource_limits_result::_internal_value() const {
  const ::koinos::chain::resource_limit_data* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::resource_limit_data&>(
      ::koinos::chain::_resource_limit_data_default_instance_);
}
inline const ::koinos::chain::resource_limit_data& get_resource_limits_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_resource_limits_result.value)
  return _internal_value();
}
inline void get_resource_limits_result::unsafe_arena_set_allocated_value(
    ::koinos::chain::resource_limit_data* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_resource_limits_result.value)
}
inline ::koinos::chain::resource_limit_data* get_resource_limits_result::release_value() {
  
  ::koinos::chain::resource_limit_data* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::resource_limit_data* get_resource_limits_result::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_resource_limits_result.value)
  
  ::koinos::chain::resource_limit_data* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::koinos::chain::resource_limit_data* get_resource_limits_result::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::resource_limit_data>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::koinos::chain::resource_limit_data* get_resource_limits_result::mutable_value() {
  ::koinos::chain::resource_limit_data* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_resource_limits_result.value)
  return _msg;
}
inline void get_resource_limits_result::set_allocated_value(::koinos::chain::resource_limit_data* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_resource_limits_result.value)
}

// -------------------------------------------------------------------

// consume_block_resources_arguments

// uint64 disk_storage_consumed = 1 [jstype = JS_STRING];
inline void consume_block_resources_arguments::clear_disk_storage_consumed() {
  disk_storage_consumed_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 consume_block_resources_arguments::_internal_disk_storage_consumed() const {
  return disk_storage_consumed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 consume_block_resources_arguments::disk_storage_consumed() const {
  // @@protoc_insertion_point(field_get:koinos.chain.consume_block_resources_arguments.disk_storage_consumed)
  return _internal_disk_storage_consumed();
}
inline void consume_block_resources_arguments::_internal_set_disk_storage_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  disk_storage_consumed_ = value;
}
inline void consume_block_resources_arguments::set_disk_storage_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_disk_storage_consumed(value);
  // @@protoc_insertion_point(field_set:koinos.chain.consume_block_resources_arguments.disk_storage_consumed)
}

// uint64 network_bandwidth_consumed = 2 [jstype = JS_STRING];
inline void consume_block_resources_arguments::clear_network_bandwidth_consumed() {
  network_bandwidth_consumed_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 consume_block_resources_arguments::_internal_network_bandwidth_consumed() const {
  return network_bandwidth_consumed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 consume_block_resources_arguments::network_bandwidth_consumed() const {
  // @@protoc_insertion_point(field_get:koinos.chain.consume_block_resources_arguments.network_bandwidth_consumed)
  return _internal_network_bandwidth_consumed();
}
inline void consume_block_resources_arguments::_internal_set_network_bandwidth_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  network_bandwidth_consumed_ = value;
}
inline void consume_block_resources_arguments::set_network_bandwidth_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_network_bandwidth_consumed(value);
  // @@protoc_insertion_point(field_set:koinos.chain.consume_block_resources_arguments.network_bandwidth_consumed)
}

// uint64 compute_bandwidth_consumed = 3 [jstype = JS_STRING];
inline void consume_block_resources_arguments::clear_compute_bandwidth_consumed() {
  compute_bandwidth_consumed_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 consume_block_resources_arguments::_internal_compute_bandwidth_consumed() const {
  return compute_bandwidth_consumed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 consume_block_resources_arguments::compute_bandwidth_consumed() const {
  // @@protoc_insertion_point(field_get:koinos.chain.consume_block_resources_arguments.compute_bandwidth_consumed)
  return _internal_compute_bandwidth_consumed();
}
inline void consume_block_resources_arguments::_internal_set_compute_bandwidth_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  compute_bandwidth_consumed_ = value;
}
inline void consume_block_resources_arguments::set_compute_bandwidth_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_compute_bandwidth_consumed(value);
  // @@protoc_insertion_point(field_set:koinos.chain.consume_block_resources_arguments.compute_bandwidth_consumed)
}

// -------------------------------------------------------------------

// consume_block_resources_result

// bool value = 1;
inline void consume_block_resources_result::clear_value() {
  value_ = false;
}
inline bool consume_block_resources_result::_internal_value() const {
  return value_;
}
inline bool consume_block_resources_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.consume_block_resources_result.value)
  return _internal_value();
}
inline void consume_block_resources_result::_internal_set_value(bool value) {
  
  value_ = value;
}
inline void consume_block_resources_result::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.consume_block_resources_result.value)
}

// -------------------------------------------------------------------

// put_object_arguments

// .koinos.chain.object_space space = 1;
inline bool put_object_arguments::_internal_has_space() const {
  return this != internal_default_instance() && space_ != nullptr;
}
inline bool put_object_arguments::has_space() const {
  return _internal_has_space();
}
inline const ::koinos::chain::object_space& put_object_arguments::_internal_space() const {
  const ::koinos::chain::object_space* p = space_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::object_space&>(
      ::koinos::chain::_object_space_default_instance_);
}
inline const ::koinos::chain::object_space& put_object_arguments::space() const {
  // @@protoc_insertion_point(field_get:koinos.chain.put_object_arguments.space)
  return _internal_space();
}
inline void put_object_arguments::unsafe_arena_set_allocated_space(
    ::koinos::chain::object_space* space) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(space_);
  }
  space_ = space;
  if (space) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.put_object_arguments.space)
}
inline ::koinos::chain::object_space* put_object_arguments::release_space() {
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::object_space* put_object_arguments::unsafe_arena_release_space() {
  // @@protoc_insertion_point(field_release:koinos.chain.put_object_arguments.space)
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
  return temp;
}
inline ::koinos::chain::object_space* put_object_arguments::_internal_mutable_space() {
  
  if (space_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::object_space>(GetArenaForAllocation());
    space_ = p;
  }
  return space_;
}
inline ::koinos::chain::object_space* put_object_arguments::mutable_space() {
  ::koinos::chain::object_space* _msg = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:koinos.chain.put_object_arguments.space)
  return _msg;
}
inline void put_object_arguments::set_allocated_space(::koinos::chain::object_space* space) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(space_);
  }
  if (space) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(space));
    if (message_arena != submessage_arena) {
      space = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, space, submessage_arena);
    }
    
  } else {
    
  }
  space_ = space;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.put_object_arguments.space)
}

// bytes key = 2;
inline void put_object_arguments::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& put_object_arguments::key() const {
  // @@protoc_insertion_point(field_get:koinos.chain.put_object_arguments.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void put_object_arguments::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.put_object_arguments.key)
}
inline std::string* put_object_arguments::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:koinos.chain.put_object_arguments.key)
  return _s;
}
inline const std::string& put_object_arguments::_internal_key() const {
  return key_.Get();
}
inline void put_object_arguments::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* put_object_arguments::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* put_object_arguments::release_key() {
  // @@protoc_insertion_point(field_release:koinos.chain.put_object_arguments.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void put_object_arguments::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.put_object_arguments.key)
}

// bytes obj = 3;
inline void put_object_arguments::clear_obj() {
  obj_.ClearToEmpty();
}
inline const std::string& put_object_arguments::obj() const {
  // @@protoc_insertion_point(field_get:koinos.chain.put_object_arguments.obj)
  return _internal_obj();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void put_object_arguments::set_obj(ArgT0&& arg0, ArgT... args) {
 
 obj_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.put_object_arguments.obj)
}
inline std::string* put_object_arguments::mutable_obj() {
  std::string* _s = _internal_mutable_obj();
  // @@protoc_insertion_point(field_mutable:koinos.chain.put_object_arguments.obj)
  return _s;
}
inline const std::string& put_object_arguments::_internal_obj() const {
  return obj_.Get();
}
inline void put_object_arguments::_internal_set_obj(const std::string& value) {
  
  obj_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* put_object_arguments::_internal_mutable_obj() {
  
  return obj_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* put_object_arguments::release_obj() {
  // @@protoc_insertion_point(field_release:koinos.chain.put_object_arguments.obj)
  return obj_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void put_object_arguments::set_allocated_obj(std::string* obj) {
  if (obj != nullptr) {
    
  } else {
    
  }
  obj_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), obj,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.put_object_arguments.obj)
}

// -------------------------------------------------------------------

// put_object_result

// -------------------------------------------------------------------

// remove_object_arguments

// .koinos.chain.object_space space = 1;
inline bool remove_object_arguments::_internal_has_space() const {
  return this != internal_default_instance() && space_ != nullptr;
}
inline bool remove_object_arguments::has_space() const {
  return _internal_has_space();
}
inline const ::koinos::chain::object_space& remove_object_arguments::_internal_space() const {
  const ::koinos::chain::object_space* p = space_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::object_space&>(
      ::koinos::chain::_object_space_default_instance_);
}
inline const ::koinos::chain::object_space& remove_object_arguments::space() const {
  // @@protoc_insertion_point(field_get:koinos.chain.remove_object_arguments.space)
  return _internal_space();
}
inline void remove_object_arguments::unsafe_arena_set_allocated_space(
    ::koinos::chain::object_space* space) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(space_);
  }
  space_ = space;
  if (space) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.remove_object_arguments.space)
}
inline ::koinos::chain::object_space* remove_object_arguments::release_space() {
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::object_space* remove_object_arguments::unsafe_arena_release_space() {
  // @@protoc_insertion_point(field_release:koinos.chain.remove_object_arguments.space)
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
  return temp;
}
inline ::koinos::chain::object_space* remove_object_arguments::_internal_mutable_space() {
  
  if (space_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::object_space>(GetArenaForAllocation());
    space_ = p;
  }
  return space_;
}
inline ::koinos::chain::object_space* remove_object_arguments::mutable_space() {
  ::koinos::chain::object_space* _msg = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:koinos.chain.remove_object_arguments.space)
  return _msg;
}
inline void remove_object_arguments::set_allocated_space(::koinos::chain::object_space* space) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(space_);
  }
  if (space) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(space));
    if (message_arena != submessage_arena) {
      space = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, space, submessage_arena);
    }
    
  } else {
    
  }
  space_ = space;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.remove_object_arguments.space)
}

// bytes key = 2;
inline void remove_object_arguments::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& remove_object_arguments::key() const {
  // @@protoc_insertion_point(field_get:koinos.chain.remove_object_arguments.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void remove_object_arguments::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.remove_object_arguments.key)
}
inline std::string* remove_object_arguments::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:koinos.chain.remove_object_arguments.key)
  return _s;
}
inline const std::string& remove_object_arguments::_internal_key() const {
  return key_.Get();
}
inline void remove_object_arguments::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* remove_object_arguments::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* remove_object_arguments::release_key() {
  // @@protoc_insertion_point(field_release:koinos.chain.remove_object_arguments.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void remove_object_arguments::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.remove_object_arguments.key)
}

// -------------------------------------------------------------------

// remove_object_result

// -------------------------------------------------------------------

// get_object_arguments

// .koinos.chain.object_space space = 1;
inline bool get_object_arguments::_internal_has_space() const {
  return this != internal_default_instance() && space_ != nullptr;
}
inline bool get_object_arguments::has_space() const {
  return _internal_has_space();
}
inline const ::koinos::chain::object_space& get_object_arguments::_internal_space() const {
  const ::koinos::chain::object_space* p = space_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::object_space&>(
      ::koinos::chain::_object_space_default_instance_);
}
inline const ::koinos::chain::object_space& get_object_arguments::space() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_object_arguments.space)
  return _internal_space();
}
inline void get_object_arguments::unsafe_arena_set_allocated_space(
    ::koinos::chain::object_space* space) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(space_);
  }
  space_ = space;
  if (space) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_object_arguments.space)
}
inline ::koinos::chain::object_space* get_object_arguments::release_space() {
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::object_space* get_object_arguments::unsafe_arena_release_space() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_object_arguments.space)
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
  return temp;
}
inline ::koinos::chain::object_space* get_object_arguments::_internal_mutable_space() {
  
  if (space_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::object_space>(GetArenaForAllocation());
    space_ = p;
  }
  return space_;
}
inline ::koinos::chain::object_space* get_object_arguments::mutable_space() {
  ::koinos::chain::object_space* _msg = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_object_arguments.space)
  return _msg;
}
inline void get_object_arguments::set_allocated_space(::koinos::chain::object_space* space) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(space_);
  }
  if (space) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(space));
    if (message_arena != submessage_arena) {
      space = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, space, submessage_arena);
    }
    
  } else {
    
  }
  space_ = space;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_object_arguments.space)
}

// bytes key = 2;
inline void get_object_arguments::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& get_object_arguments::key() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_object_arguments.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_object_arguments::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_object_arguments.key)
}
inline std::string* get_object_arguments::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_object_arguments.key)
  return _s;
}
inline const std::string& get_object_arguments::_internal_key() const {
  return key_.Get();
}
inline void get_object_arguments::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_object_arguments::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_object_arguments::release_key() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_object_arguments.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_object_arguments::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_object_arguments.key)
}

// -------------------------------------------------------------------

// database_object

// bool exists = 1;
inline void database_object::clear_exists() {
  exists_ = false;
}
inline bool database_object::_internal_exists() const {
  return exists_;
}
inline bool database_object::exists() const {
  // @@protoc_insertion_point(field_get:koinos.chain.database_object.exists)
  return _internal_exists();
}
inline void database_object::_internal_set_exists(bool value) {
  
  exists_ = value;
}
inline void database_object::set_exists(bool value) {
  _internal_set_exists(value);
  // @@protoc_insertion_point(field_set:koinos.chain.database_object.exists)
}

// bytes value = 2;
inline void database_object::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& database_object::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.database_object.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void database_object::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.database_object.value)
}
inline std::string* database_object::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.database_object.value)
  return _s;
}
inline const std::string& database_object::_internal_value() const {
  return value_.Get();
}
inline void database_object::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* database_object::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* database_object::release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.database_object.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void database_object::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.database_object.value)
}

// bytes key = 3;
inline void database_object::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& database_object::key() const {
  // @@protoc_insertion_point(field_get:koinos.chain.database_object.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void database_object::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.database_object.key)
}
inline std::string* database_object::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:koinos.chain.database_object.key)
  return _s;
}
inline const std::string& database_object::_internal_key() const {
  return key_.Get();
}
inline void database_object::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* database_object::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* database_object::release_key() {
  // @@protoc_insertion_point(field_release:koinos.chain.database_object.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void database_object::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.database_object.key)
}

// -------------------------------------------------------------------

// get_object_result

// .koinos.chain.database_object value = 1;
inline bool get_object_result::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool get_object_result::has_value() const {
  return _internal_has_value();
}
inline void get_object_result::clear_value() {
  if (GetArenaForAllocation() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::koinos::chain::database_object& get_object_result::_internal_value() const {
  const ::koinos::chain::database_object* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::database_object&>(
      ::koinos::chain::_database_object_default_instance_);
}
inline const ::koinos::chain::database_object& get_object_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_object_result.value)
  return _internal_value();
}
inline void get_object_result::unsafe_arena_set_allocated_value(
    ::koinos::chain::database_object* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_object_result.value)
}
inline ::koinos::chain::database_object* get_object_result::release_value() {
  
  ::koinos::chain::database_object* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::database_object* get_object_result::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_object_result.value)
  
  ::koinos::chain::database_object* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::koinos::chain::database_object* get_object_result::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::database_object>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::koinos::chain::database_object* get_object_result::mutable_value() {
  ::koinos::chain::database_object* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_object_result.value)
  return _msg;
}
inline void get_object_result::set_allocated_value(::koinos::chain::database_object* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::koinos::chain::database_object>::GetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_object_result.value)
}

// -------------------------------------------------------------------

// get_next_object_arguments

// .koinos.chain.object_space space = 1;
inline bool get_next_object_arguments::_internal_has_space() const {
  return this != internal_default_instance() && space_ != nullptr;
}
inline bool get_next_object_arguments::has_space() const {
  return _internal_has_space();
}
inline const ::koinos::chain::object_space& get_next_object_arguments::_internal_space() const {
  const ::koinos::chain::object_space* p = space_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::object_space&>(
      ::koinos::chain::_object_space_default_instance_);
}
inline const ::koinos::chain::object_space& get_next_object_arguments::space() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_next_object_arguments.space)
  return _internal_space();
}
inline void get_next_object_arguments::unsafe_arena_set_allocated_space(
    ::koinos::chain::object_space* space) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(space_);
  }
  space_ = space;
  if (space) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_next_object_arguments.space)
}
inline ::koinos::chain::object_space* get_next_object_arguments::release_space() {
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::object_space* get_next_object_arguments::unsafe_arena_release_space() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_next_object_arguments.space)
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
  return temp;
}
inline ::koinos::chain::object_space* get_next_object_arguments::_internal_mutable_space() {
  
  if (space_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::object_space>(GetArenaForAllocation());
    space_ = p;
  }
  return space_;
}
inline ::koinos::chain::object_space* get_next_object_arguments::mutable_space() {
  ::koinos::chain::object_space* _msg = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_next_object_arguments.space)
  return _msg;
}
inline void get_next_object_arguments::set_allocated_space(::koinos::chain::object_space* space) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(space_);
  }
  if (space) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(space));
    if (message_arena != submessage_arena) {
      space = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, space, submessage_arena);
    }
    
  } else {
    
  }
  space_ = space;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_next_object_arguments.space)
}

// bytes key = 2;
inline void get_next_object_arguments::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& get_next_object_arguments::key() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_next_object_arguments.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_next_object_arguments::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_next_object_arguments.key)
}
inline std::string* get_next_object_arguments::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_next_object_arguments.key)
  return _s;
}
inline const std::string& get_next_object_arguments::_internal_key() const {
  return key_.Get();
}
inline void get_next_object_arguments::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_next_object_arguments::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_next_object_arguments::release_key() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_next_object_arguments.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_next_object_arguments::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_next_object_arguments.key)
}

// -------------------------------------------------------------------

// get_next_object_result

// .koinos.chain.database_object value = 1;
inline bool get_next_object_result::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool get_next_object_result::has_value() const {
  return _internal_has_value();
}
inline void get_next_object_result::clear_value() {
  if (GetArenaForAllocation() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::koinos::chain::database_object& get_next_object_result::_internal_value() const {
  const ::koinos::chain::database_object* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::database_object&>(
      ::koinos::chain::_database_object_default_instance_);
}
inline const ::koinos::chain::database_object& get_next_object_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_next_object_result.value)
  return _internal_value();
}
inline void get_next_object_result::unsafe_arena_set_allocated_value(
    ::koinos::chain::database_object* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_next_object_result.value)
}
inline ::koinos::chain::database_object* get_next_object_result::release_value() {
  
  ::koinos::chain::database_object* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::database_object* get_next_object_result::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_next_object_result.value)
  
  ::koinos::chain::database_object* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::koinos::chain::database_object* get_next_object_result::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::database_object>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::koinos::chain::database_object* get_next_object_result::mutable_value() {
  ::koinos::chain::database_object* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_next_object_result.value)
  return _msg;
}
inline void get_next_object_result::set_allocated_value(::koinos::chain::database_object* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::koinos::chain::database_object>::GetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_next_object_result.value)
}

// -------------------------------------------------------------------

// get_prev_object_arguments

// .koinos.chain.object_space space = 1;
inline bool get_prev_object_arguments::_internal_has_space() const {
  return this != internal_default_instance() && space_ != nullptr;
}
inline bool get_prev_object_arguments::has_space() const {
  return _internal_has_space();
}
inline const ::koinos::chain::object_space& get_prev_object_arguments::_internal_space() const {
  const ::koinos::chain::object_space* p = space_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::object_space&>(
      ::koinos::chain::_object_space_default_instance_);
}
inline const ::koinos::chain::object_space& get_prev_object_arguments::space() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_prev_object_arguments.space)
  return _internal_space();
}
inline void get_prev_object_arguments::unsafe_arena_set_allocated_space(
    ::koinos::chain::object_space* space) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(space_);
  }
  space_ = space;
  if (space) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_prev_object_arguments.space)
}
inline ::koinos::chain::object_space* get_prev_object_arguments::release_space() {
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::object_space* get_prev_object_arguments::unsafe_arena_release_space() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_prev_object_arguments.space)
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
  return temp;
}
inline ::koinos::chain::object_space* get_prev_object_arguments::_internal_mutable_space() {
  
  if (space_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::object_space>(GetArenaForAllocation());
    space_ = p;
  }
  return space_;
}
inline ::koinos::chain::object_space* get_prev_object_arguments::mutable_space() {
  ::koinos::chain::object_space* _msg = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_prev_object_arguments.space)
  return _msg;
}
inline void get_prev_object_arguments::set_allocated_space(::koinos::chain::object_space* space) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(space_);
  }
  if (space) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(space));
    if (message_arena != submessage_arena) {
      space = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, space, submessage_arena);
    }
    
  } else {
    
  }
  space_ = space;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_prev_object_arguments.space)
}

// bytes key = 2;
inline void get_prev_object_arguments::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& get_prev_object_arguments::key() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_prev_object_arguments.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_prev_object_arguments::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_prev_object_arguments.key)
}
inline std::string* get_prev_object_arguments::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_prev_object_arguments.key)
  return _s;
}
inline const std::string& get_prev_object_arguments::_internal_key() const {
  return key_.Get();
}
inline void get_prev_object_arguments::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_prev_object_arguments::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_prev_object_arguments::release_key() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_prev_object_arguments.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_prev_object_arguments::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_prev_object_arguments.key)
}

// -------------------------------------------------------------------

// get_prev_object_result

// .koinos.chain.database_object value = 1;
inline bool get_prev_object_result::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool get_prev_object_result::has_value() const {
  return _internal_has_value();
}
inline void get_prev_object_result::clear_value() {
  if (GetArenaForAllocation() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::koinos::chain::database_object& get_prev_object_result::_internal_value() const {
  const ::koinos::chain::database_object* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::database_object&>(
      ::koinos::chain::_database_object_default_instance_);
}
inline const ::koinos::chain::database_object& get_prev_object_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_prev_object_result.value)
  return _internal_value();
}
inline void get_prev_object_result::unsafe_arena_set_allocated_value(
    ::koinos::chain::database_object* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_prev_object_result.value)
}
inline ::koinos::chain::database_object* get_prev_object_result::release_value() {
  
  ::koinos::chain::database_object* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::database_object* get_prev_object_result::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_prev_object_result.value)
  
  ::koinos::chain::database_object* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::koinos::chain::database_object* get_prev_object_result::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::database_object>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::koinos::chain::database_object* get_prev_object_result::mutable_value() {
  ::koinos::chain::database_object* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_prev_object_result.value)
  return _msg;
}
inline void get_prev_object_result::set_allocated_value(::koinos::chain::database_object* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::koinos::chain::database_object>::GetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_prev_object_result.value)
}

// -------------------------------------------------------------------

// log_arguments

// string message = 1;
inline void log_arguments::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& log_arguments::message() const {
  // @@protoc_insertion_point(field_get:koinos.chain.log_arguments.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void log_arguments::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.log_arguments.message)
}
inline std::string* log_arguments::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:koinos.chain.log_arguments.message)
  return _s;
}
inline const std::string& log_arguments::_internal_message() const {
  return message_.Get();
}
inline void log_arguments::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* log_arguments::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* log_arguments::release_message() {
  // @@protoc_insertion_point(field_release:koinos.chain.log_arguments.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void log_arguments::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.log_arguments.message)
}

// -------------------------------------------------------------------

// log_result

// -------------------------------------------------------------------

// event_arguments

// string name = 1;
inline void event_arguments::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& event_arguments::name() const {
  // @@protoc_insertion_point(field_get:koinos.chain.event_arguments.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void event_arguments::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.event_arguments.name)
}
inline std::string* event_arguments::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:koinos.chain.event_arguments.name)
  return _s;
}
inline const std::string& event_arguments::_internal_name() const {
  return name_.Get();
}
inline void event_arguments::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* event_arguments::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* event_arguments::release_name() {
  // @@protoc_insertion_point(field_release:koinos.chain.event_arguments.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void event_arguments::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.event_arguments.name)
}

// bytes data = 2;
inline void event_arguments::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& event_arguments::data() const {
  // @@protoc_insertion_point(field_get:koinos.chain.event_arguments.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void event_arguments::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.event_arguments.data)
}
inline std::string* event_arguments::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:koinos.chain.event_arguments.data)
  return _s;
}
inline const std::string& event_arguments::_internal_data() const {
  return data_.Get();
}
inline void event_arguments::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* event_arguments::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* event_arguments::release_data() {
  // @@protoc_insertion_point(field_release:koinos.chain.event_arguments.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void event_arguments::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.event_arguments.data)
}

// repeated bytes impacted = 3 [(.koinos.btype) = ADDRESS];
inline int event_arguments::_internal_impacted_size() const {
  return impacted_.size();
}
inline int event_arguments::impacted_size() const {
  return _internal_impacted_size();
}
inline void event_arguments::clear_impacted() {
  impacted_.Clear();
}
inline std::string* event_arguments::add_impacted() {
  std::string* _s = _internal_add_impacted();
  // @@protoc_insertion_point(field_add_mutable:koinos.chain.event_arguments.impacted)
  return _s;
}
inline const std::string& event_arguments::_internal_impacted(int index) const {
  return impacted_.Get(index);
}
inline const std::string& event_arguments::impacted(int index) const {
  // @@protoc_insertion_point(field_get:koinos.chain.event_arguments.impacted)
  return _internal_impacted(index);
}
inline std::string* event_arguments::mutable_impacted(int index) {
  // @@protoc_insertion_point(field_mutable:koinos.chain.event_arguments.impacted)
  return impacted_.Mutable(index);
}
inline void event_arguments::set_impacted(int index, const std::string& value) {
  impacted_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:koinos.chain.event_arguments.impacted)
}
inline void event_arguments::set_impacted(int index, std::string&& value) {
  impacted_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:koinos.chain.event_arguments.impacted)
}
inline void event_arguments::set_impacted(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  impacted_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:koinos.chain.event_arguments.impacted)
}
inline void event_arguments::set_impacted(int index, const void* value, size_t size) {
  impacted_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:koinos.chain.event_arguments.impacted)
}
inline std::string* event_arguments::_internal_add_impacted() {
  return impacted_.Add();
}
inline void event_arguments::add_impacted(const std::string& value) {
  impacted_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:koinos.chain.event_arguments.impacted)
}
inline void event_arguments::add_impacted(std::string&& value) {
  impacted_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:koinos.chain.event_arguments.impacted)
}
inline void event_arguments::add_impacted(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  impacted_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:koinos.chain.event_arguments.impacted)
}
inline void event_arguments::add_impacted(const void* value, size_t size) {
  impacted_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:koinos.chain.event_arguments.impacted)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
event_arguments::impacted() const {
  // @@protoc_insertion_point(field_list:koinos.chain.event_arguments.impacted)
  return impacted_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
event_arguments::mutable_impacted() {
  // @@protoc_insertion_point(field_mutable_list:koinos.chain.event_arguments.impacted)
  return &impacted_;
}

// -------------------------------------------------------------------

// event_result

// -------------------------------------------------------------------

// hash_arguments

// uint64 code = 1 [jstype = JS_STRING];
inline void hash_arguments::clear_code() {
  code_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 hash_arguments::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 hash_arguments::code() const {
  // @@protoc_insertion_point(field_get:koinos.chain.hash_arguments.code)
  return _internal_code();
}
inline void hash_arguments::_internal_set_code(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  code_ = value;
}
inline void hash_arguments::set_code(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:koinos.chain.hash_arguments.code)
}

// bytes obj = 2;
inline void hash_arguments::clear_obj() {
  obj_.ClearToEmpty();
}
inline const std::string& hash_arguments::obj() const {
  // @@protoc_insertion_point(field_get:koinos.chain.hash_arguments.obj)
  return _internal_obj();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void hash_arguments::set_obj(ArgT0&& arg0, ArgT... args) {
 
 obj_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.hash_arguments.obj)
}
inline std::string* hash_arguments::mutable_obj() {
  std::string* _s = _internal_mutable_obj();
  // @@protoc_insertion_point(field_mutable:koinos.chain.hash_arguments.obj)
  return _s;
}
inline const std::string& hash_arguments::_internal_obj() const {
  return obj_.Get();
}
inline void hash_arguments::_internal_set_obj(const std::string& value) {
  
  obj_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* hash_arguments::_internal_mutable_obj() {
  
  return obj_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* hash_arguments::release_obj() {
  // @@protoc_insertion_point(field_release:koinos.chain.hash_arguments.obj)
  return obj_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void hash_arguments::set_allocated_obj(std::string* obj) {
  if (obj != nullptr) {
    
  } else {
    
  }
  obj_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), obj,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.hash_arguments.obj)
}

// uint64 size = 3 [jstype = JS_STRING];
inline void hash_arguments::clear_size() {
  size_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 hash_arguments::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 hash_arguments::size() const {
  // @@protoc_insertion_point(field_get:koinos.chain.hash_arguments.size)
  return _internal_size();
}
inline void hash_arguments::_internal_set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  size_ = value;
}
inline void hash_arguments::set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:koinos.chain.hash_arguments.size)
}

// -------------------------------------------------------------------

// hash_result

// bytes value = 1;
inline void hash_result::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& hash_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.hash_result.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void hash_result::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.hash_result.value)
}
inline std::string* hash_result::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.hash_result.value)
  return _s;
}
inline const std::string& hash_result::_internal_value() const {
  return value_.Get();
}
inline void hash_result::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* hash_result::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* hash_result::release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.hash_result.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void hash_result::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.hash_result.value)
}

// -------------------------------------------------------------------

// recover_public_key_arguments

// .koinos.chain.dsa type = 1;
inline void recover_public_key_arguments::clear_type() {
  type_ = 0;
}
inline ::koinos::chain::dsa recover_public_key_arguments::_internal_type() const {
  return static_cast< ::koinos::chain::dsa >(type_);
}
inline ::koinos::chain::dsa recover_public_key_arguments::type() const {
  // @@protoc_insertion_point(field_get:koinos.chain.recover_public_key_arguments.type)
  return _internal_type();
}
inline void recover_public_key_arguments::_internal_set_type(::koinos::chain::dsa value) {
  
  type_ = value;
}
inline void recover_public_key_arguments::set_type(::koinos::chain::dsa value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:koinos.chain.recover_public_key_arguments.type)
}

// bytes signature = 2;
inline void recover_public_key_arguments::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& recover_public_key_arguments::signature() const {
  // @@protoc_insertion_point(field_get:koinos.chain.recover_public_key_arguments.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void recover_public_key_arguments::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.recover_public_key_arguments.signature)
}
inline std::string* recover_public_key_arguments::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:koinos.chain.recover_public_key_arguments.signature)
  return _s;
}
inline const std::string& recover_public_key_arguments::_internal_signature() const {
  return signature_.Get();
}
inline void recover_public_key_arguments::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* recover_public_key_arguments::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* recover_public_key_arguments::release_signature() {
  // @@protoc_insertion_point(field_release:koinos.chain.recover_public_key_arguments.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void recover_public_key_arguments::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.recover_public_key_arguments.signature)
}

// bytes digest = 3;
inline void recover_public_key_arguments::clear_digest() {
  digest_.ClearToEmpty();
}
inline const std::string& recover_public_key_arguments::digest() const {
  // @@protoc_insertion_point(field_get:koinos.chain.recover_public_key_arguments.digest)
  return _internal_digest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void recover_public_key_arguments::set_digest(ArgT0&& arg0, ArgT... args) {
 
 digest_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.recover_public_key_arguments.digest)
}
inline std::string* recover_public_key_arguments::mutable_digest() {
  std::string* _s = _internal_mutable_digest();
  // @@protoc_insertion_point(field_mutable:koinos.chain.recover_public_key_arguments.digest)
  return _s;
}
inline const std::string& recover_public_key_arguments::_internal_digest() const {
  return digest_.Get();
}
inline void recover_public_key_arguments::_internal_set_digest(const std::string& value) {
  
  digest_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* recover_public_key_arguments::_internal_mutable_digest() {
  
  return digest_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* recover_public_key_arguments::release_digest() {
  // @@protoc_insertion_point(field_release:koinos.chain.recover_public_key_arguments.digest)
  return digest_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void recover_public_key_arguments::set_allocated_digest(std::string* digest) {
  if (digest != nullptr) {
    
  } else {
    
  }
  digest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), digest,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.recover_public_key_arguments.digest)
}

// bool compressed = 4;
inline void recover_public_key_arguments::clear_compressed() {
  compressed_ = false;
}
inline bool recover_public_key_arguments::_internal_compressed() const {
  return compressed_;
}
inline bool recover_public_key_arguments::compressed() const {
  // @@protoc_insertion_point(field_get:koinos.chain.recover_public_key_arguments.compressed)
  return _internal_compressed();
}
inline void recover_public_key_arguments::_internal_set_compressed(bool value) {
  
  compressed_ = value;
}
inline void recover_public_key_arguments::set_compressed(bool value) {
  _internal_set_compressed(value);
  // @@protoc_insertion_point(field_set:koinos.chain.recover_public_key_arguments.compressed)
}

// -------------------------------------------------------------------

// recover_public_key_result

// bytes value = 1 [(.koinos.btype) = BASE64];
inline void recover_public_key_result::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& recover_public_key_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.recover_public_key_result.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void recover_public_key_result::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.recover_public_key_result.value)
}
inline std::string* recover_public_key_result::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.recover_public_key_result.value)
  return _s;
}
inline const std::string& recover_public_key_result::_internal_value() const {
  return value_.Get();
}
inline void recover_public_key_result::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* recover_public_key_result::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* recover_public_key_result::release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.recover_public_key_result.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void recover_public_key_result::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.recover_public_key_result.value)
}

// -------------------------------------------------------------------

// verify_merkle_root_arguments

// bytes root = 1;
inline void verify_merkle_root_arguments::clear_root() {
  root_.ClearToEmpty();
}
inline const std::string& verify_merkle_root_arguments::root() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_merkle_root_arguments.root)
  return _internal_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void verify_merkle_root_arguments::set_root(ArgT0&& arg0, ArgT... args) {
 
 root_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.verify_merkle_root_arguments.root)
}
inline std::string* verify_merkle_root_arguments::mutable_root() {
  std::string* _s = _internal_mutable_root();
  // @@protoc_insertion_point(field_mutable:koinos.chain.verify_merkle_root_arguments.root)
  return _s;
}
inline const std::string& verify_merkle_root_arguments::_internal_root() const {
  return root_.Get();
}
inline void verify_merkle_root_arguments::_internal_set_root(const std::string& value) {
  
  root_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* verify_merkle_root_arguments::_internal_mutable_root() {
  
  return root_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* verify_merkle_root_arguments::release_root() {
  // @@protoc_insertion_point(field_release:koinos.chain.verify_merkle_root_arguments.root)
  return root_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void verify_merkle_root_arguments::set_allocated_root(std::string* root) {
  if (root != nullptr) {
    
  } else {
    
  }
  root_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), root,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.verify_merkle_root_arguments.root)
}

// repeated bytes hashes = 2;
inline int verify_merkle_root_arguments::_internal_hashes_size() const {
  return hashes_.size();
}
inline int verify_merkle_root_arguments::hashes_size() const {
  return _internal_hashes_size();
}
inline void verify_merkle_root_arguments::clear_hashes() {
  hashes_.Clear();
}
inline std::string* verify_merkle_root_arguments::add_hashes() {
  std::string* _s = _internal_add_hashes();
  // @@protoc_insertion_point(field_add_mutable:koinos.chain.verify_merkle_root_arguments.hashes)
  return _s;
}
inline const std::string& verify_merkle_root_arguments::_internal_hashes(int index) const {
  return hashes_.Get(index);
}
inline const std::string& verify_merkle_root_arguments::hashes(int index) const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_merkle_root_arguments.hashes)
  return _internal_hashes(index);
}
inline std::string* verify_merkle_root_arguments::mutable_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:koinos.chain.verify_merkle_root_arguments.hashes)
  return hashes_.Mutable(index);
}
inline void verify_merkle_root_arguments::set_hashes(int index, const std::string& value) {
  hashes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:koinos.chain.verify_merkle_root_arguments.hashes)
}
inline void verify_merkle_root_arguments::set_hashes(int index, std::string&& value) {
  hashes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:koinos.chain.verify_merkle_root_arguments.hashes)
}
inline void verify_merkle_root_arguments::set_hashes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hashes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:koinos.chain.verify_merkle_root_arguments.hashes)
}
inline void verify_merkle_root_arguments::set_hashes(int index, const void* value, size_t size) {
  hashes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:koinos.chain.verify_merkle_root_arguments.hashes)
}
inline std::string* verify_merkle_root_arguments::_internal_add_hashes() {
  return hashes_.Add();
}
inline void verify_merkle_root_arguments::add_hashes(const std::string& value) {
  hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:koinos.chain.verify_merkle_root_arguments.hashes)
}
inline void verify_merkle_root_arguments::add_hashes(std::string&& value) {
  hashes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:koinos.chain.verify_merkle_root_arguments.hashes)
}
inline void verify_merkle_root_arguments::add_hashes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:koinos.chain.verify_merkle_root_arguments.hashes)
}
inline void verify_merkle_root_arguments::add_hashes(const void* value, size_t size) {
  hashes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:koinos.chain.verify_merkle_root_arguments.hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
verify_merkle_root_arguments::hashes() const {
  // @@protoc_insertion_point(field_list:koinos.chain.verify_merkle_root_arguments.hashes)
  return hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
verify_merkle_root_arguments::mutable_hashes() {
  // @@protoc_insertion_point(field_mutable_list:koinos.chain.verify_merkle_root_arguments.hashes)
  return &hashes_;
}

// -------------------------------------------------------------------

// verify_merkle_root_result

// bool value = 1;
inline void verify_merkle_root_result::clear_value() {
  value_ = false;
}
inline bool verify_merkle_root_result::_internal_value() const {
  return value_;
}
inline bool verify_merkle_root_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_merkle_root_result.value)
  return _internal_value();
}
inline void verify_merkle_root_result::_internal_set_value(bool value) {
  
  value_ = value;
}
inline void verify_merkle_root_result::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.verify_merkle_root_result.value)
}

// -------------------------------------------------------------------

// verify_signature_arguments

// .koinos.chain.dsa type = 1;
inline void verify_signature_arguments::clear_type() {
  type_ = 0;
}
inline ::koinos::chain::dsa verify_signature_arguments::_internal_type() const {
  return static_cast< ::koinos::chain::dsa >(type_);
}
inline ::koinos::chain::dsa verify_signature_arguments::type() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_signature_arguments.type)
  return _internal_type();
}
inline void verify_signature_arguments::_internal_set_type(::koinos::chain::dsa value) {
  
  type_ = value;
}
inline void verify_signature_arguments::set_type(::koinos::chain::dsa value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:koinos.chain.verify_signature_arguments.type)
}

// bytes public_key = 2 [(.koinos.btype) = BASE64];
inline void verify_signature_arguments::clear_public_key() {
  public_key_.ClearToEmpty();
}
inline const std::string& verify_signature_arguments::public_key() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_signature_arguments.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void verify_signature_arguments::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 public_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.verify_signature_arguments.public_key)
}
inline std::string* verify_signature_arguments::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:koinos.chain.verify_signature_arguments.public_key)
  return _s;
}
inline const std::string& verify_signature_arguments::_internal_public_key() const {
  return public_key_.Get();
}
inline void verify_signature_arguments::_internal_set_public_key(const std::string& value) {
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* verify_signature_arguments::_internal_mutable_public_key() {
  
  return public_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* verify_signature_arguments::release_public_key() {
  // @@protoc_insertion_point(field_release:koinos.chain.verify_signature_arguments.public_key)
  return public_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void verify_signature_arguments::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.verify_signature_arguments.public_key)
}

// bytes signature = 3 [(.koinos.btype) = BASE64];
inline void verify_signature_arguments::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& verify_signature_arguments::signature() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_signature_arguments.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void verify_signature_arguments::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.verify_signature_arguments.signature)
}
inline std::string* verify_signature_arguments::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:koinos.chain.verify_signature_arguments.signature)
  return _s;
}
inline const std::string& verify_signature_arguments::_internal_signature() const {
  return signature_.Get();
}
inline void verify_signature_arguments::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* verify_signature_arguments::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* verify_signature_arguments::release_signature() {
  // @@protoc_insertion_point(field_release:koinos.chain.verify_signature_arguments.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void verify_signature_arguments::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.verify_signature_arguments.signature)
}

// bytes digest = 4 [(.koinos.btype) = BASE64];
inline void verify_signature_arguments::clear_digest() {
  digest_.ClearToEmpty();
}
inline const std::string& verify_signature_arguments::digest() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_signature_arguments.digest)
  return _internal_digest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void verify_signature_arguments::set_digest(ArgT0&& arg0, ArgT... args) {
 
 digest_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.verify_signature_arguments.digest)
}
inline std::string* verify_signature_arguments::mutable_digest() {
  std::string* _s = _internal_mutable_digest();
  // @@protoc_insertion_point(field_mutable:koinos.chain.verify_signature_arguments.digest)
  return _s;
}
inline const std::string& verify_signature_arguments::_internal_digest() const {
  return digest_.Get();
}
inline void verify_signature_arguments::_internal_set_digest(const std::string& value) {
  
  digest_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* verify_signature_arguments::_internal_mutable_digest() {
  
  return digest_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* verify_signature_arguments::release_digest() {
  // @@protoc_insertion_point(field_release:koinos.chain.verify_signature_arguments.digest)
  return digest_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void verify_signature_arguments::set_allocated_digest(std::string* digest) {
  if (digest != nullptr) {
    
  } else {
    
  }
  digest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), digest,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.verify_signature_arguments.digest)
}

// bool compressed = 5;
inline void verify_signature_arguments::clear_compressed() {
  compressed_ = false;
}
inline bool verify_signature_arguments::_internal_compressed() const {
  return compressed_;
}
inline bool verify_signature_arguments::compressed() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_signature_arguments.compressed)
  return _internal_compressed();
}
inline void verify_signature_arguments::_internal_set_compressed(bool value) {
  
  compressed_ = value;
}
inline void verify_signature_arguments::set_compressed(bool value) {
  _internal_set_compressed(value);
  // @@protoc_insertion_point(field_set:koinos.chain.verify_signature_arguments.compressed)
}

// -------------------------------------------------------------------

// verify_signature_result

// bool value = 1;
inline void verify_signature_result::clear_value() {
  value_ = false;
}
inline bool verify_signature_result::_internal_value() const {
  return value_;
}
inline bool verify_signature_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_signature_result.value)
  return _internal_value();
}
inline void verify_signature_result::_internal_set_value(bool value) {
  
  value_ = value;
}
inline void verify_signature_result::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.verify_signature_result.value)
}

// -------------------------------------------------------------------

// verify_vrf_proof_arguments

// .koinos.chain.dsa type = 1;
inline void verify_vrf_proof_arguments::clear_type() {
  type_ = 0;
}
inline ::koinos::chain::dsa verify_vrf_proof_arguments::_internal_type() const {
  return static_cast< ::koinos::chain::dsa >(type_);
}
inline ::koinos::chain::dsa verify_vrf_proof_arguments::type() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_vrf_proof_arguments.type)
  return _internal_type();
}
inline void verify_vrf_proof_arguments::_internal_set_type(::koinos::chain::dsa value) {
  
  type_ = value;
}
inline void verify_vrf_proof_arguments::set_type(::koinos::chain::dsa value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:koinos.chain.verify_vrf_proof_arguments.type)
}

// bytes public_key = 2 [(.koinos.btype) = BASE64];
inline void verify_vrf_proof_arguments::clear_public_key() {
  public_key_.ClearToEmpty();
}
inline const std::string& verify_vrf_proof_arguments::public_key() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_vrf_proof_arguments.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void verify_vrf_proof_arguments::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 public_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.verify_vrf_proof_arguments.public_key)
}
inline std::string* verify_vrf_proof_arguments::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:koinos.chain.verify_vrf_proof_arguments.public_key)
  return _s;
}
inline const std::string& verify_vrf_proof_arguments::_internal_public_key() const {
  return public_key_.Get();
}
inline void verify_vrf_proof_arguments::_internal_set_public_key(const std::string& value) {
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* verify_vrf_proof_arguments::_internal_mutable_public_key() {
  
  return public_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* verify_vrf_proof_arguments::release_public_key() {
  // @@protoc_insertion_point(field_release:koinos.chain.verify_vrf_proof_arguments.public_key)
  return public_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void verify_vrf_proof_arguments::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.verify_vrf_proof_arguments.public_key)
}

// bytes proof = 3 [(.koinos.btype) = BASE64];
inline void verify_vrf_proof_arguments::clear_proof() {
  proof_.ClearToEmpty();
}
inline const std::string& verify_vrf_proof_arguments::proof() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_vrf_proof_arguments.proof)
  return _internal_proof();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void verify_vrf_proof_arguments::set_proof(ArgT0&& arg0, ArgT... args) {
 
 proof_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.verify_vrf_proof_arguments.proof)
}
inline std::string* verify_vrf_proof_arguments::mutable_proof() {
  std::string* _s = _internal_mutable_proof();
  // @@protoc_insertion_point(field_mutable:koinos.chain.verify_vrf_proof_arguments.proof)
  return _s;
}
inline const std::string& verify_vrf_proof_arguments::_internal_proof() const {
  return proof_.Get();
}
inline void verify_vrf_proof_arguments::_internal_set_proof(const std::string& value) {
  
  proof_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* verify_vrf_proof_arguments::_internal_mutable_proof() {
  
  return proof_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* verify_vrf_proof_arguments::release_proof() {
  // @@protoc_insertion_point(field_release:koinos.chain.verify_vrf_proof_arguments.proof)
  return proof_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void verify_vrf_proof_arguments::set_allocated_proof(std::string* proof) {
  if (proof != nullptr) {
    
  } else {
    
  }
  proof_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), proof,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.verify_vrf_proof_arguments.proof)
}

// bytes hash = 4 [(.koinos.btype) = BASE64];
inline void verify_vrf_proof_arguments::clear_hash() {
  hash_.ClearToEmpty();
}
inline const std::string& verify_vrf_proof_arguments::hash() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_vrf_proof_arguments.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void verify_vrf_proof_arguments::set_hash(ArgT0&& arg0, ArgT... args) {
 
 hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.verify_vrf_proof_arguments.hash)
}
inline std::string* verify_vrf_proof_arguments::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:koinos.chain.verify_vrf_proof_arguments.hash)
  return _s;
}
inline const std::string& verify_vrf_proof_arguments::_internal_hash() const {
  return hash_.Get();
}
inline void verify_vrf_proof_arguments::_internal_set_hash(const std::string& value) {
  
  hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* verify_vrf_proof_arguments::_internal_mutable_hash() {
  
  return hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* verify_vrf_proof_arguments::release_hash() {
  // @@protoc_insertion_point(field_release:koinos.chain.verify_vrf_proof_arguments.hash)
  return hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void verify_vrf_proof_arguments::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.verify_vrf_proof_arguments.hash)
}

// bytes message = 5 [(.koinos.btype) = BASE64];
inline void verify_vrf_proof_arguments::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& verify_vrf_proof_arguments::message() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_vrf_proof_arguments.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void verify_vrf_proof_arguments::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.verify_vrf_proof_arguments.message)
}
inline std::string* verify_vrf_proof_arguments::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:koinos.chain.verify_vrf_proof_arguments.message)
  return _s;
}
inline const std::string& verify_vrf_proof_arguments::_internal_message() const {
  return message_.Get();
}
inline void verify_vrf_proof_arguments::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* verify_vrf_proof_arguments::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* verify_vrf_proof_arguments::release_message() {
  // @@protoc_insertion_point(field_release:koinos.chain.verify_vrf_proof_arguments.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void verify_vrf_proof_arguments::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.verify_vrf_proof_arguments.message)
}

// -------------------------------------------------------------------

// verify_vrf_proof_result

// bool value = 1;
inline void verify_vrf_proof_result::clear_value() {
  value_ = false;
}
inline bool verify_vrf_proof_result::_internal_value() const {
  return value_;
}
inline bool verify_vrf_proof_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_vrf_proof_result.value)
  return _internal_value();
}
inline void verify_vrf_proof_result::_internal_set_value(bool value) {
  
  value_ = value;
}
inline void verify_vrf_proof_result::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.verify_vrf_proof_result.value)
}

// -------------------------------------------------------------------

// call_arguments

// bytes contract_id = 1 [(.koinos.btype) = CONTRACT_ID];
inline void call_arguments::clear_contract_id() {
  contract_id_.ClearToEmpty();
}
inline const std::string& call_arguments::contract_id() const {
  // @@protoc_insertion_point(field_get:koinos.chain.call_arguments.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void call_arguments::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 contract_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.call_arguments.contract_id)
}
inline std::string* call_arguments::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:koinos.chain.call_arguments.contract_id)
  return _s;
}
inline const std::string& call_arguments::_internal_contract_id() const {
  return contract_id_.Get();
}
inline void call_arguments::_internal_set_contract_id(const std::string& value) {
  
  contract_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* call_arguments::_internal_mutable_contract_id() {
  
  return contract_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* call_arguments::release_contract_id() {
  // @@protoc_insertion_point(field_release:koinos.chain.call_arguments.contract_id)
  return contract_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void call_arguments::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  contract_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.call_arguments.contract_id)
}

// uint32 entry_point = 2;
inline void call_arguments::clear_entry_point() {
  entry_point_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 call_arguments::_internal_entry_point() const {
  return entry_point_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 call_arguments::entry_point() const {
  // @@protoc_insertion_point(field_get:koinos.chain.call_arguments.entry_point)
  return _internal_entry_point();
}
inline void call_arguments::_internal_set_entry_point(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  entry_point_ = value;
}
inline void call_arguments::set_entry_point(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_entry_point(value);
  // @@protoc_insertion_point(field_set:koinos.chain.call_arguments.entry_point)
}

// bytes args = 3;
inline void call_arguments::clear_args() {
  args_.ClearToEmpty();
}
inline const std::string& call_arguments::args() const {
  // @@protoc_insertion_point(field_get:koinos.chain.call_arguments.args)
  return _internal_args();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void call_arguments::set_args(ArgT0&& arg0, ArgT... args) {
 
 args_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.call_arguments.args)
}
inline std::string* call_arguments::mutable_args() {
  std::string* _s = _internal_mutable_args();
  // @@protoc_insertion_point(field_mutable:koinos.chain.call_arguments.args)
  return _s;
}
inline const std::string& call_arguments::_internal_args() const {
  return args_.Get();
}
inline void call_arguments::_internal_set_args(const std::string& value) {
  
  args_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* call_arguments::_internal_mutable_args() {
  
  return args_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* call_arguments::release_args() {
  // @@protoc_insertion_point(field_release:koinos.chain.call_arguments.args)
  return args_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void call_arguments::set_allocated_args(std::string* args) {
  if (args != nullptr) {
    
  } else {
    
  }
  args_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), args,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.call_arguments.args)
}

// -------------------------------------------------------------------

// call_result

// bytes value = 1;
inline void call_result::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& call_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.call_result.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void call_result::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.call_result.value)
}
inline std::string* call_result::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.call_result.value)
  return _s;
}
inline const std::string& call_result::_internal_value() const {
  return value_.Get();
}
inline void call_result::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* call_result::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* call_result::release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.call_result.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void call_result::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.call_result.value)
}

// -------------------------------------------------------------------

// get_arguments_arguments

// -------------------------------------------------------------------

// get_arguments_result

// .koinos.chain.argument_data value = 1;
inline bool get_arguments_result::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool get_arguments_result::has_value() const {
  return _internal_has_value();
}
inline const ::koinos::chain::argument_data& get_arguments_result::_internal_value() const {
  const ::koinos::chain::argument_data* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::argument_data&>(
      ::koinos::chain::_argument_data_default_instance_);
}
inline const ::koinos::chain::argument_data& get_arguments_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_arguments_result.value)
  return _internal_value();
}
inline void get_arguments_result::unsafe_arena_set_allocated_value(
    ::koinos::chain::argument_data* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_arguments_result.value)
}
inline ::koinos::chain::argument_data* get_arguments_result::release_value() {
  
  ::koinos::chain::argument_data* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::argument_data* get_arguments_result::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_arguments_result.value)
  
  ::koinos::chain::argument_data* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::koinos::chain::argument_data* get_arguments_result::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::argument_data>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::koinos::chain::argument_data* get_arguments_result::mutable_value() {
  ::koinos::chain::argument_data* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_arguments_result.value)
  return _msg;
}
inline void get_arguments_result::set_allocated_value(::koinos::chain::argument_data* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_arguments_result.value)
}

// -------------------------------------------------------------------

// exit_arguments

// int32 code = 1;
inline void exit_arguments::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 exit_arguments::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 exit_arguments::code() const {
  // @@protoc_insertion_point(field_get:koinos.chain.exit_arguments.code)
  return _internal_code();
}
inline void exit_arguments::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void exit_arguments::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:koinos.chain.exit_arguments.code)
}

// .koinos.chain.result res = 2;
inline bool exit_arguments::_internal_has_res() const {
  return this != internal_default_instance() && res_ != nullptr;
}
inline bool exit_arguments::has_res() const {
  return _internal_has_res();
}
inline const ::koinos::chain::result& exit_arguments::_internal_res() const {
  const ::koinos::chain::result* p = res_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::result&>(
      ::koinos::chain::_result_default_instance_);
}
inline const ::koinos::chain::result& exit_arguments::res() const {
  // @@protoc_insertion_point(field_get:koinos.chain.exit_arguments.res)
  return _internal_res();
}
inline void exit_arguments::unsafe_arena_set_allocated_res(
    ::koinos::chain::result* res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(res_);
  }
  res_ = res;
  if (res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.exit_arguments.res)
}
inline ::koinos::chain::result* exit_arguments::release_res() {
  
  ::koinos::chain::result* temp = res_;
  res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::result* exit_arguments::unsafe_arena_release_res() {
  // @@protoc_insertion_point(field_release:koinos.chain.exit_arguments.res)
  
  ::koinos::chain::result* temp = res_;
  res_ = nullptr;
  return temp;
}
inline ::koinos::chain::result* exit_arguments::_internal_mutable_res() {
  
  if (res_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::result>(GetArenaForAllocation());
    res_ = p;
  }
  return res_;
}
inline ::koinos::chain::result* exit_arguments::mutable_res() {
  ::koinos::chain::result* _msg = _internal_mutable_res();
  // @@protoc_insertion_point(field_mutable:koinos.chain.exit_arguments.res)
  return _msg;
}
inline void exit_arguments::set_allocated_res(::koinos::chain::result* res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(res_);
  }
  if (res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(res));
    if (message_arena != submessage_arena) {
      res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, res, submessage_arena);
    }
    
  } else {
    
  }
  res_ = res;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.exit_arguments.res)
}

// -------------------------------------------------------------------

// exit_result

// -------------------------------------------------------------------

// get_contract_id_arguments

// -------------------------------------------------------------------

// get_contract_id_result

// bytes value = 1 [(.koinos.btype) = CONTRACT_ID];
inline void get_contract_id_result::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& get_contract_id_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_contract_id_result.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_contract_id_result::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_contract_id_result.value)
}
inline std::string* get_contract_id_result::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_contract_id_result.value)
  return _s;
}
inline const std::string& get_contract_id_result::_internal_value() const {
  return value_.Get();
}
inline void get_contract_id_result::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_contract_id_result::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_contract_id_result::release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_contract_id_result.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_contract_id_result::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_contract_id_result.value)
}

// -------------------------------------------------------------------

// get_caller_arguments

// -------------------------------------------------------------------

// get_caller_result

// .koinos.chain.caller_data value = 1;
inline bool get_caller_result::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool get_caller_result::has_value() const {
  return _internal_has_value();
}
inline const ::koinos::chain::caller_data& get_caller_result::_internal_value() const {
  const ::koinos::chain::caller_data* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::caller_data&>(
      ::koinos::chain::_caller_data_default_instance_);
}
inline const ::koinos::chain::caller_data& get_caller_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_caller_result.value)
  return _internal_value();
}
inline void get_caller_result::unsafe_arena_set_allocated_value(
    ::koinos::chain::caller_data* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_caller_result.value)
}
inline ::koinos::chain::caller_data* get_caller_result::release_value() {
  
  ::koinos::chain::caller_data* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::caller_data* get_caller_result::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_caller_result.value)
  
  ::koinos::chain::caller_data* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::koinos::chain::caller_data* get_caller_result::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::caller_data>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::koinos::chain::caller_data* get_caller_result::mutable_value() {
  ::koinos::chain::caller_data* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_caller_result.value)
  return _msg;
}
inline void get_caller_result::set_allocated_value(::koinos::chain::caller_data* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_caller_result.value)
}

// -------------------------------------------------------------------

// check_authority_arguments

// .koinos.chain.authorization_type type = 1;
inline void check_authority_arguments::clear_type() {
  type_ = 0;
}
inline ::koinos::chain::authorization_type check_authority_arguments::_internal_type() const {
  return static_cast< ::koinos::chain::authorization_type >(type_);
}
inline ::koinos::chain::authorization_type check_authority_arguments::type() const {
  // @@protoc_insertion_point(field_get:koinos.chain.check_authority_arguments.type)
  return _internal_type();
}
inline void check_authority_arguments::_internal_set_type(::koinos::chain::authorization_type value) {
  
  type_ = value;
}
inline void check_authority_arguments::set_type(::koinos::chain::authorization_type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:koinos.chain.check_authority_arguments.type)
}

// bytes account = 2 [(.koinos.btype) = ADDRESS];
inline void check_authority_arguments::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& check_authority_arguments::account() const {
  // @@protoc_insertion_point(field_get:koinos.chain.check_authority_arguments.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void check_authority_arguments::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.check_authority_arguments.account)
}
inline std::string* check_authority_arguments::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:koinos.chain.check_authority_arguments.account)
  return _s;
}
inline const std::string& check_authority_arguments::_internal_account() const {
  return account_.Get();
}
inline void check_authority_arguments::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* check_authority_arguments::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* check_authority_arguments::release_account() {
  // @@protoc_insertion_point(field_release:koinos.chain.check_authority_arguments.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void check_authority_arguments::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.check_authority_arguments.account)
}

// bytes data = 3;
inline void check_authority_arguments::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& check_authority_arguments::data() const {
  // @@protoc_insertion_point(field_get:koinos.chain.check_authority_arguments.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void check_authority_arguments::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.check_authority_arguments.data)
}
inline std::string* check_authority_arguments::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:koinos.chain.check_authority_arguments.data)
  return _s;
}
inline const std::string& check_authority_arguments::_internal_data() const {
  return data_.Get();
}
inline void check_authority_arguments::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* check_authority_arguments::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* check_authority_arguments::release_data() {
  // @@protoc_insertion_point(field_release:koinos.chain.check_authority_arguments.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void check_authority_arguments::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.check_authority_arguments.data)
}

// -------------------------------------------------------------------

// check_authority_result

// bool value = 1;
inline void check_authority_result::clear_value() {
  value_ = false;
}
inline bool check_authority_result::_internal_value() const {
  return value_;
}
inline bool check_authority_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.check_authority_result.value)
  return _internal_value();
}
inline void check_authority_result::_internal_set_value(bool value) {
  
  value_ = value;
}
inline void check_authority_result::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.check_authority_result.value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chain
}  // namespace koinos

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::koinos::chain::system_authorization_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::koinos::chain::system_authorization_type>() {
  return ::koinos::chain::system_authorization_type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_koinos_2fchain_2fsystem_5fcalls_2eproto
