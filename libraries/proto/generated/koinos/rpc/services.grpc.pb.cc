// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: koinos/rpc/services.proto

#include "koinos/rpc/services.pb.h"
#include "koinos/rpc/services.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace koinos {
namespace services {

static const char* koinos_method_names[] = {
  "/koinos.services.koinos/get_account_history",
  "/koinos.services.koinos/get_blocks_by_id",
  "/koinos.services.koinos/get_blocks_by_height",
  "/koinos.services.koinos/get_highest_block",
  "/koinos.services.koinos/submit_block",
  "/koinos.services.koinos/submit_transaction",
  "/koinos.services.koinos/get_head_info",
  "/koinos.services.koinos/get_chain_id",
  "/koinos.services.koinos/get_fork_heads",
  "/koinos.services.koinos/read_contract",
  "/koinos.services.koinos/get_account_nonce",
  "/koinos.services.koinos/get_account_rc",
  "/koinos.services.koinos/get_resource_limits",
  "/koinos.services.koinos/invoke_system_call",
  "/koinos.services.koinos/get_contract_meta",
  "/koinos.services.koinos/get_pending_transactions",
  "/koinos.services.koinos/check_pending_account_resources",
  "/koinos.services.koinos/get_gossip_status",
  "/koinos.services.koinos/get_transactions_by_id",
};

std::unique_ptr< koinos::Stub> koinos::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< koinos::Stub> stub(new koinos::Stub(channel));
  return stub;
}

koinos::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_get_account_history_(koinos_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_blocks_by_id_(koinos_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_blocks_by_height_(koinos_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_highest_block_(koinos_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_submit_block_(koinos_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_submit_transaction_(koinos_method_names[5], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_head_info_(koinos_method_names[6], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_chain_id_(koinos_method_names[7], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_fork_heads_(koinos_method_names[8], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_read_contract_(koinos_method_names[9], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_account_nonce_(koinos_method_names[10], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_account_rc_(koinos_method_names[11], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_resource_limits_(koinos_method_names[12], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_invoke_system_call_(koinos_method_names[13], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_contract_meta_(koinos_method_names[14], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_pending_transactions_(koinos_method_names[15], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_check_pending_account_resources_(koinos_method_names[16], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_gossip_status_(koinos_method_names[17], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_transactions_by_id_(koinos_method_names[18], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status koinos::Stub::get_account_history(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request& request, ::koinos::rpc::account_history::get_account_history_response* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_account_history_, context, request, response);
}

void koinos::Stub::experimental_async::get_account_history(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request* request, ::koinos::rpc::account_history::get_account_history_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_account_history_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_account_history(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::account_history::get_account_history_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_account_history_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_account_history(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request* request, ::koinos::rpc::account_history::get_account_history_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_account_history_, context, request, response, reactor);
}

void koinos::Stub::experimental_async::get_account_history(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::account_history::get_account_history_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_account_history_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::account_history::get_account_history_response>* koinos::Stub::Asyncget_account_historyRaw(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::account_history::get_account_history_response>::Create(channel_.get(), cq, rpcmethod_get_account_history_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::account_history::get_account_history_response>* koinos::Stub::PrepareAsyncget_account_historyRaw(::grpc::ClientContext* context, const ::koinos::rpc::account_history::get_account_history_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::account_history::get_account_history_response>::Create(channel_.get(), cq, rpcmethod_get_account_history_, context, request, false);
}

::grpc::Status koinos::Stub::get_blocks_by_id(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request& request, ::koinos::rpc::block_store::get_blocks_by_id_response* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_blocks_by_id_, context, request, response);
}

void koinos::Stub::experimental_async::get_blocks_by_id(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request* request, ::koinos::rpc::block_store::get_blocks_by_id_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_blocks_by_id_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_blocks_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_blocks_by_id_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_blocks_by_id_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_blocks_by_id(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request* request, ::koinos::rpc::block_store::get_blocks_by_id_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_blocks_by_id_, context, request, response, reactor);
}

void koinos::Stub::experimental_async::get_blocks_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_blocks_by_id_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_blocks_by_id_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_blocks_by_id_response>* koinos::Stub::Asyncget_blocks_by_idRaw(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::block_store::get_blocks_by_id_response>::Create(channel_.get(), cq, rpcmethod_get_blocks_by_id_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_blocks_by_id_response>* koinos::Stub::PrepareAsyncget_blocks_by_idRaw(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::block_store::get_blocks_by_id_response>::Create(channel_.get(), cq, rpcmethod_get_blocks_by_id_, context, request, false);
}

::grpc::Status koinos::Stub::get_blocks_by_height(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request& request, ::koinos::rpc::block_store::get_blocks_by_height_response* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_blocks_by_height_, context, request, response);
}

void koinos::Stub::experimental_async::get_blocks_by_height(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request* request, ::koinos::rpc::block_store::get_blocks_by_height_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_blocks_by_height_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_blocks_by_height(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_blocks_by_height_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_blocks_by_height_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_blocks_by_height(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request* request, ::koinos::rpc::block_store::get_blocks_by_height_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_blocks_by_height_, context, request, response, reactor);
}

void koinos::Stub::experimental_async::get_blocks_by_height(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_blocks_by_height_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_blocks_by_height_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_blocks_by_height_response>* koinos::Stub::Asyncget_blocks_by_heightRaw(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::block_store::get_blocks_by_height_response>::Create(channel_.get(), cq, rpcmethod_get_blocks_by_height_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_blocks_by_height_response>* koinos::Stub::PrepareAsyncget_blocks_by_heightRaw(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::block_store::get_blocks_by_height_response>::Create(channel_.get(), cq, rpcmethod_get_blocks_by_height_, context, request, false);
}

::grpc::Status koinos::Stub::get_highest_block(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request& request, ::koinos::rpc::block_store::get_highest_block_response* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_highest_block_, context, request, response);
}

void koinos::Stub::experimental_async::get_highest_block(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request* request, ::koinos::rpc::block_store::get_highest_block_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_highest_block_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_highest_block(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_highest_block_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_highest_block_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_highest_block(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request* request, ::koinos::rpc::block_store::get_highest_block_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_highest_block_, context, request, response, reactor);
}

void koinos::Stub::experimental_async::get_highest_block(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::block_store::get_highest_block_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_highest_block_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_highest_block_response>* koinos::Stub::Asyncget_highest_blockRaw(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::block_store::get_highest_block_response>::Create(channel_.get(), cq, rpcmethod_get_highest_block_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::block_store::get_highest_block_response>* koinos::Stub::PrepareAsyncget_highest_blockRaw(::grpc::ClientContext* context, const ::koinos::rpc::block_store::get_highest_block_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::block_store::get_highest_block_response>::Create(channel_.get(), cq, rpcmethod_get_highest_block_, context, request, false);
}

::grpc::Status koinos::Stub::submit_block(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request& request, ::koinos::rpc::chain::submit_block_response* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_submit_block_, context, request, response);
}

void koinos::Stub::experimental_async::submit_block(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request* request, ::koinos::rpc::chain::submit_block_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_submit_block_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::submit_block(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::submit_block_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_submit_block_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::submit_block(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request* request, ::koinos::rpc::chain::submit_block_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_submit_block_, context, request, response, reactor);
}

void koinos::Stub::experimental_async::submit_block(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::submit_block_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_submit_block_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::submit_block_response>* koinos::Stub::Asyncsubmit_blockRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::chain::submit_block_response>::Create(channel_.get(), cq, rpcmethod_submit_block_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::submit_block_response>* koinos::Stub::PrepareAsyncsubmit_blockRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_block_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::chain::submit_block_response>::Create(channel_.get(), cq, rpcmethod_submit_block_, context, request, false);
}

::grpc::Status koinos::Stub::submit_transaction(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request& request, ::koinos::rpc::chain::submit_transaction_response* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_submit_transaction_, context, request, response);
}

void koinos::Stub::experimental_async::submit_transaction(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request* request, ::koinos::rpc::chain::submit_transaction_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_submit_transaction_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::submit_transaction(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::submit_transaction_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_submit_transaction_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::submit_transaction(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request* request, ::koinos::rpc::chain::submit_transaction_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_submit_transaction_, context, request, response, reactor);
}

void koinos::Stub::experimental_async::submit_transaction(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::submit_transaction_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_submit_transaction_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::submit_transaction_response>* koinos::Stub::Asyncsubmit_transactionRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::chain::submit_transaction_response>::Create(channel_.get(), cq, rpcmethod_submit_transaction_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::submit_transaction_response>* koinos::Stub::PrepareAsyncsubmit_transactionRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::submit_transaction_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::chain::submit_transaction_response>::Create(channel_.get(), cq, rpcmethod_submit_transaction_, context, request, false);
}

::grpc::Status koinos::Stub::get_head_info(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request& request, ::koinos::rpc::chain::get_head_info_response* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_head_info_, context, request, response);
}

void koinos::Stub::experimental_async::get_head_info(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request* request, ::koinos::rpc::chain::get_head_info_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_head_info_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_head_info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_head_info_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_head_info_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_head_info(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request* request, ::koinos::rpc::chain::get_head_info_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_head_info_, context, request, response, reactor);
}

void koinos::Stub::experimental_async::get_head_info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_head_info_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_head_info_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_head_info_response>* koinos::Stub::Asyncget_head_infoRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::chain::get_head_info_response>::Create(channel_.get(), cq, rpcmethod_get_head_info_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_head_info_response>* koinos::Stub::PrepareAsyncget_head_infoRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_head_info_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::chain::get_head_info_response>::Create(channel_.get(), cq, rpcmethod_get_head_info_, context, request, false);
}

::grpc::Status koinos::Stub::get_chain_id(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request& request, ::koinos::rpc::chain::get_chain_id_response* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_chain_id_, context, request, response);
}

void koinos::Stub::experimental_async::get_chain_id(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request* request, ::koinos::rpc::chain::get_chain_id_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_chain_id_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_chain_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_chain_id_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_chain_id_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_chain_id(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request* request, ::koinos::rpc::chain::get_chain_id_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_chain_id_, context, request, response, reactor);
}

void koinos::Stub::experimental_async::get_chain_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_chain_id_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_chain_id_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_chain_id_response>* koinos::Stub::Asyncget_chain_idRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::chain::get_chain_id_response>::Create(channel_.get(), cq, rpcmethod_get_chain_id_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_chain_id_response>* koinos::Stub::PrepareAsyncget_chain_idRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_chain_id_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::chain::get_chain_id_response>::Create(channel_.get(), cq, rpcmethod_get_chain_id_, context, request, false);
}

::grpc::Status koinos::Stub::get_fork_heads(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request& request, ::koinos::rpc::chain::get_fork_heads_response* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_fork_heads_, context, request, response);
}

void koinos::Stub::experimental_async::get_fork_heads(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request* request, ::koinos::rpc::chain::get_fork_heads_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_fork_heads_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_fork_heads(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_fork_heads_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_fork_heads_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_fork_heads(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request* request, ::koinos::rpc::chain::get_fork_heads_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_fork_heads_, context, request, response, reactor);
}

void koinos::Stub::experimental_async::get_fork_heads(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_fork_heads_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_fork_heads_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_fork_heads_response>* koinos::Stub::Asyncget_fork_headsRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::chain::get_fork_heads_response>::Create(channel_.get(), cq, rpcmethod_get_fork_heads_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_fork_heads_response>* koinos::Stub::PrepareAsyncget_fork_headsRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_fork_heads_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::chain::get_fork_heads_response>::Create(channel_.get(), cq, rpcmethod_get_fork_heads_, context, request, false);
}

::grpc::Status koinos::Stub::read_contract(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request& request, ::koinos::rpc::chain::read_contract_response* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_read_contract_, context, request, response);
}

void koinos::Stub::experimental_async::read_contract(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request* request, ::koinos::rpc::chain::read_contract_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_read_contract_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::read_contract(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::read_contract_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_read_contract_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::read_contract(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request* request, ::koinos::rpc::chain::read_contract_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_read_contract_, context, request, response, reactor);
}

void koinos::Stub::experimental_async::read_contract(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::read_contract_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_read_contract_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::read_contract_response>* koinos::Stub::Asyncread_contractRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::chain::read_contract_response>::Create(channel_.get(), cq, rpcmethod_read_contract_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::read_contract_response>* koinos::Stub::PrepareAsyncread_contractRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::read_contract_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::chain::read_contract_response>::Create(channel_.get(), cq, rpcmethod_read_contract_, context, request, false);
}

::grpc::Status koinos::Stub::get_account_nonce(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request& request, ::koinos::rpc::chain::get_account_nonce_response* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_account_nonce_, context, request, response);
}

void koinos::Stub::experimental_async::get_account_nonce(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request* request, ::koinos::rpc::chain::get_account_nonce_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_account_nonce_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_account_nonce(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_account_nonce_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_account_nonce_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_account_nonce(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request* request, ::koinos::rpc::chain::get_account_nonce_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_account_nonce_, context, request, response, reactor);
}

void koinos::Stub::experimental_async::get_account_nonce(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_account_nonce_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_account_nonce_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_account_nonce_response>* koinos::Stub::Asyncget_account_nonceRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::chain::get_account_nonce_response>::Create(channel_.get(), cq, rpcmethod_get_account_nonce_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_account_nonce_response>* koinos::Stub::PrepareAsyncget_account_nonceRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_nonce_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::chain::get_account_nonce_response>::Create(channel_.get(), cq, rpcmethod_get_account_nonce_, context, request, false);
}

::grpc::Status koinos::Stub::get_account_rc(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request& request, ::koinos::rpc::chain::get_account_rc_response* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_account_rc_, context, request, response);
}

void koinos::Stub::experimental_async::get_account_rc(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request* request, ::koinos::rpc::chain::get_account_rc_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_account_rc_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_account_rc(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_account_rc_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_account_rc_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_account_rc(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request* request, ::koinos::rpc::chain::get_account_rc_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_account_rc_, context, request, response, reactor);
}

void koinos::Stub::experimental_async::get_account_rc(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_account_rc_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_account_rc_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_account_rc_response>* koinos::Stub::Asyncget_account_rcRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::chain::get_account_rc_response>::Create(channel_.get(), cq, rpcmethod_get_account_rc_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_account_rc_response>* koinos::Stub::PrepareAsyncget_account_rcRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_account_rc_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::chain::get_account_rc_response>::Create(channel_.get(), cq, rpcmethod_get_account_rc_, context, request, false);
}

::grpc::Status koinos::Stub::get_resource_limits(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request& request, ::koinos::rpc::chain::get_resource_limits_response* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_resource_limits_, context, request, response);
}

void koinos::Stub::experimental_async::get_resource_limits(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request* request, ::koinos::rpc::chain::get_resource_limits_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_resource_limits_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_resource_limits(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_resource_limits_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_resource_limits_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_resource_limits(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request* request, ::koinos::rpc::chain::get_resource_limits_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_resource_limits_, context, request, response, reactor);
}

void koinos::Stub::experimental_async::get_resource_limits(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::get_resource_limits_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_resource_limits_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_resource_limits_response>* koinos::Stub::Asyncget_resource_limitsRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::chain::get_resource_limits_response>::Create(channel_.get(), cq, rpcmethod_get_resource_limits_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::get_resource_limits_response>* koinos::Stub::PrepareAsyncget_resource_limitsRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::get_resource_limits_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::chain::get_resource_limits_response>::Create(channel_.get(), cq, rpcmethod_get_resource_limits_, context, request, false);
}

::grpc::Status koinos::Stub::invoke_system_call(::grpc::ClientContext* context, const ::koinos::rpc::chain::invoke_system_call_request& request, ::koinos::rpc::chain::invoke_system_call_response* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_invoke_system_call_, context, request, response);
}

void koinos::Stub::experimental_async::invoke_system_call(::grpc::ClientContext* context, const ::koinos::rpc::chain::invoke_system_call_request* request, ::koinos::rpc::chain::invoke_system_call_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_invoke_system_call_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::invoke_system_call(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::invoke_system_call_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_invoke_system_call_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::invoke_system_call(::grpc::ClientContext* context, const ::koinos::rpc::chain::invoke_system_call_request* request, ::koinos::rpc::chain::invoke_system_call_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_invoke_system_call_, context, request, response, reactor);
}

void koinos::Stub::experimental_async::invoke_system_call(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::chain::invoke_system_call_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_invoke_system_call_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::invoke_system_call_response>* koinos::Stub::Asyncinvoke_system_callRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::invoke_system_call_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::chain::invoke_system_call_response>::Create(channel_.get(), cq, rpcmethod_invoke_system_call_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::chain::invoke_system_call_response>* koinos::Stub::PrepareAsyncinvoke_system_callRaw(::grpc::ClientContext* context, const ::koinos::rpc::chain::invoke_system_call_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::chain::invoke_system_call_response>::Create(channel_.get(), cq, rpcmethod_invoke_system_call_, context, request, false);
}

::grpc::Status koinos::Stub::get_contract_meta(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request& request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_contract_meta_, context, request, response);
}

void koinos::Stub::experimental_async::get_contract_meta(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request* request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_contract_meta_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_contract_meta(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_contract_meta_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_contract_meta(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request* request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_contract_meta_, context, request, response, reactor);
}

void koinos::Stub::experimental_async::get_contract_meta(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_contract_meta_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::contract_meta_store::get_contract_meta_response>* koinos::Stub::Asyncget_contract_metaRaw(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::contract_meta_store::get_contract_meta_response>::Create(channel_.get(), cq, rpcmethod_get_contract_meta_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::contract_meta_store::get_contract_meta_response>* koinos::Stub::PrepareAsyncget_contract_metaRaw(::grpc::ClientContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::contract_meta_store::get_contract_meta_response>::Create(channel_.get(), cq, rpcmethod_get_contract_meta_, context, request, false);
}

::grpc::Status koinos::Stub::get_pending_transactions(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request& request, ::koinos::rpc::mempool::get_pending_transactions_response* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_pending_transactions_, context, request, response);
}

void koinos::Stub::experimental_async::get_pending_transactions(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request* request, ::koinos::rpc::mempool::get_pending_transactions_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_pending_transactions_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_pending_transactions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::mempool::get_pending_transactions_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_pending_transactions_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_pending_transactions(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request* request, ::koinos::rpc::mempool::get_pending_transactions_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_pending_transactions_, context, request, response, reactor);
}

void koinos::Stub::experimental_async::get_pending_transactions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::mempool::get_pending_transactions_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_pending_transactions_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::mempool::get_pending_transactions_response>* koinos::Stub::Asyncget_pending_transactionsRaw(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::mempool::get_pending_transactions_response>::Create(channel_.get(), cq, rpcmethod_get_pending_transactions_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::mempool::get_pending_transactions_response>* koinos::Stub::PrepareAsyncget_pending_transactionsRaw(::grpc::ClientContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::mempool::get_pending_transactions_response>::Create(channel_.get(), cq, rpcmethod_get_pending_transactions_, context, request, false);
}

::grpc::Status koinos::Stub::check_pending_account_resources(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request& request, ::koinos::rpc::mempool::check_pending_account_resources_response* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_check_pending_account_resources_, context, request, response);
}

void koinos::Stub::experimental_async::check_pending_account_resources(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request* request, ::koinos::rpc::mempool::check_pending_account_resources_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_check_pending_account_resources_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::check_pending_account_resources(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::mempool::check_pending_account_resources_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_check_pending_account_resources_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::check_pending_account_resources(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request* request, ::koinos::rpc::mempool::check_pending_account_resources_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_check_pending_account_resources_, context, request, response, reactor);
}

void koinos::Stub::experimental_async::check_pending_account_resources(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::mempool::check_pending_account_resources_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_check_pending_account_resources_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::mempool::check_pending_account_resources_response>* koinos::Stub::Asynccheck_pending_account_resourcesRaw(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::mempool::check_pending_account_resources_response>::Create(channel_.get(), cq, rpcmethod_check_pending_account_resources_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::mempool::check_pending_account_resources_response>* koinos::Stub::PrepareAsynccheck_pending_account_resourcesRaw(::grpc::ClientContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::mempool::check_pending_account_resources_response>::Create(channel_.get(), cq, rpcmethod_check_pending_account_resources_, context, request, false);
}

::grpc::Status koinos::Stub::get_gossip_status(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request& request, ::koinos::rpc::p2p::get_gossip_status_response* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_gossip_status_, context, request, response);
}

void koinos::Stub::experimental_async::get_gossip_status(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request* request, ::koinos::rpc::p2p::get_gossip_status_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_gossip_status_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_gossip_status(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::p2p::get_gossip_status_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_gossip_status_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_gossip_status(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request* request, ::koinos::rpc::p2p::get_gossip_status_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_gossip_status_, context, request, response, reactor);
}

void koinos::Stub::experimental_async::get_gossip_status(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::p2p::get_gossip_status_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_gossip_status_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::p2p::get_gossip_status_response>* koinos::Stub::Asyncget_gossip_statusRaw(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::p2p::get_gossip_status_response>::Create(channel_.get(), cq, rpcmethod_get_gossip_status_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::p2p::get_gossip_status_response>* koinos::Stub::PrepareAsyncget_gossip_statusRaw(::grpc::ClientContext* context, const ::koinos::rpc::p2p::get_gossip_status_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::p2p::get_gossip_status_response>::Create(channel_.get(), cq, rpcmethod_get_gossip_status_, context, request, false);
}

::grpc::Status koinos::Stub::get_transactions_by_id(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request& request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_transactions_by_id_, context, request, response);
}

void koinos::Stub::experimental_async::get_transactions_by_id(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request* request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_transactions_by_id_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_transactions_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_transactions_by_id_, context, request, response, std::move(f));
}

void koinos::Stub::experimental_async::get_transactions_by_id(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request* request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_transactions_by_id_, context, request, response, reactor);
}

void koinos::Stub::experimental_async::get_transactions_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_transactions_by_id_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::transaction_store::get_transactions_by_id_response>* koinos::Stub::Asyncget_transactions_by_idRaw(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::transaction_store::get_transactions_by_id_response>::Create(channel_.get(), cq, rpcmethod_get_transactions_by_id_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::koinos::rpc::transaction_store::get_transactions_by_id_response>* koinos::Stub::PrepareAsyncget_transactions_by_idRaw(::grpc::ClientContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::koinos::rpc::transaction_store::get_transactions_by_id_response>::Create(channel_.get(), cq, rpcmethod_get_transactions_by_id_, context, request, false);
}

koinos::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      koinos_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< koinos::Service, ::koinos::rpc::account_history::get_account_history_request, ::koinos::rpc::account_history::get_account_history_response>(
          [](koinos::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::koinos::rpc::account_history::get_account_history_request* req,
             ::koinos::rpc::account_history::get_account_history_response* resp) {
               return service->get_account_history(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      koinos_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< koinos::Service, ::koinos::rpc::block_store::get_blocks_by_id_request, ::koinos::rpc::block_store::get_blocks_by_id_response>(
          [](koinos::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::koinos::rpc::block_store::get_blocks_by_id_request* req,
             ::koinos::rpc::block_store::get_blocks_by_id_response* resp) {
               return service->get_blocks_by_id(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      koinos_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< koinos::Service, ::koinos::rpc::block_store::get_blocks_by_height_request, ::koinos::rpc::block_store::get_blocks_by_height_response>(
          [](koinos::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::koinos::rpc::block_store::get_blocks_by_height_request* req,
             ::koinos::rpc::block_store::get_blocks_by_height_response* resp) {
               return service->get_blocks_by_height(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      koinos_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< koinos::Service, ::koinos::rpc::block_store::get_highest_block_request, ::koinos::rpc::block_store::get_highest_block_response>(
          [](koinos::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::koinos::rpc::block_store::get_highest_block_request* req,
             ::koinos::rpc::block_store::get_highest_block_response* resp) {
               return service->get_highest_block(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      koinos_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< koinos::Service, ::koinos::rpc::chain::submit_block_request, ::koinos::rpc::chain::submit_block_response>(
          [](koinos::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::koinos::rpc::chain::submit_block_request* req,
             ::koinos::rpc::chain::submit_block_response* resp) {
               return service->submit_block(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      koinos_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< koinos::Service, ::koinos::rpc::chain::submit_transaction_request, ::koinos::rpc::chain::submit_transaction_response>(
          [](koinos::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::koinos::rpc::chain::submit_transaction_request* req,
             ::koinos::rpc::chain::submit_transaction_response* resp) {
               return service->submit_transaction(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      koinos_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< koinos::Service, ::koinos::rpc::chain::get_head_info_request, ::koinos::rpc::chain::get_head_info_response>(
          [](koinos::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::koinos::rpc::chain::get_head_info_request* req,
             ::koinos::rpc::chain::get_head_info_response* resp) {
               return service->get_head_info(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      koinos_method_names[7],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< koinos::Service, ::koinos::rpc::chain::get_chain_id_request, ::koinos::rpc::chain::get_chain_id_response>(
          [](koinos::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::koinos::rpc::chain::get_chain_id_request* req,
             ::koinos::rpc::chain::get_chain_id_response* resp) {
               return service->get_chain_id(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      koinos_method_names[8],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< koinos::Service, ::koinos::rpc::chain::get_fork_heads_request, ::koinos::rpc::chain::get_fork_heads_response>(
          [](koinos::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::koinos::rpc::chain::get_fork_heads_request* req,
             ::koinos::rpc::chain::get_fork_heads_response* resp) {
               return service->get_fork_heads(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      koinos_method_names[9],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< koinos::Service, ::koinos::rpc::chain::read_contract_request, ::koinos::rpc::chain::read_contract_response>(
          [](koinos::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::koinos::rpc::chain::read_contract_request* req,
             ::koinos::rpc::chain::read_contract_response* resp) {
               return service->read_contract(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      koinos_method_names[10],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< koinos::Service, ::koinos::rpc::chain::get_account_nonce_request, ::koinos::rpc::chain::get_account_nonce_response>(
          [](koinos::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::koinos::rpc::chain::get_account_nonce_request* req,
             ::koinos::rpc::chain::get_account_nonce_response* resp) {
               return service->get_account_nonce(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      koinos_method_names[11],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< koinos::Service, ::koinos::rpc::chain::get_account_rc_request, ::koinos::rpc::chain::get_account_rc_response>(
          [](koinos::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::koinos::rpc::chain::get_account_rc_request* req,
             ::koinos::rpc::chain::get_account_rc_response* resp) {
               return service->get_account_rc(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      koinos_method_names[12],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< koinos::Service, ::koinos::rpc::chain::get_resource_limits_request, ::koinos::rpc::chain::get_resource_limits_response>(
          [](koinos::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::koinos::rpc::chain::get_resource_limits_request* req,
             ::koinos::rpc::chain::get_resource_limits_response* resp) {
               return service->get_resource_limits(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      koinos_method_names[13],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< koinos::Service, ::koinos::rpc::chain::invoke_system_call_request, ::koinos::rpc::chain::invoke_system_call_response>(
          [](koinos::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::koinos::rpc::chain::invoke_system_call_request* req,
             ::koinos::rpc::chain::invoke_system_call_response* resp) {
               return service->invoke_system_call(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      koinos_method_names[14],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< koinos::Service, ::koinos::rpc::contract_meta_store::get_contract_meta_request, ::koinos::rpc::contract_meta_store::get_contract_meta_response>(
          [](koinos::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::koinos::rpc::contract_meta_store::get_contract_meta_request* req,
             ::koinos::rpc::contract_meta_store::get_contract_meta_response* resp) {
               return service->get_contract_meta(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      koinos_method_names[15],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< koinos::Service, ::koinos::rpc::mempool::get_pending_transactions_request, ::koinos::rpc::mempool::get_pending_transactions_response>(
          [](koinos::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::koinos::rpc::mempool::get_pending_transactions_request* req,
             ::koinos::rpc::mempool::get_pending_transactions_response* resp) {
               return service->get_pending_transactions(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      koinos_method_names[16],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< koinos::Service, ::koinos::rpc::mempool::check_pending_account_resources_request, ::koinos::rpc::mempool::check_pending_account_resources_response>(
          [](koinos::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::koinos::rpc::mempool::check_pending_account_resources_request* req,
             ::koinos::rpc::mempool::check_pending_account_resources_response* resp) {
               return service->check_pending_account_resources(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      koinos_method_names[17],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< koinos::Service, ::koinos::rpc::p2p::get_gossip_status_request, ::koinos::rpc::p2p::get_gossip_status_response>(
          [](koinos::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::koinos::rpc::p2p::get_gossip_status_request* req,
             ::koinos::rpc::p2p::get_gossip_status_response* resp) {
               return service->get_gossip_status(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      koinos_method_names[18],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< koinos::Service, ::koinos::rpc::transaction_store::get_transactions_by_id_request, ::koinos::rpc::transaction_store::get_transactions_by_id_response>(
          [](koinos::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::koinos::rpc::transaction_store::get_transactions_by_id_request* req,
             ::koinos::rpc::transaction_store::get_transactions_by_id_response* resp) {
               return service->get_transactions_by_id(ctx, req, resp);
             }, this)));
}

koinos::Service::~Service() {
}

::grpc::Status koinos::Service::get_account_history(::grpc::ServerContext* context, const ::koinos::rpc::account_history::get_account_history_request* request, ::koinos::rpc::account_history::get_account_history_response* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status koinos::Service::get_blocks_by_id(::grpc::ServerContext* context, const ::koinos::rpc::block_store::get_blocks_by_id_request* request, ::koinos::rpc::block_store::get_blocks_by_id_response* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status koinos::Service::get_blocks_by_height(::grpc::ServerContext* context, const ::koinos::rpc::block_store::get_blocks_by_height_request* request, ::koinos::rpc::block_store::get_blocks_by_height_response* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status koinos::Service::get_highest_block(::grpc::ServerContext* context, const ::koinos::rpc::block_store::get_highest_block_request* request, ::koinos::rpc::block_store::get_highest_block_response* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status koinos::Service::submit_block(::grpc::ServerContext* context, const ::koinos::rpc::chain::submit_block_request* request, ::koinos::rpc::chain::submit_block_response* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status koinos::Service::submit_transaction(::grpc::ServerContext* context, const ::koinos::rpc::chain::submit_transaction_request* request, ::koinos::rpc::chain::submit_transaction_response* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status koinos::Service::get_head_info(::grpc::ServerContext* context, const ::koinos::rpc::chain::get_head_info_request* request, ::koinos::rpc::chain::get_head_info_response* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status koinos::Service::get_chain_id(::grpc::ServerContext* context, const ::koinos::rpc::chain::get_chain_id_request* request, ::koinos::rpc::chain::get_chain_id_response* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status koinos::Service::get_fork_heads(::grpc::ServerContext* context, const ::koinos::rpc::chain::get_fork_heads_request* request, ::koinos::rpc::chain::get_fork_heads_response* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status koinos::Service::read_contract(::grpc::ServerContext* context, const ::koinos::rpc::chain::read_contract_request* request, ::koinos::rpc::chain::read_contract_response* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status koinos::Service::get_account_nonce(::grpc::ServerContext* context, const ::koinos::rpc::chain::get_account_nonce_request* request, ::koinos::rpc::chain::get_account_nonce_response* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status koinos::Service::get_account_rc(::grpc::ServerContext* context, const ::koinos::rpc::chain::get_account_rc_request* request, ::koinos::rpc::chain::get_account_rc_response* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status koinos::Service::get_resource_limits(::grpc::ServerContext* context, const ::koinos::rpc::chain::get_resource_limits_request* request, ::koinos::rpc::chain::get_resource_limits_response* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status koinos::Service::invoke_system_call(::grpc::ServerContext* context, const ::koinos::rpc::chain::invoke_system_call_request* request, ::koinos::rpc::chain::invoke_system_call_response* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status koinos::Service::get_contract_meta(::grpc::ServerContext* context, const ::koinos::rpc::contract_meta_store::get_contract_meta_request* request, ::koinos::rpc::contract_meta_store::get_contract_meta_response* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status koinos::Service::get_pending_transactions(::grpc::ServerContext* context, const ::koinos::rpc::mempool::get_pending_transactions_request* request, ::koinos::rpc::mempool::get_pending_transactions_response* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status koinos::Service::check_pending_account_resources(::grpc::ServerContext* context, const ::koinos::rpc::mempool::check_pending_account_resources_request* request, ::koinos::rpc::mempool::check_pending_account_resources_response* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status koinos::Service::get_gossip_status(::grpc::ServerContext* context, const ::koinos::rpc::p2p::get_gossip_status_request* request, ::koinos::rpc::p2p::get_gossip_status_response* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status koinos::Service::get_transactions_by_id(::grpc::ServerContext* context, const ::koinos::rpc::transaction_store::get_transactions_by_id_request* request, ::koinos::rpc::transaction_store::get_transactions_by_id_response* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace koinos
}  // namespace services

