// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: koinos/chain/chain.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_koinos_2fchain_2fchain_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_koinos_2fchain_2fchain_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "koinos/common.pb.h"
#include "koinos/protocol/protocol.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_koinos_2fchain_2fchain_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_koinos_2fchain_2fchain_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[70]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_koinos_2fchain_2fchain_2eproto;
namespace koinos {
namespace chain {
class apply_block_arguments;
struct apply_block_argumentsDefaultTypeInternal;
extern apply_block_argumentsDefaultTypeInternal _apply_block_arguments_default_instance_;
class apply_block_result;
struct apply_block_resultDefaultTypeInternal;
extern apply_block_resultDefaultTypeInternal _apply_block_result_default_instance_;
class apply_call_contract_operation_arguments;
struct apply_call_contract_operation_argumentsDefaultTypeInternal;
extern apply_call_contract_operation_argumentsDefaultTypeInternal _apply_call_contract_operation_arguments_default_instance_;
class apply_call_contract_operation_result;
struct apply_call_contract_operation_resultDefaultTypeInternal;
extern apply_call_contract_operation_resultDefaultTypeInternal _apply_call_contract_operation_result_default_instance_;
class apply_set_system_call_operation_arguments;
struct apply_set_system_call_operation_argumentsDefaultTypeInternal;
extern apply_set_system_call_operation_argumentsDefaultTypeInternal _apply_set_system_call_operation_arguments_default_instance_;
class apply_set_system_call_operation_result;
struct apply_set_system_call_operation_resultDefaultTypeInternal;
extern apply_set_system_call_operation_resultDefaultTypeInternal _apply_set_system_call_operation_result_default_instance_;
class apply_transaction_arguments;
struct apply_transaction_argumentsDefaultTypeInternal;
extern apply_transaction_argumentsDefaultTypeInternal _apply_transaction_arguments_default_instance_;
class apply_transaction_result;
struct apply_transaction_resultDefaultTypeInternal;
extern apply_transaction_resultDefaultTypeInternal _apply_transaction_result_default_instance_;
class apply_upload_contract_operation_arguments;
struct apply_upload_contract_operation_argumentsDefaultTypeInternal;
extern apply_upload_contract_operation_argumentsDefaultTypeInternal _apply_upload_contract_operation_arguments_default_instance_;
class apply_upload_contract_operation_result;
struct apply_upload_contract_operation_resultDefaultTypeInternal;
extern apply_upload_contract_operation_resultDefaultTypeInternal _apply_upload_contract_operation_result_default_instance_;
class call_contract_arguments;
struct call_contract_argumentsDefaultTypeInternal;
extern call_contract_argumentsDefaultTypeInternal _call_contract_arguments_default_instance_;
class call_contract_result;
struct call_contract_resultDefaultTypeInternal;
extern call_contract_resultDefaultTypeInternal _call_contract_result_default_instance_;
class caller_data;
struct caller_dataDefaultTypeInternal;
extern caller_dataDefaultTypeInternal _caller_data_default_instance_;
class consume_account_rc_arguments;
struct consume_account_rc_argumentsDefaultTypeInternal;
extern consume_account_rc_argumentsDefaultTypeInternal _consume_account_rc_arguments_default_instance_;
class consume_account_rc_result;
struct consume_account_rc_resultDefaultTypeInternal;
extern consume_account_rc_resultDefaultTypeInternal _consume_account_rc_result_default_instance_;
class consume_block_resources_arguments;
struct consume_block_resources_argumentsDefaultTypeInternal;
extern consume_block_resources_argumentsDefaultTypeInternal _consume_block_resources_arguments_default_instance_;
class consume_block_resources_result;
struct consume_block_resources_resultDefaultTypeInternal;
extern consume_block_resources_resultDefaultTypeInternal _consume_block_resources_result_default_instance_;
class exit_contract_arguments;
struct exit_contract_argumentsDefaultTypeInternal;
extern exit_contract_argumentsDefaultTypeInternal _exit_contract_arguments_default_instance_;
class exit_contract_result;
struct exit_contract_resultDefaultTypeInternal;
extern exit_contract_resultDefaultTypeInternal _exit_contract_result_default_instance_;
class get_account_nonce_arguments;
struct get_account_nonce_argumentsDefaultTypeInternal;
extern get_account_nonce_argumentsDefaultTypeInternal _get_account_nonce_arguments_default_instance_;
class get_account_nonce_result;
struct get_account_nonce_resultDefaultTypeInternal;
extern get_account_nonce_resultDefaultTypeInternal _get_account_nonce_result_default_instance_;
class get_account_rc_arguments;
struct get_account_rc_argumentsDefaultTypeInternal;
extern get_account_rc_argumentsDefaultTypeInternal _get_account_rc_arguments_default_instance_;
class get_account_rc_result;
struct get_account_rc_resultDefaultTypeInternal;
extern get_account_rc_resultDefaultTypeInternal _get_account_rc_result_default_instance_;
class get_caller_arguments;
struct get_caller_argumentsDefaultTypeInternal;
extern get_caller_argumentsDefaultTypeInternal _get_caller_arguments_default_instance_;
class get_caller_result;
struct get_caller_resultDefaultTypeInternal;
extern get_caller_resultDefaultTypeInternal _get_caller_result_default_instance_;
class get_contract_arguments_arguments;
struct get_contract_arguments_argumentsDefaultTypeInternal;
extern get_contract_arguments_argumentsDefaultTypeInternal _get_contract_arguments_arguments_default_instance_;
class get_contract_arguments_result;
struct get_contract_arguments_resultDefaultTypeInternal;
extern get_contract_arguments_resultDefaultTypeInternal _get_contract_arguments_result_default_instance_;
class get_contract_arguments_size_arguments;
struct get_contract_arguments_size_argumentsDefaultTypeInternal;
extern get_contract_arguments_size_argumentsDefaultTypeInternal _get_contract_arguments_size_arguments_default_instance_;
class get_contract_arguments_size_result;
struct get_contract_arguments_size_resultDefaultTypeInternal;
extern get_contract_arguments_size_resultDefaultTypeInternal _get_contract_arguments_size_result_default_instance_;
class get_contract_id_arguments;
struct get_contract_id_argumentsDefaultTypeInternal;
extern get_contract_id_argumentsDefaultTypeInternal _get_contract_id_arguments_default_instance_;
class get_contract_id_result;
struct get_contract_id_resultDefaultTypeInternal;
extern get_contract_id_resultDefaultTypeInternal _get_contract_id_result_default_instance_;
class get_entry_point_arguments;
struct get_entry_point_argumentsDefaultTypeInternal;
extern get_entry_point_argumentsDefaultTypeInternal _get_entry_point_arguments_default_instance_;
class get_entry_point_result;
struct get_entry_point_resultDefaultTypeInternal;
extern get_entry_point_resultDefaultTypeInternal _get_entry_point_result_default_instance_;
class get_head_info_arguments;
struct get_head_info_argumentsDefaultTypeInternal;
extern get_head_info_argumentsDefaultTypeInternal _get_head_info_arguments_default_instance_;
class get_head_info_result;
struct get_head_info_resultDefaultTypeInternal;
extern get_head_info_resultDefaultTypeInternal _get_head_info_result_default_instance_;
class get_last_irreversible_block_arguments;
struct get_last_irreversible_block_argumentsDefaultTypeInternal;
extern get_last_irreversible_block_argumentsDefaultTypeInternal _get_last_irreversible_block_arguments_default_instance_;
class get_last_irreversible_block_result;
struct get_last_irreversible_block_resultDefaultTypeInternal;
extern get_last_irreversible_block_resultDefaultTypeInternal _get_last_irreversible_block_result_default_instance_;
class get_next_object_arguments;
struct get_next_object_argumentsDefaultTypeInternal;
extern get_next_object_argumentsDefaultTypeInternal _get_next_object_arguments_default_instance_;
class get_next_object_result;
struct get_next_object_resultDefaultTypeInternal;
extern get_next_object_resultDefaultTypeInternal _get_next_object_result_default_instance_;
class get_object_arguments;
struct get_object_argumentsDefaultTypeInternal;
extern get_object_argumentsDefaultTypeInternal _get_object_arguments_default_instance_;
class get_object_result;
struct get_object_resultDefaultTypeInternal;
extern get_object_resultDefaultTypeInternal _get_object_result_default_instance_;
class get_prev_object_arguments;
struct get_prev_object_argumentsDefaultTypeInternal;
extern get_prev_object_argumentsDefaultTypeInternal _get_prev_object_arguments_default_instance_;
class get_prev_object_result;
struct get_prev_object_resultDefaultTypeInternal;
extern get_prev_object_resultDefaultTypeInternal _get_prev_object_result_default_instance_;
class get_resource_limits_arguments;
struct get_resource_limits_argumentsDefaultTypeInternal;
extern get_resource_limits_argumentsDefaultTypeInternal _get_resource_limits_arguments_default_instance_;
class get_resource_limits_result;
struct get_resource_limits_resultDefaultTypeInternal;
extern get_resource_limits_resultDefaultTypeInternal _get_resource_limits_result_default_instance_;
class get_transaction_payer_arguments;
struct get_transaction_payer_argumentsDefaultTypeInternal;
extern get_transaction_payer_argumentsDefaultTypeInternal _get_transaction_payer_arguments_default_instance_;
class get_transaction_payer_result;
struct get_transaction_payer_resultDefaultTypeInternal;
extern get_transaction_payer_resultDefaultTypeInternal _get_transaction_payer_result_default_instance_;
class get_transaction_rc_limit_arguments;
struct get_transaction_rc_limit_argumentsDefaultTypeInternal;
extern get_transaction_rc_limit_argumentsDefaultTypeInternal _get_transaction_rc_limit_arguments_default_instance_;
class get_transaction_rc_limit_result;
struct get_transaction_rc_limit_resultDefaultTypeInternal;
extern get_transaction_rc_limit_resultDefaultTypeInternal _get_transaction_rc_limit_result_default_instance_;
class get_transaction_signature_arguments;
struct get_transaction_signature_argumentsDefaultTypeInternal;
extern get_transaction_signature_argumentsDefaultTypeInternal _get_transaction_signature_arguments_default_instance_;
class get_transaction_signature_result;
struct get_transaction_signature_resultDefaultTypeInternal;
extern get_transaction_signature_resultDefaultTypeInternal _get_transaction_signature_result_default_instance_;
class hash_arguments;
struct hash_argumentsDefaultTypeInternal;
extern hash_argumentsDefaultTypeInternal _hash_arguments_default_instance_;
class hash_result;
struct hash_resultDefaultTypeInternal;
extern hash_resultDefaultTypeInternal _hash_result_default_instance_;
class head_info;
struct head_infoDefaultTypeInternal;
extern head_infoDefaultTypeInternal _head_info_default_instance_;
class object_space;
struct object_spaceDefaultTypeInternal;
extern object_spaceDefaultTypeInternal _object_space_default_instance_;
class prints_arguments;
struct prints_argumentsDefaultTypeInternal;
extern prints_argumentsDefaultTypeInternal _prints_arguments_default_instance_;
class prints_result;
struct prints_resultDefaultTypeInternal;
extern prints_resultDefaultTypeInternal _prints_result_default_instance_;
class put_object_arguments;
struct put_object_argumentsDefaultTypeInternal;
extern put_object_argumentsDefaultTypeInternal _put_object_arguments_default_instance_;
class put_object_result;
struct put_object_resultDefaultTypeInternal;
extern put_object_resultDefaultTypeInternal _put_object_result_default_instance_;
class recover_public_key_arguments;
struct recover_public_key_argumentsDefaultTypeInternal;
extern recover_public_key_argumentsDefaultTypeInternal _recover_public_key_arguments_default_instance_;
class recover_public_key_result;
struct recover_public_key_resultDefaultTypeInternal;
extern recover_public_key_resultDefaultTypeInternal _recover_public_key_result_default_instance_;
class require_authority_arguments;
struct require_authority_argumentsDefaultTypeInternal;
extern require_authority_argumentsDefaultTypeInternal _require_authority_arguments_default_instance_;
class require_authority_result;
struct require_authority_resultDefaultTypeInternal;
extern require_authority_resultDefaultTypeInternal _require_authority_result_default_instance_;
class resource_limit_data;
struct resource_limit_dataDefaultTypeInternal;
extern resource_limit_dataDefaultTypeInternal _resource_limit_data_default_instance_;
class set_contract_result_arguments;
struct set_contract_result_argumentsDefaultTypeInternal;
extern set_contract_result_argumentsDefaultTypeInternal _set_contract_result_arguments_default_instance_;
class set_contract_result_result;
struct set_contract_result_resultDefaultTypeInternal;
extern set_contract_result_resultDefaultTypeInternal _set_contract_result_result_default_instance_;
class verify_block_signature_arguments;
struct verify_block_signature_argumentsDefaultTypeInternal;
extern verify_block_signature_argumentsDefaultTypeInternal _verify_block_signature_arguments_default_instance_;
class verify_block_signature_result;
struct verify_block_signature_resultDefaultTypeInternal;
extern verify_block_signature_resultDefaultTypeInternal _verify_block_signature_result_default_instance_;
class verify_merkle_root_arguments;
struct verify_merkle_root_argumentsDefaultTypeInternal;
extern verify_merkle_root_argumentsDefaultTypeInternal _verify_merkle_root_arguments_default_instance_;
class verify_merkle_root_result;
struct verify_merkle_root_resultDefaultTypeInternal;
extern verify_merkle_root_resultDefaultTypeInternal _verify_merkle_root_result_default_instance_;
}  // namespace chain
}  // namespace koinos
PROTOBUF_NAMESPACE_OPEN
template<> ::koinos::chain::apply_block_arguments* Arena::CreateMaybeMessage<::koinos::chain::apply_block_arguments>(Arena*);
template<> ::koinos::chain::apply_block_result* Arena::CreateMaybeMessage<::koinos::chain::apply_block_result>(Arena*);
template<> ::koinos::chain::apply_call_contract_operation_arguments* Arena::CreateMaybeMessage<::koinos::chain::apply_call_contract_operation_arguments>(Arena*);
template<> ::koinos::chain::apply_call_contract_operation_result* Arena::CreateMaybeMessage<::koinos::chain::apply_call_contract_operation_result>(Arena*);
template<> ::koinos::chain::apply_set_system_call_operation_arguments* Arena::CreateMaybeMessage<::koinos::chain::apply_set_system_call_operation_arguments>(Arena*);
template<> ::koinos::chain::apply_set_system_call_operation_result* Arena::CreateMaybeMessage<::koinos::chain::apply_set_system_call_operation_result>(Arena*);
template<> ::koinos::chain::apply_transaction_arguments* Arena::CreateMaybeMessage<::koinos::chain::apply_transaction_arguments>(Arena*);
template<> ::koinos::chain::apply_transaction_result* Arena::CreateMaybeMessage<::koinos::chain::apply_transaction_result>(Arena*);
template<> ::koinos::chain::apply_upload_contract_operation_arguments* Arena::CreateMaybeMessage<::koinos::chain::apply_upload_contract_operation_arguments>(Arena*);
template<> ::koinos::chain::apply_upload_contract_operation_result* Arena::CreateMaybeMessage<::koinos::chain::apply_upload_contract_operation_result>(Arena*);
template<> ::koinos::chain::call_contract_arguments* Arena::CreateMaybeMessage<::koinos::chain::call_contract_arguments>(Arena*);
template<> ::koinos::chain::call_contract_result* Arena::CreateMaybeMessage<::koinos::chain::call_contract_result>(Arena*);
template<> ::koinos::chain::caller_data* Arena::CreateMaybeMessage<::koinos::chain::caller_data>(Arena*);
template<> ::koinos::chain::consume_account_rc_arguments* Arena::CreateMaybeMessage<::koinos::chain::consume_account_rc_arguments>(Arena*);
template<> ::koinos::chain::consume_account_rc_result* Arena::CreateMaybeMessage<::koinos::chain::consume_account_rc_result>(Arena*);
template<> ::koinos::chain::consume_block_resources_arguments* Arena::CreateMaybeMessage<::koinos::chain::consume_block_resources_arguments>(Arena*);
template<> ::koinos::chain::consume_block_resources_result* Arena::CreateMaybeMessage<::koinos::chain::consume_block_resources_result>(Arena*);
template<> ::koinos::chain::exit_contract_arguments* Arena::CreateMaybeMessage<::koinos::chain::exit_contract_arguments>(Arena*);
template<> ::koinos::chain::exit_contract_result* Arena::CreateMaybeMessage<::koinos::chain::exit_contract_result>(Arena*);
template<> ::koinos::chain::get_account_nonce_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_account_nonce_arguments>(Arena*);
template<> ::koinos::chain::get_account_nonce_result* Arena::CreateMaybeMessage<::koinos::chain::get_account_nonce_result>(Arena*);
template<> ::koinos::chain::get_account_rc_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_account_rc_arguments>(Arena*);
template<> ::koinos::chain::get_account_rc_result* Arena::CreateMaybeMessage<::koinos::chain::get_account_rc_result>(Arena*);
template<> ::koinos::chain::get_caller_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_caller_arguments>(Arena*);
template<> ::koinos::chain::get_caller_result* Arena::CreateMaybeMessage<::koinos::chain::get_caller_result>(Arena*);
template<> ::koinos::chain::get_contract_arguments_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_contract_arguments_arguments>(Arena*);
template<> ::koinos::chain::get_contract_arguments_result* Arena::CreateMaybeMessage<::koinos::chain::get_contract_arguments_result>(Arena*);
template<> ::koinos::chain::get_contract_arguments_size_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_contract_arguments_size_arguments>(Arena*);
template<> ::koinos::chain::get_contract_arguments_size_result* Arena::CreateMaybeMessage<::koinos::chain::get_contract_arguments_size_result>(Arena*);
template<> ::koinos::chain::get_contract_id_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_contract_id_arguments>(Arena*);
template<> ::koinos::chain::get_contract_id_result* Arena::CreateMaybeMessage<::koinos::chain::get_contract_id_result>(Arena*);
template<> ::koinos::chain::get_entry_point_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_entry_point_arguments>(Arena*);
template<> ::koinos::chain::get_entry_point_result* Arena::CreateMaybeMessage<::koinos::chain::get_entry_point_result>(Arena*);
template<> ::koinos::chain::get_head_info_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_head_info_arguments>(Arena*);
template<> ::koinos::chain::get_head_info_result* Arena::CreateMaybeMessage<::koinos::chain::get_head_info_result>(Arena*);
template<> ::koinos::chain::get_last_irreversible_block_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_last_irreversible_block_arguments>(Arena*);
template<> ::koinos::chain::get_last_irreversible_block_result* Arena::CreateMaybeMessage<::koinos::chain::get_last_irreversible_block_result>(Arena*);
template<> ::koinos::chain::get_next_object_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_next_object_arguments>(Arena*);
template<> ::koinos::chain::get_next_object_result* Arena::CreateMaybeMessage<::koinos::chain::get_next_object_result>(Arena*);
template<> ::koinos::chain::get_object_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_object_arguments>(Arena*);
template<> ::koinos::chain::get_object_result* Arena::CreateMaybeMessage<::koinos::chain::get_object_result>(Arena*);
template<> ::koinos::chain::get_prev_object_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_prev_object_arguments>(Arena*);
template<> ::koinos::chain::get_prev_object_result* Arena::CreateMaybeMessage<::koinos::chain::get_prev_object_result>(Arena*);
template<> ::koinos::chain::get_resource_limits_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_resource_limits_arguments>(Arena*);
template<> ::koinos::chain::get_resource_limits_result* Arena::CreateMaybeMessage<::koinos::chain::get_resource_limits_result>(Arena*);
template<> ::koinos::chain::get_transaction_payer_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_transaction_payer_arguments>(Arena*);
template<> ::koinos::chain::get_transaction_payer_result* Arena::CreateMaybeMessage<::koinos::chain::get_transaction_payer_result>(Arena*);
template<> ::koinos::chain::get_transaction_rc_limit_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_transaction_rc_limit_arguments>(Arena*);
template<> ::koinos::chain::get_transaction_rc_limit_result* Arena::CreateMaybeMessage<::koinos::chain::get_transaction_rc_limit_result>(Arena*);
template<> ::koinos::chain::get_transaction_signature_arguments* Arena::CreateMaybeMessage<::koinos::chain::get_transaction_signature_arguments>(Arena*);
template<> ::koinos::chain::get_transaction_signature_result* Arena::CreateMaybeMessage<::koinos::chain::get_transaction_signature_result>(Arena*);
template<> ::koinos::chain::hash_arguments* Arena::CreateMaybeMessage<::koinos::chain::hash_arguments>(Arena*);
template<> ::koinos::chain::hash_result* Arena::CreateMaybeMessage<::koinos::chain::hash_result>(Arena*);
template<> ::koinos::chain::head_info* Arena::CreateMaybeMessage<::koinos::chain::head_info>(Arena*);
template<> ::koinos::chain::object_space* Arena::CreateMaybeMessage<::koinos::chain::object_space>(Arena*);
template<> ::koinos::chain::prints_arguments* Arena::CreateMaybeMessage<::koinos::chain::prints_arguments>(Arena*);
template<> ::koinos::chain::prints_result* Arena::CreateMaybeMessage<::koinos::chain::prints_result>(Arena*);
template<> ::koinos::chain::put_object_arguments* Arena::CreateMaybeMessage<::koinos::chain::put_object_arguments>(Arena*);
template<> ::koinos::chain::put_object_result* Arena::CreateMaybeMessage<::koinos::chain::put_object_result>(Arena*);
template<> ::koinos::chain::recover_public_key_arguments* Arena::CreateMaybeMessage<::koinos::chain::recover_public_key_arguments>(Arena*);
template<> ::koinos::chain::recover_public_key_result* Arena::CreateMaybeMessage<::koinos::chain::recover_public_key_result>(Arena*);
template<> ::koinos::chain::require_authority_arguments* Arena::CreateMaybeMessage<::koinos::chain::require_authority_arguments>(Arena*);
template<> ::koinos::chain::require_authority_result* Arena::CreateMaybeMessage<::koinos::chain::require_authority_result>(Arena*);
template<> ::koinos::chain::resource_limit_data* Arena::CreateMaybeMessage<::koinos::chain::resource_limit_data>(Arena*);
template<> ::koinos::chain::set_contract_result_arguments* Arena::CreateMaybeMessage<::koinos::chain::set_contract_result_arguments>(Arena*);
template<> ::koinos::chain::set_contract_result_result* Arena::CreateMaybeMessage<::koinos::chain::set_contract_result_result>(Arena*);
template<> ::koinos::chain::verify_block_signature_arguments* Arena::CreateMaybeMessage<::koinos::chain::verify_block_signature_arguments>(Arena*);
template<> ::koinos::chain::verify_block_signature_result* Arena::CreateMaybeMessage<::koinos::chain::verify_block_signature_result>(Arena*);
template<> ::koinos::chain::verify_merkle_root_arguments* Arena::CreateMaybeMessage<::koinos::chain::verify_merkle_root_arguments>(Arena*);
template<> ::koinos::chain::verify_merkle_root_result* Arena::CreateMaybeMessage<::koinos::chain::verify_merkle_root_result>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace koinos {
namespace chain {

enum privilege : int {
  kernel_mode = 0,
  user_mode = 1,
  privilege_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  privilege_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool privilege_IsValid(int value);
constexpr privilege privilege_MIN = kernel_mode;
constexpr privilege privilege_MAX = user_mode;
constexpr int privilege_ARRAYSIZE = privilege_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* privilege_descriptor();
template<typename T>
inline const std::string& privilege_Name(T enum_t_value) {
  static_assert(::std::is_same<T, privilege>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function privilege_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    privilege_descriptor(), enum_t_value);
}
inline bool privilege_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, privilege* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<privilege>(
    privilege_descriptor(), name, value);
}
// ===================================================================

class object_space final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.object_space) */ {
 public:
  inline object_space() : object_space(nullptr) {}
  ~object_space() override;
  explicit constexpr object_space(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  object_space(const object_space& from);
  object_space(object_space&& from) noexcept
    : object_space() {
    *this = ::std::move(from);
  }

  inline object_space& operator=(const object_space& from) {
    CopyFrom(from);
    return *this;
  }
  inline object_space& operator=(object_space&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const object_space& default_instance() {
    return *internal_default_instance();
  }
  static inline const object_space* internal_default_instance() {
    return reinterpret_cast<const object_space*>(
               &_object_space_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(object_space& a, object_space& b) {
    a.Swap(&b);
  }
  inline void Swap(object_space* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(object_space* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline object_space* New() const final {
    return new object_space();
  }

  object_space* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<object_space>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const object_space& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const object_space& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(object_space* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.object_space";
  }
  protected:
  explicit object_space(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZoneFieldNumber = 2,
    kSystemFieldNumber = 1,
    kIdFieldNumber = 3,
  };
  // bytes zone = 2;
  void clear_zone();
  const std::string& zone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_zone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_zone();
  PROTOBUF_MUST_USE_RESULT std::string* release_zone();
  void set_allocated_zone(std::string* zone);
  private:
  const std::string& _internal_zone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_zone(const std::string& value);
  std::string* _internal_mutable_zone();
  public:

  // bool system = 1;
  void clear_system();
  bool system() const;
  void set_system(bool value);
  private:
  bool _internal_system() const;
  void _internal_set_system(bool value);
  public:

  // uint32 id = 3;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.object_space)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr zone_;
  bool system_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class head_info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.head_info) */ {
 public:
  inline head_info() : head_info(nullptr) {}
  ~head_info() override;
  explicit constexpr head_info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  head_info(const head_info& from);
  head_info(head_info&& from) noexcept
    : head_info() {
    *this = ::std::move(from);
  }

  inline head_info& operator=(const head_info& from) {
    CopyFrom(from);
    return *this;
  }
  inline head_info& operator=(head_info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const head_info& default_instance() {
    return *internal_default_instance();
  }
  static inline const head_info* internal_default_instance() {
    return reinterpret_cast<const head_info*>(
               &_head_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(head_info& a, head_info& b) {
    a.Swap(&b);
  }
  inline void Swap(head_info* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(head_info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline head_info* New() const final {
    return new head_info();
  }

  head_info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<head_info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const head_info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const head_info& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(head_info* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.head_info";
  }
  protected:
  explicit head_info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadTopologyFieldNumber = 1,
    kHeadBlockTimeFieldNumber = 2,
    kLastIrreversibleBlockFieldNumber = 3,
  };
  // .koinos.block_topology head_topology = 1;
  bool has_head_topology() const;
  private:
  bool _internal_has_head_topology() const;
  public:
  void clear_head_topology();
  const ::koinos::block_topology& head_topology() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::block_topology* release_head_topology();
  ::koinos::block_topology* mutable_head_topology();
  void set_allocated_head_topology(::koinos::block_topology* head_topology);
  private:
  const ::koinos::block_topology& _internal_head_topology() const;
  ::koinos::block_topology* _internal_mutable_head_topology();
  public:
  void unsafe_arena_set_allocated_head_topology(
      ::koinos::block_topology* head_topology);
  ::koinos::block_topology* unsafe_arena_release_head_topology();

  // uint64 head_block_time = 2 [jstype = JS_STRING];
  void clear_head_block_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 head_block_time() const;
  void set_head_block_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_head_block_time() const;
  void _internal_set_head_block_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 last_irreversible_block = 3 [jstype = JS_STRING];
  void clear_last_irreversible_block();
  ::PROTOBUF_NAMESPACE_ID::uint64 last_irreversible_block() const;
  void set_last_irreversible_block(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_last_irreversible_block() const;
  void _internal_set_last_irreversible_block(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.head_info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::block_topology* head_topology_;
  ::PROTOBUF_NAMESPACE_ID::uint64 head_block_time_;
  ::PROTOBUF_NAMESPACE_ID::uint64 last_irreversible_block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class caller_data final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.caller_data) */ {
 public:
  inline caller_data() : caller_data(nullptr) {}
  ~caller_data() override;
  explicit constexpr caller_data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  caller_data(const caller_data& from);
  caller_data(caller_data&& from) noexcept
    : caller_data() {
    *this = ::std::move(from);
  }

  inline caller_data& operator=(const caller_data& from) {
    CopyFrom(from);
    return *this;
  }
  inline caller_data& operator=(caller_data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const caller_data& default_instance() {
    return *internal_default_instance();
  }
  static inline const caller_data* internal_default_instance() {
    return reinterpret_cast<const caller_data*>(
               &_caller_data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(caller_data& a, caller_data& b) {
    a.Swap(&b);
  }
  inline void Swap(caller_data* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(caller_data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline caller_data* New() const final {
    return new caller_data();
  }

  caller_data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<caller_data>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const caller_data& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const caller_data& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(caller_data* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.caller_data";
  }
  protected:
  explicit caller_data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallerFieldNumber = 1,
    kCallerPrivilegeFieldNumber = 2,
  };
  // bytes caller = 1;
  void clear_caller();
  const std::string& caller() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caller(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caller();
  PROTOBUF_MUST_USE_RESULT std::string* release_caller();
  void set_allocated_caller(std::string* caller);
  private:
  const std::string& _internal_caller() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caller(const std::string& value);
  std::string* _internal_mutable_caller();
  public:

  // .koinos.chain.privilege caller_privilege = 2;
  void clear_caller_privilege();
  ::koinos::chain::privilege caller_privilege() const;
  void set_caller_privilege(::koinos::chain::privilege value);
  private:
  ::koinos::chain::privilege _internal_caller_privilege() const;
  void _internal_set_caller_privilege(::koinos::chain::privilege value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.caller_data)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caller_;
  int caller_privilege_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class resource_limit_data final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.resource_limit_data) */ {
 public:
  inline resource_limit_data() : resource_limit_data(nullptr) {}
  ~resource_limit_data() override;
  explicit constexpr resource_limit_data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resource_limit_data(const resource_limit_data& from);
  resource_limit_data(resource_limit_data&& from) noexcept
    : resource_limit_data() {
    *this = ::std::move(from);
  }

  inline resource_limit_data& operator=(const resource_limit_data& from) {
    CopyFrom(from);
    return *this;
  }
  inline resource_limit_data& operator=(resource_limit_data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resource_limit_data& default_instance() {
    return *internal_default_instance();
  }
  static inline const resource_limit_data* internal_default_instance() {
    return reinterpret_cast<const resource_limit_data*>(
               &_resource_limit_data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(resource_limit_data& a, resource_limit_data& b) {
    a.Swap(&b);
  }
  inline void Swap(resource_limit_data* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resource_limit_data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline resource_limit_data* New() const final {
    return new resource_limit_data();
  }

  resource_limit_data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<resource_limit_data>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const resource_limit_data& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const resource_limit_data& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(resource_limit_data* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.resource_limit_data";
  }
  protected:
  explicit resource_limit_data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiskStorageLimitFieldNumber = 1,
    kDiskStorageCostFieldNumber = 2,
    kNetworkBandwidthLimitFieldNumber = 3,
    kNetworkBandwidthCostFieldNumber = 4,
    kComputeBandwidthLimitFieldNumber = 5,
    kComputeBandwidthCostFieldNumber = 6,
  };
  // uint64 disk_storage_limit = 1 [jstype = JS_STRING];
  void clear_disk_storage_limit();
  ::PROTOBUF_NAMESPACE_ID::uint64 disk_storage_limit() const;
  void set_disk_storage_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_disk_storage_limit() const;
  void _internal_set_disk_storage_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 disk_storage_cost = 2 [jstype = JS_STRING];
  void clear_disk_storage_cost();
  ::PROTOBUF_NAMESPACE_ID::uint64 disk_storage_cost() const;
  void set_disk_storage_cost(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_disk_storage_cost() const;
  void _internal_set_disk_storage_cost(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 network_bandwidth_limit = 3 [jstype = JS_STRING];
  void clear_network_bandwidth_limit();
  ::PROTOBUF_NAMESPACE_ID::uint64 network_bandwidth_limit() const;
  void set_network_bandwidth_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_network_bandwidth_limit() const;
  void _internal_set_network_bandwidth_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 network_bandwidth_cost = 4 [jstype = JS_STRING];
  void clear_network_bandwidth_cost();
  ::PROTOBUF_NAMESPACE_ID::uint64 network_bandwidth_cost() const;
  void set_network_bandwidth_cost(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_network_bandwidth_cost() const;
  void _internal_set_network_bandwidth_cost(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 compute_bandwidth_limit = 5 [jstype = JS_STRING];
  void clear_compute_bandwidth_limit();
  ::PROTOBUF_NAMESPACE_ID::uint64 compute_bandwidth_limit() const;
  void set_compute_bandwidth_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_compute_bandwidth_limit() const;
  void _internal_set_compute_bandwidth_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 compute_bandwidth_cost = 6 [jstype = JS_STRING];
  void clear_compute_bandwidth_cost();
  ::PROTOBUF_NAMESPACE_ID::uint64 compute_bandwidth_cost() const;
  void set_compute_bandwidth_cost(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_compute_bandwidth_cost() const;
  void _internal_set_compute_bandwidth_cost(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.resource_limit_data)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 disk_storage_limit_;
  ::PROTOBUF_NAMESPACE_ID::uint64 disk_storage_cost_;
  ::PROTOBUF_NAMESPACE_ID::uint64 network_bandwidth_limit_;
  ::PROTOBUF_NAMESPACE_ID::uint64 network_bandwidth_cost_;
  ::PROTOBUF_NAMESPACE_ID::uint64 compute_bandwidth_limit_;
  ::PROTOBUF_NAMESPACE_ID::uint64 compute_bandwidth_cost_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class prints_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.prints_arguments) */ {
 public:
  inline prints_arguments() : prints_arguments(nullptr) {}
  ~prints_arguments() override;
  explicit constexpr prints_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  prints_arguments(const prints_arguments& from);
  prints_arguments(prints_arguments&& from) noexcept
    : prints_arguments() {
    *this = ::std::move(from);
  }

  inline prints_arguments& operator=(const prints_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline prints_arguments& operator=(prints_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const prints_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const prints_arguments* internal_default_instance() {
    return reinterpret_cast<const prints_arguments*>(
               &_prints_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(prints_arguments& a, prints_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(prints_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(prints_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline prints_arguments* New() const final {
    return new prints_arguments();
  }

  prints_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<prints_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const prints_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const prints_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(prints_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.prints_arguments";
  }
  protected:
  explicit prints_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.prints_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class prints_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.prints_result) */ {
 public:
  inline prints_result() : prints_result(nullptr) {}
  ~prints_result() override;
  explicit constexpr prints_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  prints_result(const prints_result& from);
  prints_result(prints_result&& from) noexcept
    : prints_result() {
    *this = ::std::move(from);
  }

  inline prints_result& operator=(const prints_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline prints_result& operator=(prints_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const prints_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const prints_result* internal_default_instance() {
    return reinterpret_cast<const prints_result*>(
               &_prints_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(prints_result& a, prints_result& b) {
    a.Swap(&b);
  }
  inline void Swap(prints_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(prints_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline prints_result* New() const final {
    return new prints_result();
  }

  prints_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<prints_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const prints_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const prints_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(prints_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.prints_result";
  }
  protected:
  explicit prints_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.prints_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class verify_block_signature_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.verify_block_signature_arguments) */ {
 public:
  inline verify_block_signature_arguments() : verify_block_signature_arguments(nullptr) {}
  ~verify_block_signature_arguments() override;
  explicit constexpr verify_block_signature_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  verify_block_signature_arguments(const verify_block_signature_arguments& from);
  verify_block_signature_arguments(verify_block_signature_arguments&& from) noexcept
    : verify_block_signature_arguments() {
    *this = ::std::move(from);
  }

  inline verify_block_signature_arguments& operator=(const verify_block_signature_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline verify_block_signature_arguments& operator=(verify_block_signature_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const verify_block_signature_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const verify_block_signature_arguments* internal_default_instance() {
    return reinterpret_cast<const verify_block_signature_arguments*>(
               &_verify_block_signature_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(verify_block_signature_arguments& a, verify_block_signature_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(verify_block_signature_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(verify_block_signature_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline verify_block_signature_arguments* New() const final {
    return new verify_block_signature_arguments();
  }

  verify_block_signature_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<verify_block_signature_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const verify_block_signature_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const verify_block_signature_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(verify_block_signature_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.verify_block_signature_arguments";
  }
  protected:
  explicit verify_block_signature_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDigestFieldNumber = 1,
    kActiveFieldNumber = 2,
    kSignatureDataFieldNumber = 3,
  };
  // bytes digest = 1;
  void clear_digest();
  const std::string& digest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_digest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_digest();
  PROTOBUF_MUST_USE_RESULT std::string* release_digest();
  void set_allocated_digest(std::string* digest);
  private:
  const std::string& _internal_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_digest(const std::string& value);
  std::string* _internal_mutable_digest();
  public:

  // bytes active = 2;
  void clear_active();
  const std::string& active() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_active(ArgT0&& arg0, ArgT... args);
  std::string* mutable_active();
  PROTOBUF_MUST_USE_RESULT std::string* release_active();
  void set_allocated_active(std::string* active);
  private:
  const std::string& _internal_active() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_active(const std::string& value);
  std::string* _internal_mutable_active();
  public:

  // bytes signature_data = 3;
  void clear_signature_data();
  const std::string& signature_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_signature_data();
  void set_allocated_signature_data(std::string* signature_data);
  private:
  const std::string& _internal_signature_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature_data(const std::string& value);
  std::string* _internal_mutable_signature_data();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.verify_block_signature_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr active_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class verify_block_signature_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.verify_block_signature_result) */ {
 public:
  inline verify_block_signature_result() : verify_block_signature_result(nullptr) {}
  ~verify_block_signature_result() override;
  explicit constexpr verify_block_signature_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  verify_block_signature_result(const verify_block_signature_result& from);
  verify_block_signature_result(verify_block_signature_result&& from) noexcept
    : verify_block_signature_result() {
    *this = ::std::move(from);
  }

  inline verify_block_signature_result& operator=(const verify_block_signature_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline verify_block_signature_result& operator=(verify_block_signature_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const verify_block_signature_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const verify_block_signature_result* internal_default_instance() {
    return reinterpret_cast<const verify_block_signature_result*>(
               &_verify_block_signature_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(verify_block_signature_result& a, verify_block_signature_result& b) {
    a.Swap(&b);
  }
  inline void Swap(verify_block_signature_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(verify_block_signature_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline verify_block_signature_result* New() const final {
    return new verify_block_signature_result();
  }

  verify_block_signature_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<verify_block_signature_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const verify_block_signature_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const verify_block_signature_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(verify_block_signature_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.verify_block_signature_result";
  }
  protected:
  explicit verify_block_signature_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.verify_block_signature_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class verify_merkle_root_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.verify_merkle_root_arguments) */ {
 public:
  inline verify_merkle_root_arguments() : verify_merkle_root_arguments(nullptr) {}
  ~verify_merkle_root_arguments() override;
  explicit constexpr verify_merkle_root_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  verify_merkle_root_arguments(const verify_merkle_root_arguments& from);
  verify_merkle_root_arguments(verify_merkle_root_arguments&& from) noexcept
    : verify_merkle_root_arguments() {
    *this = ::std::move(from);
  }

  inline verify_merkle_root_arguments& operator=(const verify_merkle_root_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline verify_merkle_root_arguments& operator=(verify_merkle_root_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const verify_merkle_root_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const verify_merkle_root_arguments* internal_default_instance() {
    return reinterpret_cast<const verify_merkle_root_arguments*>(
               &_verify_merkle_root_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(verify_merkle_root_arguments& a, verify_merkle_root_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(verify_merkle_root_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(verify_merkle_root_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline verify_merkle_root_arguments* New() const final {
    return new verify_merkle_root_arguments();
  }

  verify_merkle_root_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<verify_merkle_root_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const verify_merkle_root_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const verify_merkle_root_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(verify_merkle_root_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.verify_merkle_root_arguments";
  }
  protected:
  explicit verify_merkle_root_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashesFieldNumber = 2,
    kRootFieldNumber = 1,
  };
  // repeated bytes hashes = 2;
  int hashes_size() const;
  private:
  int _internal_hashes_size() const;
  public:
  void clear_hashes();
  const std::string& hashes(int index) const;
  std::string* mutable_hashes(int index);
  void set_hashes(int index, const std::string& value);
  void set_hashes(int index, std::string&& value);
  void set_hashes(int index, const char* value);
  void set_hashes(int index, const void* value, size_t size);
  std::string* add_hashes();
  void add_hashes(const std::string& value);
  void add_hashes(std::string&& value);
  void add_hashes(const char* value);
  void add_hashes(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hashes();
  private:
  const std::string& _internal_hashes(int index) const;
  std::string* _internal_add_hashes();
  public:

  // bytes root = 1;
  void clear_root();
  const std::string& root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_root();
  PROTOBUF_MUST_USE_RESULT std::string* release_root();
  void set_allocated_root(std::string* root);
  private:
  const std::string& _internal_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_root(const std::string& value);
  std::string* _internal_mutable_root();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.verify_merkle_root_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hashes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr root_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class verify_merkle_root_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.verify_merkle_root_result) */ {
 public:
  inline verify_merkle_root_result() : verify_merkle_root_result(nullptr) {}
  ~verify_merkle_root_result() override;
  explicit constexpr verify_merkle_root_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  verify_merkle_root_result(const verify_merkle_root_result& from);
  verify_merkle_root_result(verify_merkle_root_result&& from) noexcept
    : verify_merkle_root_result() {
    *this = ::std::move(from);
  }

  inline verify_merkle_root_result& operator=(const verify_merkle_root_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline verify_merkle_root_result& operator=(verify_merkle_root_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const verify_merkle_root_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const verify_merkle_root_result* internal_default_instance() {
    return reinterpret_cast<const verify_merkle_root_result*>(
               &_verify_merkle_root_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(verify_merkle_root_result& a, verify_merkle_root_result& b) {
    a.Swap(&b);
  }
  inline void Swap(verify_merkle_root_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(verify_merkle_root_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline verify_merkle_root_result* New() const final {
    return new verify_merkle_root_result();
  }

  verify_merkle_root_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<verify_merkle_root_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const verify_merkle_root_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const verify_merkle_root_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(verify_merkle_root_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.verify_merkle_root_result";
  }
  protected:
  explicit verify_merkle_root_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.verify_merkle_root_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class apply_block_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_block_arguments) */ {
 public:
  inline apply_block_arguments() : apply_block_arguments(nullptr) {}
  ~apply_block_arguments() override;
  explicit constexpr apply_block_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_block_arguments(const apply_block_arguments& from);
  apply_block_arguments(apply_block_arguments&& from) noexcept
    : apply_block_arguments() {
    *this = ::std::move(from);
  }

  inline apply_block_arguments& operator=(const apply_block_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_block_arguments& operator=(apply_block_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_block_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_block_arguments* internal_default_instance() {
    return reinterpret_cast<const apply_block_arguments*>(
               &_apply_block_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(apply_block_arguments& a, apply_block_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_block_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_block_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_block_arguments* New() const final {
    return new apply_block_arguments();
  }

  apply_block_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_block_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_block_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_block_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_block_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_block_arguments";
  }
  protected:
  explicit apply_block_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 1,
    kCheckPassiveDataFieldNumber = 2,
    kCheckBlockSignatureFieldNumber = 3,
    kCheckTransactionSignatureFieldNumber = 4,
  };
  // .koinos.protocol.block block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::koinos::protocol::block& block() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::protocol::block* release_block();
  ::koinos::protocol::block* mutable_block();
  void set_allocated_block(::koinos::protocol::block* block);
  private:
  const ::koinos::protocol::block& _internal_block() const;
  ::koinos::protocol::block* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::koinos::protocol::block* block);
  ::koinos::protocol::block* unsafe_arena_release_block();

  // bool check_passive_data = 2;
  void clear_check_passive_data();
  bool check_passive_data() const;
  void set_check_passive_data(bool value);
  private:
  bool _internal_check_passive_data() const;
  void _internal_set_check_passive_data(bool value);
  public:

  // bool check_block_signature = 3;
  void clear_check_block_signature();
  bool check_block_signature() const;
  void set_check_block_signature(bool value);
  private:
  bool _internal_check_block_signature() const;
  void _internal_set_check_block_signature(bool value);
  public:

  // bool check_transaction_signature = 4;
  void clear_check_transaction_signature();
  bool check_transaction_signature() const;
  void set_check_transaction_signature(bool value);
  private:
  bool _internal_check_transaction_signature() const;
  void _internal_set_check_transaction_signature(bool value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_block_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::protocol::block* block_;
  bool check_passive_data_;
  bool check_block_signature_;
  bool check_transaction_signature_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class apply_block_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_block_result) */ {
 public:
  inline apply_block_result() : apply_block_result(nullptr) {}
  ~apply_block_result() override;
  explicit constexpr apply_block_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_block_result(const apply_block_result& from);
  apply_block_result(apply_block_result&& from) noexcept
    : apply_block_result() {
    *this = ::std::move(from);
  }

  inline apply_block_result& operator=(const apply_block_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_block_result& operator=(apply_block_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_block_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_block_result* internal_default_instance() {
    return reinterpret_cast<const apply_block_result*>(
               &_apply_block_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(apply_block_result& a, apply_block_result& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_block_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_block_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_block_result* New() const final {
    return new apply_block_result();
  }

  apply_block_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_block_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_block_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_block_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_block_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_block_result";
  }
  protected:
  explicit apply_block_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_block_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class apply_transaction_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_transaction_arguments) */ {
 public:
  inline apply_transaction_arguments() : apply_transaction_arguments(nullptr) {}
  ~apply_transaction_arguments() override;
  explicit constexpr apply_transaction_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_transaction_arguments(const apply_transaction_arguments& from);
  apply_transaction_arguments(apply_transaction_arguments&& from) noexcept
    : apply_transaction_arguments() {
    *this = ::std::move(from);
  }

  inline apply_transaction_arguments& operator=(const apply_transaction_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_transaction_arguments& operator=(apply_transaction_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_transaction_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_transaction_arguments* internal_default_instance() {
    return reinterpret_cast<const apply_transaction_arguments*>(
               &_apply_transaction_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(apply_transaction_arguments& a, apply_transaction_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_transaction_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_transaction_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_transaction_arguments* New() const final {
    return new apply_transaction_arguments();
  }

  apply_transaction_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_transaction_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_transaction_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_transaction_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_transaction_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_transaction_arguments";
  }
  protected:
  explicit apply_transaction_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionFieldNumber = 1,
  };
  // .koinos.protocol.transaction transaction = 1;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::koinos::protocol::transaction& transaction() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::protocol::transaction* release_transaction();
  ::koinos::protocol::transaction* mutable_transaction();
  void set_allocated_transaction(::koinos::protocol::transaction* transaction);
  private:
  const ::koinos::protocol::transaction& _internal_transaction() const;
  ::koinos::protocol::transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::koinos::protocol::transaction* transaction);
  ::koinos::protocol::transaction* unsafe_arena_release_transaction();

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_transaction_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::protocol::transaction* transaction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class apply_transaction_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_transaction_result) */ {
 public:
  inline apply_transaction_result() : apply_transaction_result(nullptr) {}
  ~apply_transaction_result() override;
  explicit constexpr apply_transaction_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_transaction_result(const apply_transaction_result& from);
  apply_transaction_result(apply_transaction_result&& from) noexcept
    : apply_transaction_result() {
    *this = ::std::move(from);
  }

  inline apply_transaction_result& operator=(const apply_transaction_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_transaction_result& operator=(apply_transaction_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_transaction_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_transaction_result* internal_default_instance() {
    return reinterpret_cast<const apply_transaction_result*>(
               &_apply_transaction_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(apply_transaction_result& a, apply_transaction_result& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_transaction_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_transaction_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_transaction_result* New() const final {
    return new apply_transaction_result();
  }

  apply_transaction_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_transaction_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_transaction_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_transaction_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_transaction_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_transaction_result";
  }
  protected:
  explicit apply_transaction_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_transaction_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class apply_upload_contract_operation_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_upload_contract_operation_arguments) */ {
 public:
  inline apply_upload_contract_operation_arguments() : apply_upload_contract_operation_arguments(nullptr) {}
  ~apply_upload_contract_operation_arguments() override;
  explicit constexpr apply_upload_contract_operation_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_upload_contract_operation_arguments(const apply_upload_contract_operation_arguments& from);
  apply_upload_contract_operation_arguments(apply_upload_contract_operation_arguments&& from) noexcept
    : apply_upload_contract_operation_arguments() {
    *this = ::std::move(from);
  }

  inline apply_upload_contract_operation_arguments& operator=(const apply_upload_contract_operation_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_upload_contract_operation_arguments& operator=(apply_upload_contract_operation_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_upload_contract_operation_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_upload_contract_operation_arguments* internal_default_instance() {
    return reinterpret_cast<const apply_upload_contract_operation_arguments*>(
               &_apply_upload_contract_operation_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(apply_upload_contract_operation_arguments& a, apply_upload_contract_operation_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_upload_contract_operation_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_upload_contract_operation_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_upload_contract_operation_arguments* New() const final {
    return new apply_upload_contract_operation_arguments();
  }

  apply_upload_contract_operation_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_upload_contract_operation_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_upload_contract_operation_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_upload_contract_operation_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_upload_contract_operation_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_upload_contract_operation_arguments";
  }
  protected:
  explicit apply_upload_contract_operation_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpFieldNumber = 1,
  };
  // .koinos.protocol.upload_contract_operation op = 1;
  bool has_op() const;
  private:
  bool _internal_has_op() const;
  public:
  void clear_op();
  const ::koinos::protocol::upload_contract_operation& op() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::protocol::upload_contract_operation* release_op();
  ::koinos::protocol::upload_contract_operation* mutable_op();
  void set_allocated_op(::koinos::protocol::upload_contract_operation* op);
  private:
  const ::koinos::protocol::upload_contract_operation& _internal_op() const;
  ::koinos::protocol::upload_contract_operation* _internal_mutable_op();
  public:
  void unsafe_arena_set_allocated_op(
      ::koinos::protocol::upload_contract_operation* op);
  ::koinos::protocol::upload_contract_operation* unsafe_arena_release_op();

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_upload_contract_operation_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::protocol::upload_contract_operation* op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class apply_upload_contract_operation_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_upload_contract_operation_result) */ {
 public:
  inline apply_upload_contract_operation_result() : apply_upload_contract_operation_result(nullptr) {}
  ~apply_upload_contract_operation_result() override;
  explicit constexpr apply_upload_contract_operation_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_upload_contract_operation_result(const apply_upload_contract_operation_result& from);
  apply_upload_contract_operation_result(apply_upload_contract_operation_result&& from) noexcept
    : apply_upload_contract_operation_result() {
    *this = ::std::move(from);
  }

  inline apply_upload_contract_operation_result& operator=(const apply_upload_contract_operation_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_upload_contract_operation_result& operator=(apply_upload_contract_operation_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_upload_contract_operation_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_upload_contract_operation_result* internal_default_instance() {
    return reinterpret_cast<const apply_upload_contract_operation_result*>(
               &_apply_upload_contract_operation_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(apply_upload_contract_operation_result& a, apply_upload_contract_operation_result& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_upload_contract_operation_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_upload_contract_operation_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_upload_contract_operation_result* New() const final {
    return new apply_upload_contract_operation_result();
  }

  apply_upload_contract_operation_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_upload_contract_operation_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_upload_contract_operation_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_upload_contract_operation_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_upload_contract_operation_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_upload_contract_operation_result";
  }
  protected:
  explicit apply_upload_contract_operation_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_upload_contract_operation_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class apply_call_contract_operation_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_call_contract_operation_arguments) */ {
 public:
  inline apply_call_contract_operation_arguments() : apply_call_contract_operation_arguments(nullptr) {}
  ~apply_call_contract_operation_arguments() override;
  explicit constexpr apply_call_contract_operation_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_call_contract_operation_arguments(const apply_call_contract_operation_arguments& from);
  apply_call_contract_operation_arguments(apply_call_contract_operation_arguments&& from) noexcept
    : apply_call_contract_operation_arguments() {
    *this = ::std::move(from);
  }

  inline apply_call_contract_operation_arguments& operator=(const apply_call_contract_operation_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_call_contract_operation_arguments& operator=(apply_call_contract_operation_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_call_contract_operation_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_call_contract_operation_arguments* internal_default_instance() {
    return reinterpret_cast<const apply_call_contract_operation_arguments*>(
               &_apply_call_contract_operation_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(apply_call_contract_operation_arguments& a, apply_call_contract_operation_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_call_contract_operation_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_call_contract_operation_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_call_contract_operation_arguments* New() const final {
    return new apply_call_contract_operation_arguments();
  }

  apply_call_contract_operation_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_call_contract_operation_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_call_contract_operation_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_call_contract_operation_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_call_contract_operation_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_call_contract_operation_arguments";
  }
  protected:
  explicit apply_call_contract_operation_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpFieldNumber = 1,
  };
  // .koinos.protocol.call_contract_operation op = 1;
  bool has_op() const;
  private:
  bool _internal_has_op() const;
  public:
  void clear_op();
  const ::koinos::protocol::call_contract_operation& op() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::protocol::call_contract_operation* release_op();
  ::koinos::protocol::call_contract_operation* mutable_op();
  void set_allocated_op(::koinos::protocol::call_contract_operation* op);
  private:
  const ::koinos::protocol::call_contract_operation& _internal_op() const;
  ::koinos::protocol::call_contract_operation* _internal_mutable_op();
  public:
  void unsafe_arena_set_allocated_op(
      ::koinos::protocol::call_contract_operation* op);
  ::koinos::protocol::call_contract_operation* unsafe_arena_release_op();

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_call_contract_operation_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::protocol::call_contract_operation* op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class apply_call_contract_operation_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_call_contract_operation_result) */ {
 public:
  inline apply_call_contract_operation_result() : apply_call_contract_operation_result(nullptr) {}
  ~apply_call_contract_operation_result() override;
  explicit constexpr apply_call_contract_operation_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_call_contract_operation_result(const apply_call_contract_operation_result& from);
  apply_call_contract_operation_result(apply_call_contract_operation_result&& from) noexcept
    : apply_call_contract_operation_result() {
    *this = ::std::move(from);
  }

  inline apply_call_contract_operation_result& operator=(const apply_call_contract_operation_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_call_contract_operation_result& operator=(apply_call_contract_operation_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_call_contract_operation_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_call_contract_operation_result* internal_default_instance() {
    return reinterpret_cast<const apply_call_contract_operation_result*>(
               &_apply_call_contract_operation_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(apply_call_contract_operation_result& a, apply_call_contract_operation_result& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_call_contract_operation_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_call_contract_operation_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_call_contract_operation_result* New() const final {
    return new apply_call_contract_operation_result();
  }

  apply_call_contract_operation_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_call_contract_operation_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_call_contract_operation_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_call_contract_operation_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_call_contract_operation_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_call_contract_operation_result";
  }
  protected:
  explicit apply_call_contract_operation_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_call_contract_operation_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class apply_set_system_call_operation_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_set_system_call_operation_arguments) */ {
 public:
  inline apply_set_system_call_operation_arguments() : apply_set_system_call_operation_arguments(nullptr) {}
  ~apply_set_system_call_operation_arguments() override;
  explicit constexpr apply_set_system_call_operation_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_set_system_call_operation_arguments(const apply_set_system_call_operation_arguments& from);
  apply_set_system_call_operation_arguments(apply_set_system_call_operation_arguments&& from) noexcept
    : apply_set_system_call_operation_arguments() {
    *this = ::std::move(from);
  }

  inline apply_set_system_call_operation_arguments& operator=(const apply_set_system_call_operation_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_set_system_call_operation_arguments& operator=(apply_set_system_call_operation_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_set_system_call_operation_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_set_system_call_operation_arguments* internal_default_instance() {
    return reinterpret_cast<const apply_set_system_call_operation_arguments*>(
               &_apply_set_system_call_operation_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(apply_set_system_call_operation_arguments& a, apply_set_system_call_operation_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_set_system_call_operation_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_set_system_call_operation_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_set_system_call_operation_arguments* New() const final {
    return new apply_set_system_call_operation_arguments();
  }

  apply_set_system_call_operation_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_set_system_call_operation_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_set_system_call_operation_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_set_system_call_operation_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_set_system_call_operation_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_set_system_call_operation_arguments";
  }
  protected:
  explicit apply_set_system_call_operation_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpFieldNumber = 1,
  };
  // .koinos.protocol.set_system_call_operation op = 1;
  bool has_op() const;
  private:
  bool _internal_has_op() const;
  public:
  void clear_op();
  const ::koinos::protocol::set_system_call_operation& op() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::protocol::set_system_call_operation* release_op();
  ::koinos::protocol::set_system_call_operation* mutable_op();
  void set_allocated_op(::koinos::protocol::set_system_call_operation* op);
  private:
  const ::koinos::protocol::set_system_call_operation& _internal_op() const;
  ::koinos::protocol::set_system_call_operation* _internal_mutable_op();
  public:
  void unsafe_arena_set_allocated_op(
      ::koinos::protocol::set_system_call_operation* op);
  ::koinos::protocol::set_system_call_operation* unsafe_arena_release_op();

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_set_system_call_operation_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::protocol::set_system_call_operation* op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class apply_set_system_call_operation_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.apply_set_system_call_operation_result) */ {
 public:
  inline apply_set_system_call_operation_result() : apply_set_system_call_operation_result(nullptr) {}
  ~apply_set_system_call_operation_result() override;
  explicit constexpr apply_set_system_call_operation_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  apply_set_system_call_operation_result(const apply_set_system_call_operation_result& from);
  apply_set_system_call_operation_result(apply_set_system_call_operation_result&& from) noexcept
    : apply_set_system_call_operation_result() {
    *this = ::std::move(from);
  }

  inline apply_set_system_call_operation_result& operator=(const apply_set_system_call_operation_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline apply_set_system_call_operation_result& operator=(apply_set_system_call_operation_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const apply_set_system_call_operation_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const apply_set_system_call_operation_result* internal_default_instance() {
    return reinterpret_cast<const apply_set_system_call_operation_result*>(
               &_apply_set_system_call_operation_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(apply_set_system_call_operation_result& a, apply_set_system_call_operation_result& b) {
    a.Swap(&b);
  }
  inline void Swap(apply_set_system_call_operation_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(apply_set_system_call_operation_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline apply_set_system_call_operation_result* New() const final {
    return new apply_set_system_call_operation_result();
  }

  apply_set_system_call_operation_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<apply_set_system_call_operation_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const apply_set_system_call_operation_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const apply_set_system_call_operation_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(apply_set_system_call_operation_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.apply_set_system_call_operation_result";
  }
  protected:
  explicit apply_set_system_call_operation_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.apply_set_system_call_operation_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class put_object_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.put_object_arguments) */ {
 public:
  inline put_object_arguments() : put_object_arguments(nullptr) {}
  ~put_object_arguments() override;
  explicit constexpr put_object_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  put_object_arguments(const put_object_arguments& from);
  put_object_arguments(put_object_arguments&& from) noexcept
    : put_object_arguments() {
    *this = ::std::move(from);
  }

  inline put_object_arguments& operator=(const put_object_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline put_object_arguments& operator=(put_object_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const put_object_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const put_object_arguments* internal_default_instance() {
    return reinterpret_cast<const put_object_arguments*>(
               &_put_object_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(put_object_arguments& a, put_object_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(put_object_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(put_object_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline put_object_arguments* New() const final {
    return new put_object_arguments();
  }

  put_object_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<put_object_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const put_object_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const put_object_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(put_object_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.put_object_arguments";
  }
  protected:
  explicit put_object_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kObjFieldNumber = 3,
    kSpaceFieldNumber = 1,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes obj = 3;
  void clear_obj();
  const std::string& obj() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_obj(ArgT0&& arg0, ArgT... args);
  std::string* mutable_obj();
  PROTOBUF_MUST_USE_RESULT std::string* release_obj();
  void set_allocated_obj(std::string* obj);
  private:
  const std::string& _internal_obj() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obj(const std::string& value);
  std::string* _internal_mutable_obj();
  public:

  // .koinos.chain.object_space space = 1;
  bool has_space() const;
  private:
  bool _internal_has_space() const;
  public:
  void clear_space();
  const ::koinos::chain::object_space& space() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::object_space* release_space();
  ::koinos::chain::object_space* mutable_space();
  void set_allocated_space(::koinos::chain::object_space* space);
  private:
  const ::koinos::chain::object_space& _internal_space() const;
  ::koinos::chain::object_space* _internal_mutable_space();
  public:
  void unsafe_arena_set_allocated_space(
      ::koinos::chain::object_space* space);
  ::koinos::chain::object_space* unsafe_arena_release_space();

  // @@protoc_insertion_point(class_scope:koinos.chain.put_object_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obj_;
  ::koinos::chain::object_space* space_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class put_object_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.put_object_result) */ {
 public:
  inline put_object_result() : put_object_result(nullptr) {}
  ~put_object_result() override;
  explicit constexpr put_object_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  put_object_result(const put_object_result& from);
  put_object_result(put_object_result&& from) noexcept
    : put_object_result() {
    *this = ::std::move(from);
  }

  inline put_object_result& operator=(const put_object_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline put_object_result& operator=(put_object_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const put_object_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const put_object_result* internal_default_instance() {
    return reinterpret_cast<const put_object_result*>(
               &_put_object_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(put_object_result& a, put_object_result& b) {
    a.Swap(&b);
  }
  inline void Swap(put_object_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(put_object_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline put_object_result* New() const final {
    return new put_object_result();
  }

  put_object_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<put_object_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const put_object_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const put_object_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(put_object_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.put_object_result";
  }
  protected:
  explicit put_object_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.put_object_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_object_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_object_arguments) */ {
 public:
  inline get_object_arguments() : get_object_arguments(nullptr) {}
  ~get_object_arguments() override;
  explicit constexpr get_object_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_object_arguments(const get_object_arguments& from);
  get_object_arguments(get_object_arguments&& from) noexcept
    : get_object_arguments() {
    *this = ::std::move(from);
  }

  inline get_object_arguments& operator=(const get_object_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_object_arguments& operator=(get_object_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_object_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_object_arguments* internal_default_instance() {
    return reinterpret_cast<const get_object_arguments*>(
               &_get_object_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(get_object_arguments& a, get_object_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_object_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_object_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_object_arguments* New() const final {
    return new get_object_arguments();
  }

  get_object_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_object_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_object_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_object_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_object_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_object_arguments";
  }
  protected:
  explicit get_object_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kSpaceFieldNumber = 1,
    kObjectSizeHintFieldNumber = 3,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .koinos.chain.object_space space = 1;
  bool has_space() const;
  private:
  bool _internal_has_space() const;
  public:
  void clear_space();
  const ::koinos::chain::object_space& space() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::object_space* release_space();
  ::koinos::chain::object_space* mutable_space();
  void set_allocated_space(::koinos::chain::object_space* space);
  private:
  const ::koinos::chain::object_space& _internal_space() const;
  ::koinos::chain::object_space* _internal_mutable_space();
  public:
  void unsafe_arena_set_allocated_space(
      ::koinos::chain::object_space* space);
  ::koinos::chain::object_space* unsafe_arena_release_space();

  // uint32 object_size_hint = 3;
  void clear_object_size_hint();
  ::PROTOBUF_NAMESPACE_ID::uint32 object_size_hint() const;
  void set_object_size_hint(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_object_size_hint() const;
  void _internal_set_object_size_hint(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_object_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::koinos::chain::object_space* space_;
  ::PROTOBUF_NAMESPACE_ID::uint32 object_size_hint_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_object_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_object_result) */ {
 public:
  inline get_object_result() : get_object_result(nullptr) {}
  ~get_object_result() override;
  explicit constexpr get_object_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_object_result(const get_object_result& from);
  get_object_result(get_object_result&& from) noexcept
    : get_object_result() {
    *this = ::std::move(from);
  }

  inline get_object_result& operator=(const get_object_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_object_result& operator=(get_object_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_object_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_object_result* internal_default_instance() {
    return reinterpret_cast<const get_object_result*>(
               &_get_object_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(get_object_result& a, get_object_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_object_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_object_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_object_result* New() const final {
    return new get_object_result();
  }

  get_object_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_object_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_object_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_object_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_object_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_object_result";
  }
  protected:
  explicit get_object_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 3,
  };
  // bytes value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_object_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_next_object_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_next_object_arguments) */ {
 public:
  inline get_next_object_arguments() : get_next_object_arguments(nullptr) {}
  ~get_next_object_arguments() override;
  explicit constexpr get_next_object_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_next_object_arguments(const get_next_object_arguments& from);
  get_next_object_arguments(get_next_object_arguments&& from) noexcept
    : get_next_object_arguments() {
    *this = ::std::move(from);
  }

  inline get_next_object_arguments& operator=(const get_next_object_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_next_object_arguments& operator=(get_next_object_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_next_object_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_next_object_arguments* internal_default_instance() {
    return reinterpret_cast<const get_next_object_arguments*>(
               &_get_next_object_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(get_next_object_arguments& a, get_next_object_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_next_object_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_next_object_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_next_object_arguments* New() const final {
    return new get_next_object_arguments();
  }

  get_next_object_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_next_object_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_next_object_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_next_object_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_next_object_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_next_object_arguments";
  }
  protected:
  explicit get_next_object_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kSpaceFieldNumber = 1,
    kObjectSizeHintFieldNumber = 3,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .koinos.chain.object_space space = 1;
  bool has_space() const;
  private:
  bool _internal_has_space() const;
  public:
  void clear_space();
  const ::koinos::chain::object_space& space() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::object_space* release_space();
  ::koinos::chain::object_space* mutable_space();
  void set_allocated_space(::koinos::chain::object_space* space);
  private:
  const ::koinos::chain::object_space& _internal_space() const;
  ::koinos::chain::object_space* _internal_mutable_space();
  public:
  void unsafe_arena_set_allocated_space(
      ::koinos::chain::object_space* space);
  ::koinos::chain::object_space* unsafe_arena_release_space();

  // uint32 object_size_hint = 3;
  void clear_object_size_hint();
  ::PROTOBUF_NAMESPACE_ID::uint32 object_size_hint() const;
  void set_object_size_hint(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_object_size_hint() const;
  void _internal_set_object_size_hint(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_next_object_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::koinos::chain::object_space* space_;
  ::PROTOBUF_NAMESPACE_ID::uint32 object_size_hint_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_next_object_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_next_object_result) */ {
 public:
  inline get_next_object_result() : get_next_object_result(nullptr) {}
  ~get_next_object_result() override;
  explicit constexpr get_next_object_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_next_object_result(const get_next_object_result& from);
  get_next_object_result(get_next_object_result&& from) noexcept
    : get_next_object_result() {
    *this = ::std::move(from);
  }

  inline get_next_object_result& operator=(const get_next_object_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_next_object_result& operator=(get_next_object_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_next_object_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_next_object_result* internal_default_instance() {
    return reinterpret_cast<const get_next_object_result*>(
               &_get_next_object_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(get_next_object_result& a, get_next_object_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_next_object_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_next_object_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_next_object_result* New() const final {
    return new get_next_object_result();
  }

  get_next_object_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_next_object_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_next_object_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_next_object_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_next_object_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_next_object_result";
  }
  protected:
  explicit get_next_object_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 3,
  };
  // bytes value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_next_object_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_prev_object_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_prev_object_arguments) */ {
 public:
  inline get_prev_object_arguments() : get_prev_object_arguments(nullptr) {}
  ~get_prev_object_arguments() override;
  explicit constexpr get_prev_object_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_prev_object_arguments(const get_prev_object_arguments& from);
  get_prev_object_arguments(get_prev_object_arguments&& from) noexcept
    : get_prev_object_arguments() {
    *this = ::std::move(from);
  }

  inline get_prev_object_arguments& operator=(const get_prev_object_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_prev_object_arguments& operator=(get_prev_object_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_prev_object_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_prev_object_arguments* internal_default_instance() {
    return reinterpret_cast<const get_prev_object_arguments*>(
               &_get_prev_object_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(get_prev_object_arguments& a, get_prev_object_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_prev_object_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_prev_object_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_prev_object_arguments* New() const final {
    return new get_prev_object_arguments();
  }

  get_prev_object_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_prev_object_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_prev_object_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_prev_object_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_prev_object_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_prev_object_arguments";
  }
  protected:
  explicit get_prev_object_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kSpaceFieldNumber = 1,
    kObjectSizeHintFieldNumber = 3,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .koinos.chain.object_space space = 1;
  bool has_space() const;
  private:
  bool _internal_has_space() const;
  public:
  void clear_space();
  const ::koinos::chain::object_space& space() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::object_space* release_space();
  ::koinos::chain::object_space* mutable_space();
  void set_allocated_space(::koinos::chain::object_space* space);
  private:
  const ::koinos::chain::object_space& _internal_space() const;
  ::koinos::chain::object_space* _internal_mutable_space();
  public:
  void unsafe_arena_set_allocated_space(
      ::koinos::chain::object_space* space);
  ::koinos::chain::object_space* unsafe_arena_release_space();

  // uint32 object_size_hint = 3;
  void clear_object_size_hint();
  ::PROTOBUF_NAMESPACE_ID::uint32 object_size_hint() const;
  void set_object_size_hint(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_object_size_hint() const;
  void _internal_set_object_size_hint(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_prev_object_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::koinos::chain::object_space* space_;
  ::PROTOBUF_NAMESPACE_ID::uint32 object_size_hint_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_prev_object_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_prev_object_result) */ {
 public:
  inline get_prev_object_result() : get_prev_object_result(nullptr) {}
  ~get_prev_object_result() override;
  explicit constexpr get_prev_object_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_prev_object_result(const get_prev_object_result& from);
  get_prev_object_result(get_prev_object_result&& from) noexcept
    : get_prev_object_result() {
    *this = ::std::move(from);
  }

  inline get_prev_object_result& operator=(const get_prev_object_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_prev_object_result& operator=(get_prev_object_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_prev_object_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_prev_object_result* internal_default_instance() {
    return reinterpret_cast<const get_prev_object_result*>(
               &_get_prev_object_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(get_prev_object_result& a, get_prev_object_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_prev_object_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_prev_object_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_prev_object_result* New() const final {
    return new get_prev_object_result();
  }

  get_prev_object_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_prev_object_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_prev_object_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_prev_object_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_prev_object_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_prev_object_result";
  }
  protected:
  explicit get_prev_object_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 3,
  };
  // bytes value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_prev_object_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class call_contract_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.call_contract_arguments) */ {
 public:
  inline call_contract_arguments() : call_contract_arguments(nullptr) {}
  ~call_contract_arguments() override;
  explicit constexpr call_contract_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  call_contract_arguments(const call_contract_arguments& from);
  call_contract_arguments(call_contract_arguments&& from) noexcept
    : call_contract_arguments() {
    *this = ::std::move(from);
  }

  inline call_contract_arguments& operator=(const call_contract_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline call_contract_arguments& operator=(call_contract_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const call_contract_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const call_contract_arguments* internal_default_instance() {
    return reinterpret_cast<const call_contract_arguments*>(
               &_call_contract_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(call_contract_arguments& a, call_contract_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(call_contract_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(call_contract_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline call_contract_arguments* New() const final {
    return new call_contract_arguments();
  }

  call_contract_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<call_contract_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const call_contract_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const call_contract_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(call_contract_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.call_contract_arguments";
  }
  protected:
  explicit call_contract_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 1,
    kArgsFieldNumber = 3,
    kEntryPointFieldNumber = 2,
  };
  // bytes contract_id = 1;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // bytes args = 3;
  void clear_args();
  const std::string& args() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_args(ArgT0&& arg0, ArgT... args);
  std::string* mutable_args();
  PROTOBUF_MUST_USE_RESULT std::string* release_args();
  void set_allocated_args(std::string* args);
  private:
  const std::string& _internal_args() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_args(const std::string& value);
  std::string* _internal_mutable_args();
  public:

  // uint32 entry_point = 2;
  void clear_entry_point();
  ::PROTOBUF_NAMESPACE_ID::uint32 entry_point() const;
  void set_entry_point(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_entry_point() const;
  void _internal_set_entry_point(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.call_contract_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr args_;
  ::PROTOBUF_NAMESPACE_ID::uint32 entry_point_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class call_contract_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.call_contract_result) */ {
 public:
  inline call_contract_result() : call_contract_result(nullptr) {}
  ~call_contract_result() override;
  explicit constexpr call_contract_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  call_contract_result(const call_contract_result& from);
  call_contract_result(call_contract_result&& from) noexcept
    : call_contract_result() {
    *this = ::std::move(from);
  }

  inline call_contract_result& operator=(const call_contract_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline call_contract_result& operator=(call_contract_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const call_contract_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const call_contract_result* internal_default_instance() {
    return reinterpret_cast<const call_contract_result*>(
               &_call_contract_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(call_contract_result& a, call_contract_result& b) {
    a.Swap(&b);
  }
  inline void Swap(call_contract_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(call_contract_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline call_contract_result* New() const final {
    return new call_contract_result();
  }

  call_contract_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<call_contract_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const call_contract_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const call_contract_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(call_contract_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.call_contract_result";
  }
  protected:
  explicit call_contract_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.call_contract_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_entry_point_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_entry_point_arguments) */ {
 public:
  inline get_entry_point_arguments() : get_entry_point_arguments(nullptr) {}
  ~get_entry_point_arguments() override;
  explicit constexpr get_entry_point_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_entry_point_arguments(const get_entry_point_arguments& from);
  get_entry_point_arguments(get_entry_point_arguments&& from) noexcept
    : get_entry_point_arguments() {
    *this = ::std::move(from);
  }

  inline get_entry_point_arguments& operator=(const get_entry_point_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_entry_point_arguments& operator=(get_entry_point_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_entry_point_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_entry_point_arguments* internal_default_instance() {
    return reinterpret_cast<const get_entry_point_arguments*>(
               &_get_entry_point_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(get_entry_point_arguments& a, get_entry_point_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_entry_point_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_entry_point_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_entry_point_arguments* New() const final {
    return new get_entry_point_arguments();
  }

  get_entry_point_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_entry_point_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_entry_point_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_entry_point_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_entry_point_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_entry_point_arguments";
  }
  protected:
  explicit get_entry_point_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.get_entry_point_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_entry_point_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_entry_point_result) */ {
 public:
  inline get_entry_point_result() : get_entry_point_result(nullptr) {}
  ~get_entry_point_result() override;
  explicit constexpr get_entry_point_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_entry_point_result(const get_entry_point_result& from);
  get_entry_point_result(get_entry_point_result&& from) noexcept
    : get_entry_point_result() {
    *this = ::std::move(from);
  }

  inline get_entry_point_result& operator=(const get_entry_point_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_entry_point_result& operator=(get_entry_point_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_entry_point_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_entry_point_result* internal_default_instance() {
    return reinterpret_cast<const get_entry_point_result*>(
               &_get_entry_point_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(get_entry_point_result& a, get_entry_point_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_entry_point_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_entry_point_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_entry_point_result* New() const final {
    return new get_entry_point_result();
  }

  get_entry_point_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_entry_point_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_entry_point_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_entry_point_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_entry_point_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_entry_point_result";
  }
  protected:
  explicit get_entry_point_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_entry_point_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_contract_arguments_size_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_contract_arguments_size_arguments) */ {
 public:
  inline get_contract_arguments_size_arguments() : get_contract_arguments_size_arguments(nullptr) {}
  ~get_contract_arguments_size_arguments() override;
  explicit constexpr get_contract_arguments_size_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_contract_arguments_size_arguments(const get_contract_arguments_size_arguments& from);
  get_contract_arguments_size_arguments(get_contract_arguments_size_arguments&& from) noexcept
    : get_contract_arguments_size_arguments() {
    *this = ::std::move(from);
  }

  inline get_contract_arguments_size_arguments& operator=(const get_contract_arguments_size_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_contract_arguments_size_arguments& operator=(get_contract_arguments_size_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_contract_arguments_size_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_contract_arguments_size_arguments* internal_default_instance() {
    return reinterpret_cast<const get_contract_arguments_size_arguments*>(
               &_get_contract_arguments_size_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(get_contract_arguments_size_arguments& a, get_contract_arguments_size_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_contract_arguments_size_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_contract_arguments_size_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_contract_arguments_size_arguments* New() const final {
    return new get_contract_arguments_size_arguments();
  }

  get_contract_arguments_size_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_contract_arguments_size_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_contract_arguments_size_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_contract_arguments_size_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_contract_arguments_size_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_contract_arguments_size_arguments";
  }
  protected:
  explicit get_contract_arguments_size_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.get_contract_arguments_size_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_contract_arguments_size_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_contract_arguments_size_result) */ {
 public:
  inline get_contract_arguments_size_result() : get_contract_arguments_size_result(nullptr) {}
  ~get_contract_arguments_size_result() override;
  explicit constexpr get_contract_arguments_size_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_contract_arguments_size_result(const get_contract_arguments_size_result& from);
  get_contract_arguments_size_result(get_contract_arguments_size_result&& from) noexcept
    : get_contract_arguments_size_result() {
    *this = ::std::move(from);
  }

  inline get_contract_arguments_size_result& operator=(const get_contract_arguments_size_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_contract_arguments_size_result& operator=(get_contract_arguments_size_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_contract_arguments_size_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_contract_arguments_size_result* internal_default_instance() {
    return reinterpret_cast<const get_contract_arguments_size_result*>(
               &_get_contract_arguments_size_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(get_contract_arguments_size_result& a, get_contract_arguments_size_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_contract_arguments_size_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_contract_arguments_size_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_contract_arguments_size_result* New() const final {
    return new get_contract_arguments_size_result();
  }

  get_contract_arguments_size_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_contract_arguments_size_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_contract_arguments_size_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_contract_arguments_size_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_contract_arguments_size_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_contract_arguments_size_result";
  }
  protected:
  explicit get_contract_arguments_size_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_contract_arguments_size_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_contract_arguments_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_contract_arguments_arguments) */ {
 public:
  inline get_contract_arguments_arguments() : get_contract_arguments_arguments(nullptr) {}
  ~get_contract_arguments_arguments() override;
  explicit constexpr get_contract_arguments_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_contract_arguments_arguments(const get_contract_arguments_arguments& from);
  get_contract_arguments_arguments(get_contract_arguments_arguments&& from) noexcept
    : get_contract_arguments_arguments() {
    *this = ::std::move(from);
  }

  inline get_contract_arguments_arguments& operator=(const get_contract_arguments_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_contract_arguments_arguments& operator=(get_contract_arguments_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_contract_arguments_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_contract_arguments_arguments* internal_default_instance() {
    return reinterpret_cast<const get_contract_arguments_arguments*>(
               &_get_contract_arguments_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(get_contract_arguments_arguments& a, get_contract_arguments_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_contract_arguments_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_contract_arguments_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_contract_arguments_arguments* New() const final {
    return new get_contract_arguments_arguments();
  }

  get_contract_arguments_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_contract_arguments_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_contract_arguments_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_contract_arguments_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_contract_arguments_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_contract_arguments_arguments";
  }
  protected:
  explicit get_contract_arguments_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.get_contract_arguments_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_contract_arguments_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_contract_arguments_result) */ {
 public:
  inline get_contract_arguments_result() : get_contract_arguments_result(nullptr) {}
  ~get_contract_arguments_result() override;
  explicit constexpr get_contract_arguments_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_contract_arguments_result(const get_contract_arguments_result& from);
  get_contract_arguments_result(get_contract_arguments_result&& from) noexcept
    : get_contract_arguments_result() {
    *this = ::std::move(from);
  }

  inline get_contract_arguments_result& operator=(const get_contract_arguments_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_contract_arguments_result& operator=(get_contract_arguments_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_contract_arguments_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_contract_arguments_result* internal_default_instance() {
    return reinterpret_cast<const get_contract_arguments_result*>(
               &_get_contract_arguments_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(get_contract_arguments_result& a, get_contract_arguments_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_contract_arguments_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_contract_arguments_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_contract_arguments_result* New() const final {
    return new get_contract_arguments_result();
  }

  get_contract_arguments_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_contract_arguments_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_contract_arguments_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_contract_arguments_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_contract_arguments_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_contract_arguments_result";
  }
  protected:
  explicit get_contract_arguments_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_contract_arguments_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class set_contract_result_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.set_contract_result_arguments) */ {
 public:
  inline set_contract_result_arguments() : set_contract_result_arguments(nullptr) {}
  ~set_contract_result_arguments() override;
  explicit constexpr set_contract_result_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  set_contract_result_arguments(const set_contract_result_arguments& from);
  set_contract_result_arguments(set_contract_result_arguments&& from) noexcept
    : set_contract_result_arguments() {
    *this = ::std::move(from);
  }

  inline set_contract_result_arguments& operator=(const set_contract_result_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline set_contract_result_arguments& operator=(set_contract_result_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const set_contract_result_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const set_contract_result_arguments* internal_default_instance() {
    return reinterpret_cast<const set_contract_result_arguments*>(
               &_set_contract_result_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(set_contract_result_arguments& a, set_contract_result_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(set_contract_result_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(set_contract_result_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline set_contract_result_arguments* New() const final {
    return new set_contract_result_arguments();
  }

  set_contract_result_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<set_contract_result_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const set_contract_result_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const set_contract_result_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(set_contract_result_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.set_contract_result_arguments";
  }
  protected:
  explicit set_contract_result_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.set_contract_result_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class set_contract_result_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.set_contract_result_result) */ {
 public:
  inline set_contract_result_result() : set_contract_result_result(nullptr) {}
  ~set_contract_result_result() override;
  explicit constexpr set_contract_result_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  set_contract_result_result(const set_contract_result_result& from);
  set_contract_result_result(set_contract_result_result&& from) noexcept
    : set_contract_result_result() {
    *this = ::std::move(from);
  }

  inline set_contract_result_result& operator=(const set_contract_result_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline set_contract_result_result& operator=(set_contract_result_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const set_contract_result_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const set_contract_result_result* internal_default_instance() {
    return reinterpret_cast<const set_contract_result_result*>(
               &_set_contract_result_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(set_contract_result_result& a, set_contract_result_result& b) {
    a.Swap(&b);
  }
  inline void Swap(set_contract_result_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(set_contract_result_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline set_contract_result_result* New() const final {
    return new set_contract_result_result();
  }

  set_contract_result_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<set_contract_result_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const set_contract_result_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const set_contract_result_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(set_contract_result_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.set_contract_result_result";
  }
  protected:
  explicit set_contract_result_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.set_contract_result_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class exit_contract_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.exit_contract_arguments) */ {
 public:
  inline exit_contract_arguments() : exit_contract_arguments(nullptr) {}
  ~exit_contract_arguments() override;
  explicit constexpr exit_contract_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  exit_contract_arguments(const exit_contract_arguments& from);
  exit_contract_arguments(exit_contract_arguments&& from) noexcept
    : exit_contract_arguments() {
    *this = ::std::move(from);
  }

  inline exit_contract_arguments& operator=(const exit_contract_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline exit_contract_arguments& operator=(exit_contract_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const exit_contract_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const exit_contract_arguments* internal_default_instance() {
    return reinterpret_cast<const exit_contract_arguments*>(
               &_exit_contract_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(exit_contract_arguments& a, exit_contract_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(exit_contract_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(exit_contract_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline exit_contract_arguments* New() const final {
    return new exit_contract_arguments();
  }

  exit_contract_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<exit_contract_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const exit_contract_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const exit_contract_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(exit_contract_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.exit_contract_arguments";
  }
  protected:
  explicit exit_contract_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExitCodeFieldNumber = 1,
  };
  // uint32 exit_code = 1;
  void clear_exit_code();
  ::PROTOBUF_NAMESPACE_ID::uint32 exit_code() const;
  void set_exit_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_exit_code() const;
  void _internal_set_exit_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.exit_contract_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 exit_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class exit_contract_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.exit_contract_result) */ {
 public:
  inline exit_contract_result() : exit_contract_result(nullptr) {}
  ~exit_contract_result() override;
  explicit constexpr exit_contract_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  exit_contract_result(const exit_contract_result& from);
  exit_contract_result(exit_contract_result&& from) noexcept
    : exit_contract_result() {
    *this = ::std::move(from);
  }

  inline exit_contract_result& operator=(const exit_contract_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline exit_contract_result& operator=(exit_contract_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const exit_contract_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const exit_contract_result* internal_default_instance() {
    return reinterpret_cast<const exit_contract_result*>(
               &_exit_contract_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(exit_contract_result& a, exit_contract_result& b) {
    a.Swap(&b);
  }
  inline void Swap(exit_contract_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(exit_contract_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline exit_contract_result* New() const final {
    return new exit_contract_result();
  }

  exit_contract_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<exit_contract_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const exit_contract_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const exit_contract_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(exit_contract_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.exit_contract_result";
  }
  protected:
  explicit exit_contract_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.exit_contract_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_head_info_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_head_info_arguments) */ {
 public:
  inline get_head_info_arguments() : get_head_info_arguments(nullptr) {}
  ~get_head_info_arguments() override;
  explicit constexpr get_head_info_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_head_info_arguments(const get_head_info_arguments& from);
  get_head_info_arguments(get_head_info_arguments&& from) noexcept
    : get_head_info_arguments() {
    *this = ::std::move(from);
  }

  inline get_head_info_arguments& operator=(const get_head_info_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_head_info_arguments& operator=(get_head_info_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_head_info_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_head_info_arguments* internal_default_instance() {
    return reinterpret_cast<const get_head_info_arguments*>(
               &_get_head_info_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(get_head_info_arguments& a, get_head_info_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_head_info_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_head_info_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_head_info_arguments* New() const final {
    return new get_head_info_arguments();
  }

  get_head_info_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_head_info_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_head_info_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_head_info_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_head_info_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_head_info_arguments";
  }
  protected:
  explicit get_head_info_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.get_head_info_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_head_info_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_head_info_result) */ {
 public:
  inline get_head_info_result() : get_head_info_result(nullptr) {}
  ~get_head_info_result() override;
  explicit constexpr get_head_info_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_head_info_result(const get_head_info_result& from);
  get_head_info_result(get_head_info_result&& from) noexcept
    : get_head_info_result() {
    *this = ::std::move(from);
  }

  inline get_head_info_result& operator=(const get_head_info_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_head_info_result& operator=(get_head_info_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_head_info_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_head_info_result* internal_default_instance() {
    return reinterpret_cast<const get_head_info_result*>(
               &_get_head_info_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(get_head_info_result& a, get_head_info_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_head_info_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_head_info_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_head_info_result* New() const final {
    return new get_head_info_result();
  }

  get_head_info_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_head_info_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_head_info_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_head_info_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_head_info_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_head_info_result";
  }
  protected:
  explicit get_head_info_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .koinos.chain.head_info value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::koinos::chain::head_info& value() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::head_info* release_value();
  ::koinos::chain::head_info* mutable_value();
  void set_allocated_value(::koinos::chain::head_info* value);
  private:
  const ::koinos::chain::head_info& _internal_value() const;
  ::koinos::chain::head_info* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::koinos::chain::head_info* value);
  ::koinos::chain::head_info* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:koinos.chain.get_head_info_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::chain::head_info* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class hash_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.hash_arguments) */ {
 public:
  inline hash_arguments() : hash_arguments(nullptr) {}
  ~hash_arguments() override;
  explicit constexpr hash_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  hash_arguments(const hash_arguments& from);
  hash_arguments(hash_arguments&& from) noexcept
    : hash_arguments() {
    *this = ::std::move(from);
  }

  inline hash_arguments& operator=(const hash_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline hash_arguments& operator=(hash_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const hash_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const hash_arguments* internal_default_instance() {
    return reinterpret_cast<const hash_arguments*>(
               &_hash_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(hash_arguments& a, hash_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(hash_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(hash_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline hash_arguments* New() const final {
    return new hash_arguments();
  }

  hash_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<hash_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const hash_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const hash_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(hash_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.hash_arguments";
  }
  protected:
  explicit hash_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjFieldNumber = 2,
    kCodeFieldNumber = 1,
    kSizeFieldNumber = 3,
  };
  // bytes obj = 2;
  void clear_obj();
  const std::string& obj() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_obj(ArgT0&& arg0, ArgT... args);
  std::string* mutable_obj();
  PROTOBUF_MUST_USE_RESULT std::string* release_obj();
  void set_allocated_obj(std::string* obj);
  private:
  const std::string& _internal_obj() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obj(const std::string& value);
  std::string* _internal_mutable_obj();
  public:

  // uint64 code = 1 [jstype = JS_STRING];
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::uint64 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 size = 3 [jstype = JS_STRING];
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.hash_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obj_;
  ::PROTOBUF_NAMESPACE_ID::uint64 code_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class hash_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.hash_result) */ {
 public:
  inline hash_result() : hash_result(nullptr) {}
  ~hash_result() override;
  explicit constexpr hash_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  hash_result(const hash_result& from);
  hash_result(hash_result&& from) noexcept
    : hash_result() {
    *this = ::std::move(from);
  }

  inline hash_result& operator=(const hash_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline hash_result& operator=(hash_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const hash_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const hash_result* internal_default_instance() {
    return reinterpret_cast<const hash_result*>(
               &_hash_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(hash_result& a, hash_result& b) {
    a.Swap(&b);
  }
  inline void Swap(hash_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(hash_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline hash_result* New() const final {
    return new hash_result();
  }

  hash_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<hash_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const hash_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const hash_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(hash_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.hash_result";
  }
  protected:
  explicit hash_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.hash_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class recover_public_key_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.recover_public_key_arguments) */ {
 public:
  inline recover_public_key_arguments() : recover_public_key_arguments(nullptr) {}
  ~recover_public_key_arguments() override;
  explicit constexpr recover_public_key_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  recover_public_key_arguments(const recover_public_key_arguments& from);
  recover_public_key_arguments(recover_public_key_arguments&& from) noexcept
    : recover_public_key_arguments() {
    *this = ::std::move(from);
  }

  inline recover_public_key_arguments& operator=(const recover_public_key_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline recover_public_key_arguments& operator=(recover_public_key_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const recover_public_key_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const recover_public_key_arguments* internal_default_instance() {
    return reinterpret_cast<const recover_public_key_arguments*>(
               &_recover_public_key_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(recover_public_key_arguments& a, recover_public_key_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(recover_public_key_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(recover_public_key_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline recover_public_key_arguments* New() const final {
    return new recover_public_key_arguments();
  }

  recover_public_key_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<recover_public_key_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const recover_public_key_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const recover_public_key_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(recover_public_key_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.recover_public_key_arguments";
  }
  protected:
  explicit recover_public_key_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureDataFieldNumber = 1,
    kDigestFieldNumber = 2,
  };
  // bytes signature_data = 1;
  void clear_signature_data();
  const std::string& signature_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_signature_data();
  void set_allocated_signature_data(std::string* signature_data);
  private:
  const std::string& _internal_signature_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature_data(const std::string& value);
  std::string* _internal_mutable_signature_data();
  public:

  // bytes digest = 2;
  void clear_digest();
  const std::string& digest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_digest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_digest();
  PROTOBUF_MUST_USE_RESULT std::string* release_digest();
  void set_allocated_digest(std::string* digest);
  private:
  const std::string& _internal_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_digest(const std::string& value);
  std::string* _internal_mutable_digest();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.recover_public_key_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class recover_public_key_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.recover_public_key_result) */ {
 public:
  inline recover_public_key_result() : recover_public_key_result(nullptr) {}
  ~recover_public_key_result() override;
  explicit constexpr recover_public_key_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  recover_public_key_result(const recover_public_key_result& from);
  recover_public_key_result(recover_public_key_result&& from) noexcept
    : recover_public_key_result() {
    *this = ::std::move(from);
  }

  inline recover_public_key_result& operator=(const recover_public_key_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline recover_public_key_result& operator=(recover_public_key_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const recover_public_key_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const recover_public_key_result* internal_default_instance() {
    return reinterpret_cast<const recover_public_key_result*>(
               &_recover_public_key_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(recover_public_key_result& a, recover_public_key_result& b) {
    a.Swap(&b);
  }
  inline void Swap(recover_public_key_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(recover_public_key_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline recover_public_key_result* New() const final {
    return new recover_public_key_result();
  }

  recover_public_key_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<recover_public_key_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const recover_public_key_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const recover_public_key_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(recover_public_key_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.recover_public_key_result";
  }
  protected:
  explicit recover_public_key_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.recover_public_key_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_transaction_payer_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_transaction_payer_arguments) */ {
 public:
  inline get_transaction_payer_arguments() : get_transaction_payer_arguments(nullptr) {}
  ~get_transaction_payer_arguments() override;
  explicit constexpr get_transaction_payer_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_transaction_payer_arguments(const get_transaction_payer_arguments& from);
  get_transaction_payer_arguments(get_transaction_payer_arguments&& from) noexcept
    : get_transaction_payer_arguments() {
    *this = ::std::move(from);
  }

  inline get_transaction_payer_arguments& operator=(const get_transaction_payer_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_transaction_payer_arguments& operator=(get_transaction_payer_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_transaction_payer_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_transaction_payer_arguments* internal_default_instance() {
    return reinterpret_cast<const get_transaction_payer_arguments*>(
               &_get_transaction_payer_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(get_transaction_payer_arguments& a, get_transaction_payer_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_transaction_payer_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_transaction_payer_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_transaction_payer_arguments* New() const final {
    return new get_transaction_payer_arguments();
  }

  get_transaction_payer_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_transaction_payer_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_transaction_payer_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_transaction_payer_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_transaction_payer_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_transaction_payer_arguments";
  }
  protected:
  explicit get_transaction_payer_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionFieldNumber = 1,
  };
  // .koinos.protocol.transaction transaction = 1;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::koinos::protocol::transaction& transaction() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::protocol::transaction* release_transaction();
  ::koinos::protocol::transaction* mutable_transaction();
  void set_allocated_transaction(::koinos::protocol::transaction* transaction);
  private:
  const ::koinos::protocol::transaction& _internal_transaction() const;
  ::koinos::protocol::transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::koinos::protocol::transaction* transaction);
  ::koinos::protocol::transaction* unsafe_arena_release_transaction();

  // @@protoc_insertion_point(class_scope:koinos.chain.get_transaction_payer_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::protocol::transaction* transaction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_transaction_payer_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_transaction_payer_result) */ {
 public:
  inline get_transaction_payer_result() : get_transaction_payer_result(nullptr) {}
  ~get_transaction_payer_result() override;
  explicit constexpr get_transaction_payer_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_transaction_payer_result(const get_transaction_payer_result& from);
  get_transaction_payer_result(get_transaction_payer_result&& from) noexcept
    : get_transaction_payer_result() {
    *this = ::std::move(from);
  }

  inline get_transaction_payer_result& operator=(const get_transaction_payer_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_transaction_payer_result& operator=(get_transaction_payer_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_transaction_payer_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_transaction_payer_result* internal_default_instance() {
    return reinterpret_cast<const get_transaction_payer_result*>(
               &_get_transaction_payer_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(get_transaction_payer_result& a, get_transaction_payer_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_transaction_payer_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_transaction_payer_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_transaction_payer_result* New() const final {
    return new get_transaction_payer_result();
  }

  get_transaction_payer_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_transaction_payer_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_transaction_payer_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_transaction_payer_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_transaction_payer_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_transaction_payer_result";
  }
  protected:
  explicit get_transaction_payer_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_transaction_payer_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_account_rc_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_account_rc_arguments) */ {
 public:
  inline get_account_rc_arguments() : get_account_rc_arguments(nullptr) {}
  ~get_account_rc_arguments() override;
  explicit constexpr get_account_rc_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_account_rc_arguments(const get_account_rc_arguments& from);
  get_account_rc_arguments(get_account_rc_arguments&& from) noexcept
    : get_account_rc_arguments() {
    *this = ::std::move(from);
  }

  inline get_account_rc_arguments& operator=(const get_account_rc_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_account_rc_arguments& operator=(get_account_rc_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_account_rc_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_account_rc_arguments* internal_default_instance() {
    return reinterpret_cast<const get_account_rc_arguments*>(
               &_get_account_rc_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(get_account_rc_arguments& a, get_account_rc_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_account_rc_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_account_rc_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_account_rc_arguments* New() const final {
    return new get_account_rc_arguments();
  }

  get_account_rc_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_account_rc_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_account_rc_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_account_rc_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_account_rc_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_account_rc_arguments";
  }
  protected:
  explicit get_account_rc_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
  };
  // bytes account = 1;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_MUST_USE_RESULT std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_account_rc_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_account_rc_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_account_rc_result) */ {
 public:
  inline get_account_rc_result() : get_account_rc_result(nullptr) {}
  ~get_account_rc_result() override;
  explicit constexpr get_account_rc_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_account_rc_result(const get_account_rc_result& from);
  get_account_rc_result(get_account_rc_result&& from) noexcept
    : get_account_rc_result() {
    *this = ::std::move(from);
  }

  inline get_account_rc_result& operator=(const get_account_rc_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_account_rc_result& operator=(get_account_rc_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_account_rc_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_account_rc_result* internal_default_instance() {
    return reinterpret_cast<const get_account_rc_result*>(
               &_get_account_rc_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(get_account_rc_result& a, get_account_rc_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_account_rc_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_account_rc_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_account_rc_result* New() const final {
    return new get_account_rc_result();
  }

  get_account_rc_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_account_rc_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_account_rc_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_account_rc_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_account_rc_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_account_rc_result";
  }
  protected:
  explicit get_account_rc_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint64 value = 1 [jstype = JS_STRING];
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_account_rc_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class consume_account_rc_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.consume_account_rc_arguments) */ {
 public:
  inline consume_account_rc_arguments() : consume_account_rc_arguments(nullptr) {}
  ~consume_account_rc_arguments() override;
  explicit constexpr consume_account_rc_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  consume_account_rc_arguments(const consume_account_rc_arguments& from);
  consume_account_rc_arguments(consume_account_rc_arguments&& from) noexcept
    : consume_account_rc_arguments() {
    *this = ::std::move(from);
  }

  inline consume_account_rc_arguments& operator=(const consume_account_rc_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline consume_account_rc_arguments& operator=(consume_account_rc_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const consume_account_rc_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const consume_account_rc_arguments* internal_default_instance() {
    return reinterpret_cast<const consume_account_rc_arguments*>(
               &_consume_account_rc_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(consume_account_rc_arguments& a, consume_account_rc_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(consume_account_rc_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(consume_account_rc_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline consume_account_rc_arguments* New() const final {
    return new consume_account_rc_arguments();
  }

  consume_account_rc_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<consume_account_rc_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const consume_account_rc_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const consume_account_rc_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(consume_account_rc_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.consume_account_rc_arguments";
  }
  protected:
  explicit consume_account_rc_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // bytes account = 1;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_MUST_USE_RESULT std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // uint64 value = 2 [jstype = JS_STRING];
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.consume_account_rc_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class consume_account_rc_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.consume_account_rc_result) */ {
 public:
  inline consume_account_rc_result() : consume_account_rc_result(nullptr) {}
  ~consume_account_rc_result() override;
  explicit constexpr consume_account_rc_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  consume_account_rc_result(const consume_account_rc_result& from);
  consume_account_rc_result(consume_account_rc_result&& from) noexcept
    : consume_account_rc_result() {
    *this = ::std::move(from);
  }

  inline consume_account_rc_result& operator=(const consume_account_rc_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline consume_account_rc_result& operator=(consume_account_rc_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const consume_account_rc_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const consume_account_rc_result* internal_default_instance() {
    return reinterpret_cast<const consume_account_rc_result*>(
               &_consume_account_rc_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(consume_account_rc_result& a, consume_account_rc_result& b) {
    a.Swap(&b);
  }
  inline void Swap(consume_account_rc_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(consume_account_rc_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline consume_account_rc_result* New() const final {
    return new consume_account_rc_result();
  }

  consume_account_rc_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<consume_account_rc_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const consume_account_rc_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const consume_account_rc_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(consume_account_rc_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.consume_account_rc_result";
  }
  protected:
  explicit consume_account_rc_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.consume_account_rc_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_resource_limits_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_resource_limits_arguments) */ {
 public:
  inline get_resource_limits_arguments() : get_resource_limits_arguments(nullptr) {}
  ~get_resource_limits_arguments() override;
  explicit constexpr get_resource_limits_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_resource_limits_arguments(const get_resource_limits_arguments& from);
  get_resource_limits_arguments(get_resource_limits_arguments&& from) noexcept
    : get_resource_limits_arguments() {
    *this = ::std::move(from);
  }

  inline get_resource_limits_arguments& operator=(const get_resource_limits_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_resource_limits_arguments& operator=(get_resource_limits_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_resource_limits_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_resource_limits_arguments* internal_default_instance() {
    return reinterpret_cast<const get_resource_limits_arguments*>(
               &_get_resource_limits_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(get_resource_limits_arguments& a, get_resource_limits_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_resource_limits_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_resource_limits_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_resource_limits_arguments* New() const final {
    return new get_resource_limits_arguments();
  }

  get_resource_limits_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_resource_limits_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_resource_limits_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_resource_limits_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_resource_limits_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_resource_limits_arguments";
  }
  protected:
  explicit get_resource_limits_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.get_resource_limits_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_resource_limits_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_resource_limits_result) */ {
 public:
  inline get_resource_limits_result() : get_resource_limits_result(nullptr) {}
  ~get_resource_limits_result() override;
  explicit constexpr get_resource_limits_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_resource_limits_result(const get_resource_limits_result& from);
  get_resource_limits_result(get_resource_limits_result&& from) noexcept
    : get_resource_limits_result() {
    *this = ::std::move(from);
  }

  inline get_resource_limits_result& operator=(const get_resource_limits_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_resource_limits_result& operator=(get_resource_limits_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_resource_limits_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_resource_limits_result* internal_default_instance() {
    return reinterpret_cast<const get_resource_limits_result*>(
               &_get_resource_limits_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(get_resource_limits_result& a, get_resource_limits_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_resource_limits_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_resource_limits_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_resource_limits_result* New() const final {
    return new get_resource_limits_result();
  }

  get_resource_limits_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_resource_limits_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_resource_limits_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_resource_limits_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_resource_limits_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_resource_limits_result";
  }
  protected:
  explicit get_resource_limits_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .koinos.chain.resource_limit_data value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::koinos::chain::resource_limit_data& value() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::resource_limit_data* release_value();
  ::koinos::chain::resource_limit_data* mutable_value();
  void set_allocated_value(::koinos::chain::resource_limit_data* value);
  private:
  const ::koinos::chain::resource_limit_data& _internal_value() const;
  ::koinos::chain::resource_limit_data* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::koinos::chain::resource_limit_data* value);
  ::koinos::chain::resource_limit_data* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:koinos.chain.get_resource_limits_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::chain::resource_limit_data* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class consume_block_resources_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.consume_block_resources_arguments) */ {
 public:
  inline consume_block_resources_arguments() : consume_block_resources_arguments(nullptr) {}
  ~consume_block_resources_arguments() override;
  explicit constexpr consume_block_resources_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  consume_block_resources_arguments(const consume_block_resources_arguments& from);
  consume_block_resources_arguments(consume_block_resources_arguments&& from) noexcept
    : consume_block_resources_arguments() {
    *this = ::std::move(from);
  }

  inline consume_block_resources_arguments& operator=(const consume_block_resources_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline consume_block_resources_arguments& operator=(consume_block_resources_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const consume_block_resources_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const consume_block_resources_arguments* internal_default_instance() {
    return reinterpret_cast<const consume_block_resources_arguments*>(
               &_consume_block_resources_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(consume_block_resources_arguments& a, consume_block_resources_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(consume_block_resources_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(consume_block_resources_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline consume_block_resources_arguments* New() const final {
    return new consume_block_resources_arguments();
  }

  consume_block_resources_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<consume_block_resources_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const consume_block_resources_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const consume_block_resources_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(consume_block_resources_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.consume_block_resources_arguments";
  }
  protected:
  explicit consume_block_resources_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiskStorageConsumedFieldNumber = 1,
    kNetworkBandwidthConsumedFieldNumber = 2,
    kComputeBandwidthConsumedFieldNumber = 3,
  };
  // uint64 disk_storage_consumed = 1 [jstype = JS_STRING];
  void clear_disk_storage_consumed();
  ::PROTOBUF_NAMESPACE_ID::uint64 disk_storage_consumed() const;
  void set_disk_storage_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_disk_storage_consumed() const;
  void _internal_set_disk_storage_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 network_bandwidth_consumed = 2 [jstype = JS_STRING];
  void clear_network_bandwidth_consumed();
  ::PROTOBUF_NAMESPACE_ID::uint64 network_bandwidth_consumed() const;
  void set_network_bandwidth_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_network_bandwidth_consumed() const;
  void _internal_set_network_bandwidth_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 compute_bandwidth_consumed = 3 [jstype = JS_STRING];
  void clear_compute_bandwidth_consumed();
  ::PROTOBUF_NAMESPACE_ID::uint64 compute_bandwidth_consumed() const;
  void set_compute_bandwidth_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_compute_bandwidth_consumed() const;
  void _internal_set_compute_bandwidth_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.consume_block_resources_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 disk_storage_consumed_;
  ::PROTOBUF_NAMESPACE_ID::uint64 network_bandwidth_consumed_;
  ::PROTOBUF_NAMESPACE_ID::uint64 compute_bandwidth_consumed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class consume_block_resources_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.consume_block_resources_result) */ {
 public:
  inline consume_block_resources_result() : consume_block_resources_result(nullptr) {}
  ~consume_block_resources_result() override;
  explicit constexpr consume_block_resources_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  consume_block_resources_result(const consume_block_resources_result& from);
  consume_block_resources_result(consume_block_resources_result&& from) noexcept
    : consume_block_resources_result() {
    *this = ::std::move(from);
  }

  inline consume_block_resources_result& operator=(const consume_block_resources_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline consume_block_resources_result& operator=(consume_block_resources_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const consume_block_resources_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const consume_block_resources_result* internal_default_instance() {
    return reinterpret_cast<const consume_block_resources_result*>(
               &_consume_block_resources_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(consume_block_resources_result& a, consume_block_resources_result& b) {
    a.Swap(&b);
  }
  inline void Swap(consume_block_resources_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(consume_block_resources_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline consume_block_resources_result* New() const final {
    return new consume_block_resources_result();
  }

  consume_block_resources_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<consume_block_resources_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const consume_block_resources_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const consume_block_resources_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(consume_block_resources_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.consume_block_resources_result";
  }
  protected:
  explicit consume_block_resources_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.consume_block_resources_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_transaction_rc_limit_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_transaction_rc_limit_arguments) */ {
 public:
  inline get_transaction_rc_limit_arguments() : get_transaction_rc_limit_arguments(nullptr) {}
  ~get_transaction_rc_limit_arguments() override;
  explicit constexpr get_transaction_rc_limit_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_transaction_rc_limit_arguments(const get_transaction_rc_limit_arguments& from);
  get_transaction_rc_limit_arguments(get_transaction_rc_limit_arguments&& from) noexcept
    : get_transaction_rc_limit_arguments() {
    *this = ::std::move(from);
  }

  inline get_transaction_rc_limit_arguments& operator=(const get_transaction_rc_limit_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_transaction_rc_limit_arguments& operator=(get_transaction_rc_limit_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_transaction_rc_limit_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_transaction_rc_limit_arguments* internal_default_instance() {
    return reinterpret_cast<const get_transaction_rc_limit_arguments*>(
               &_get_transaction_rc_limit_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(get_transaction_rc_limit_arguments& a, get_transaction_rc_limit_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_transaction_rc_limit_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_transaction_rc_limit_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_transaction_rc_limit_arguments* New() const final {
    return new get_transaction_rc_limit_arguments();
  }

  get_transaction_rc_limit_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_transaction_rc_limit_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_transaction_rc_limit_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_transaction_rc_limit_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_transaction_rc_limit_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_transaction_rc_limit_arguments";
  }
  protected:
  explicit get_transaction_rc_limit_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionFieldNumber = 1,
  };
  // .koinos.protocol.transaction transaction = 1;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::koinos::protocol::transaction& transaction() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::protocol::transaction* release_transaction();
  ::koinos::protocol::transaction* mutable_transaction();
  void set_allocated_transaction(::koinos::protocol::transaction* transaction);
  private:
  const ::koinos::protocol::transaction& _internal_transaction() const;
  ::koinos::protocol::transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::koinos::protocol::transaction* transaction);
  ::koinos::protocol::transaction* unsafe_arena_release_transaction();

  // @@protoc_insertion_point(class_scope:koinos.chain.get_transaction_rc_limit_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::protocol::transaction* transaction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_transaction_rc_limit_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_transaction_rc_limit_result) */ {
 public:
  inline get_transaction_rc_limit_result() : get_transaction_rc_limit_result(nullptr) {}
  ~get_transaction_rc_limit_result() override;
  explicit constexpr get_transaction_rc_limit_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_transaction_rc_limit_result(const get_transaction_rc_limit_result& from);
  get_transaction_rc_limit_result(get_transaction_rc_limit_result&& from) noexcept
    : get_transaction_rc_limit_result() {
    *this = ::std::move(from);
  }

  inline get_transaction_rc_limit_result& operator=(const get_transaction_rc_limit_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_transaction_rc_limit_result& operator=(get_transaction_rc_limit_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_transaction_rc_limit_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_transaction_rc_limit_result* internal_default_instance() {
    return reinterpret_cast<const get_transaction_rc_limit_result*>(
               &_get_transaction_rc_limit_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(get_transaction_rc_limit_result& a, get_transaction_rc_limit_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_transaction_rc_limit_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_transaction_rc_limit_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_transaction_rc_limit_result* New() const final {
    return new get_transaction_rc_limit_result();
  }

  get_transaction_rc_limit_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_transaction_rc_limit_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_transaction_rc_limit_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_transaction_rc_limit_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_transaction_rc_limit_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_transaction_rc_limit_result";
  }
  protected:
  explicit get_transaction_rc_limit_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint64 value = 1 [jstype = JS_STRING];
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_transaction_rc_limit_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_last_irreversible_block_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_last_irreversible_block_arguments) */ {
 public:
  inline get_last_irreversible_block_arguments() : get_last_irreversible_block_arguments(nullptr) {}
  ~get_last_irreversible_block_arguments() override;
  explicit constexpr get_last_irreversible_block_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_last_irreversible_block_arguments(const get_last_irreversible_block_arguments& from);
  get_last_irreversible_block_arguments(get_last_irreversible_block_arguments&& from) noexcept
    : get_last_irreversible_block_arguments() {
    *this = ::std::move(from);
  }

  inline get_last_irreversible_block_arguments& operator=(const get_last_irreversible_block_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_last_irreversible_block_arguments& operator=(get_last_irreversible_block_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_last_irreversible_block_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_last_irreversible_block_arguments* internal_default_instance() {
    return reinterpret_cast<const get_last_irreversible_block_arguments*>(
               &_get_last_irreversible_block_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(get_last_irreversible_block_arguments& a, get_last_irreversible_block_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_last_irreversible_block_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_last_irreversible_block_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_last_irreversible_block_arguments* New() const final {
    return new get_last_irreversible_block_arguments();
  }

  get_last_irreversible_block_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_last_irreversible_block_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_last_irreversible_block_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_last_irreversible_block_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_last_irreversible_block_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_last_irreversible_block_arguments";
  }
  protected:
  explicit get_last_irreversible_block_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.get_last_irreversible_block_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_last_irreversible_block_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_last_irreversible_block_result) */ {
 public:
  inline get_last_irreversible_block_result() : get_last_irreversible_block_result(nullptr) {}
  ~get_last_irreversible_block_result() override;
  explicit constexpr get_last_irreversible_block_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_last_irreversible_block_result(const get_last_irreversible_block_result& from);
  get_last_irreversible_block_result(get_last_irreversible_block_result&& from) noexcept
    : get_last_irreversible_block_result() {
    *this = ::std::move(from);
  }

  inline get_last_irreversible_block_result& operator=(const get_last_irreversible_block_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_last_irreversible_block_result& operator=(get_last_irreversible_block_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_last_irreversible_block_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_last_irreversible_block_result* internal_default_instance() {
    return reinterpret_cast<const get_last_irreversible_block_result*>(
               &_get_last_irreversible_block_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(get_last_irreversible_block_result& a, get_last_irreversible_block_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_last_irreversible_block_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_last_irreversible_block_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_last_irreversible_block_result* New() const final {
    return new get_last_irreversible_block_result();
  }

  get_last_irreversible_block_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_last_irreversible_block_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_last_irreversible_block_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_last_irreversible_block_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_last_irreversible_block_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_last_irreversible_block_result";
  }
  protected:
  explicit get_last_irreversible_block_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint64 value = 1 [jstype = JS_STRING];
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_last_irreversible_block_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_caller_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_caller_arguments) */ {
 public:
  inline get_caller_arguments() : get_caller_arguments(nullptr) {}
  ~get_caller_arguments() override;
  explicit constexpr get_caller_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_caller_arguments(const get_caller_arguments& from);
  get_caller_arguments(get_caller_arguments&& from) noexcept
    : get_caller_arguments() {
    *this = ::std::move(from);
  }

  inline get_caller_arguments& operator=(const get_caller_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_caller_arguments& operator=(get_caller_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_caller_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_caller_arguments* internal_default_instance() {
    return reinterpret_cast<const get_caller_arguments*>(
               &_get_caller_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(get_caller_arguments& a, get_caller_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_caller_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_caller_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_caller_arguments* New() const final {
    return new get_caller_arguments();
  }

  get_caller_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_caller_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_caller_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_caller_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_caller_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_caller_arguments";
  }
  protected:
  explicit get_caller_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.get_caller_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_caller_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_caller_result) */ {
 public:
  inline get_caller_result() : get_caller_result(nullptr) {}
  ~get_caller_result() override;
  explicit constexpr get_caller_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_caller_result(const get_caller_result& from);
  get_caller_result(get_caller_result&& from) noexcept
    : get_caller_result() {
    *this = ::std::move(from);
  }

  inline get_caller_result& operator=(const get_caller_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_caller_result& operator=(get_caller_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_caller_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_caller_result* internal_default_instance() {
    return reinterpret_cast<const get_caller_result*>(
               &_get_caller_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(get_caller_result& a, get_caller_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_caller_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_caller_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_caller_result* New() const final {
    return new get_caller_result();
  }

  get_caller_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_caller_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_caller_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_caller_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_caller_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_caller_result";
  }
  protected:
  explicit get_caller_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .koinos.chain.caller_data value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::koinos::chain::caller_data& value() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::caller_data* release_value();
  ::koinos::chain::caller_data* mutable_value();
  void set_allocated_value(::koinos::chain::caller_data* value);
  private:
  const ::koinos::chain::caller_data& _internal_value() const;
  ::koinos::chain::caller_data* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::koinos::chain::caller_data* value);
  ::koinos::chain::caller_data* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:koinos.chain.get_caller_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::chain::caller_data* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class require_authority_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.require_authority_arguments) */ {
 public:
  inline require_authority_arguments() : require_authority_arguments(nullptr) {}
  ~require_authority_arguments() override;
  explicit constexpr require_authority_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  require_authority_arguments(const require_authority_arguments& from);
  require_authority_arguments(require_authority_arguments&& from) noexcept
    : require_authority_arguments() {
    *this = ::std::move(from);
  }

  inline require_authority_arguments& operator=(const require_authority_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline require_authority_arguments& operator=(require_authority_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const require_authority_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const require_authority_arguments* internal_default_instance() {
    return reinterpret_cast<const require_authority_arguments*>(
               &_require_authority_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(require_authority_arguments& a, require_authority_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(require_authority_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(require_authority_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline require_authority_arguments* New() const final {
    return new require_authority_arguments();
  }

  require_authority_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<require_authority_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const require_authority_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const require_authority_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(require_authority_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.require_authority_arguments";
  }
  protected:
  explicit require_authority_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
  };
  // bytes account = 1;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_MUST_USE_RESULT std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.require_authority_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class require_authority_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.require_authority_result) */ {
 public:
  inline require_authority_result() : require_authority_result(nullptr) {}
  ~require_authority_result() override;
  explicit constexpr require_authority_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  require_authority_result(const require_authority_result& from);
  require_authority_result(require_authority_result&& from) noexcept
    : require_authority_result() {
    *this = ::std::move(from);
  }

  inline require_authority_result& operator=(const require_authority_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline require_authority_result& operator=(require_authority_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const require_authority_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const require_authority_result* internal_default_instance() {
    return reinterpret_cast<const require_authority_result*>(
               &_require_authority_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(require_authority_result& a, require_authority_result& b) {
    a.Swap(&b);
  }
  inline void Swap(require_authority_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(require_authority_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline require_authority_result* New() const final {
    return new require_authority_result();
  }

  require_authority_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<require_authority_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const require_authority_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const require_authority_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(require_authority_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.require_authority_result";
  }
  protected:
  explicit require_authority_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.require_authority_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_transaction_signature_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_transaction_signature_arguments) */ {
 public:
  inline get_transaction_signature_arguments() : get_transaction_signature_arguments(nullptr) {}
  ~get_transaction_signature_arguments() override;
  explicit constexpr get_transaction_signature_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_transaction_signature_arguments(const get_transaction_signature_arguments& from);
  get_transaction_signature_arguments(get_transaction_signature_arguments&& from) noexcept
    : get_transaction_signature_arguments() {
    *this = ::std::move(from);
  }

  inline get_transaction_signature_arguments& operator=(const get_transaction_signature_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_transaction_signature_arguments& operator=(get_transaction_signature_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_transaction_signature_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_transaction_signature_arguments* internal_default_instance() {
    return reinterpret_cast<const get_transaction_signature_arguments*>(
               &_get_transaction_signature_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(get_transaction_signature_arguments& a, get_transaction_signature_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_transaction_signature_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_transaction_signature_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_transaction_signature_arguments* New() const final {
    return new get_transaction_signature_arguments();
  }

  get_transaction_signature_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_transaction_signature_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_transaction_signature_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_transaction_signature_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_transaction_signature_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_transaction_signature_arguments";
  }
  protected:
  explicit get_transaction_signature_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.get_transaction_signature_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_transaction_signature_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_transaction_signature_result) */ {
 public:
  inline get_transaction_signature_result() : get_transaction_signature_result(nullptr) {}
  ~get_transaction_signature_result() override;
  explicit constexpr get_transaction_signature_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_transaction_signature_result(const get_transaction_signature_result& from);
  get_transaction_signature_result(get_transaction_signature_result&& from) noexcept
    : get_transaction_signature_result() {
    *this = ::std::move(from);
  }

  inline get_transaction_signature_result& operator=(const get_transaction_signature_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_transaction_signature_result& operator=(get_transaction_signature_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_transaction_signature_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_transaction_signature_result* internal_default_instance() {
    return reinterpret_cast<const get_transaction_signature_result*>(
               &_get_transaction_signature_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(get_transaction_signature_result& a, get_transaction_signature_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_transaction_signature_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_transaction_signature_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_transaction_signature_result* New() const final {
    return new get_transaction_signature_result();
  }

  get_transaction_signature_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_transaction_signature_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_transaction_signature_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_transaction_signature_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_transaction_signature_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_transaction_signature_result";
  }
  protected:
  explicit get_transaction_signature_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_transaction_signature_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_contract_id_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_contract_id_arguments) */ {
 public:
  inline get_contract_id_arguments() : get_contract_id_arguments(nullptr) {}
  ~get_contract_id_arguments() override;
  explicit constexpr get_contract_id_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_contract_id_arguments(const get_contract_id_arguments& from);
  get_contract_id_arguments(get_contract_id_arguments&& from) noexcept
    : get_contract_id_arguments() {
    *this = ::std::move(from);
  }

  inline get_contract_id_arguments& operator=(const get_contract_id_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_contract_id_arguments& operator=(get_contract_id_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_contract_id_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_contract_id_arguments* internal_default_instance() {
    return reinterpret_cast<const get_contract_id_arguments*>(
               &_get_contract_id_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(get_contract_id_arguments& a, get_contract_id_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_contract_id_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_contract_id_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_contract_id_arguments* New() const final {
    return new get_contract_id_arguments();
  }

  get_contract_id_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_contract_id_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_contract_id_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_contract_id_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_contract_id_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_contract_id_arguments";
  }
  protected:
  explicit get_contract_id_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:koinos.chain.get_contract_id_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_contract_id_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_contract_id_result) */ {
 public:
  inline get_contract_id_result() : get_contract_id_result(nullptr) {}
  ~get_contract_id_result() override;
  explicit constexpr get_contract_id_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_contract_id_result(const get_contract_id_result& from);
  get_contract_id_result(get_contract_id_result&& from) noexcept
    : get_contract_id_result() {
    *this = ::std::move(from);
  }

  inline get_contract_id_result& operator=(const get_contract_id_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_contract_id_result& operator=(get_contract_id_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_contract_id_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_contract_id_result* internal_default_instance() {
    return reinterpret_cast<const get_contract_id_result*>(
               &_get_contract_id_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(get_contract_id_result& a, get_contract_id_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_contract_id_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_contract_id_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_contract_id_result* New() const final {
    return new get_contract_id_result();
  }

  get_contract_id_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_contract_id_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_contract_id_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_contract_id_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_contract_id_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_contract_id_result";
  }
  protected:
  explicit get_contract_id_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_contract_id_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_account_nonce_arguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_account_nonce_arguments) */ {
 public:
  inline get_account_nonce_arguments() : get_account_nonce_arguments(nullptr) {}
  ~get_account_nonce_arguments() override;
  explicit constexpr get_account_nonce_arguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_account_nonce_arguments(const get_account_nonce_arguments& from);
  get_account_nonce_arguments(get_account_nonce_arguments&& from) noexcept
    : get_account_nonce_arguments() {
    *this = ::std::move(from);
  }

  inline get_account_nonce_arguments& operator=(const get_account_nonce_arguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_account_nonce_arguments& operator=(get_account_nonce_arguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_account_nonce_arguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_account_nonce_arguments* internal_default_instance() {
    return reinterpret_cast<const get_account_nonce_arguments*>(
               &_get_account_nonce_arguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(get_account_nonce_arguments& a, get_account_nonce_arguments& b) {
    a.Swap(&b);
  }
  inline void Swap(get_account_nonce_arguments* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_account_nonce_arguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_account_nonce_arguments* New() const final {
    return new get_account_nonce_arguments();
  }

  get_account_nonce_arguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_account_nonce_arguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_account_nonce_arguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_account_nonce_arguments& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_account_nonce_arguments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_account_nonce_arguments";
  }
  protected:
  explicit get_account_nonce_arguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
  };
  // bytes account = 1;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_MUST_USE_RESULT std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_account_nonce_arguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class get_account_nonce_result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.get_account_nonce_result) */ {
 public:
  inline get_account_nonce_result() : get_account_nonce_result(nullptr) {}
  ~get_account_nonce_result() override;
  explicit constexpr get_account_nonce_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  get_account_nonce_result(const get_account_nonce_result& from);
  get_account_nonce_result(get_account_nonce_result&& from) noexcept
    : get_account_nonce_result() {
    *this = ::std::move(from);
  }

  inline get_account_nonce_result& operator=(const get_account_nonce_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_account_nonce_result& operator=(get_account_nonce_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const get_account_nonce_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const get_account_nonce_result* internal_default_instance() {
    return reinterpret_cast<const get_account_nonce_result*>(
               &_get_account_nonce_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(get_account_nonce_result& a, get_account_nonce_result& b) {
    a.Swap(&b);
  }
  inline void Swap(get_account_nonce_result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(get_account_nonce_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_account_nonce_result* New() const final {
    return new get_account_nonce_result();
  }

  get_account_nonce_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_account_nonce_result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const get_account_nonce_result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const get_account_nonce_result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_account_nonce_result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.get_account_nonce_result";
  }
  protected:
  explicit get_account_nonce_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint64 value = 1 [jstype = JS_STRING];
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.get_account_nonce_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// object_space

// bool system = 1;
inline void object_space::clear_system() {
  system_ = false;
}
inline bool object_space::_internal_system() const {
  return system_;
}
inline bool object_space::system() const {
  // @@protoc_insertion_point(field_get:koinos.chain.object_space.system)
  return _internal_system();
}
inline void object_space::_internal_set_system(bool value) {
  
  system_ = value;
}
inline void object_space::set_system(bool value) {
  _internal_set_system(value);
  // @@protoc_insertion_point(field_set:koinos.chain.object_space.system)
}

// bytes zone = 2;
inline void object_space::clear_zone() {
  zone_.ClearToEmpty();
}
inline const std::string& object_space::zone() const {
  // @@protoc_insertion_point(field_get:koinos.chain.object_space.zone)
  return _internal_zone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void object_space::set_zone(ArgT0&& arg0, ArgT... args) {
 
 zone_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.object_space.zone)
}
inline std::string* object_space::mutable_zone() {
  std::string* _s = _internal_mutable_zone();
  // @@protoc_insertion_point(field_mutable:koinos.chain.object_space.zone)
  return _s;
}
inline const std::string& object_space::_internal_zone() const {
  return zone_.Get();
}
inline void object_space::_internal_set_zone(const std::string& value) {
  
  zone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* object_space::_internal_mutable_zone() {
  
  return zone_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* object_space::release_zone() {
  // @@protoc_insertion_point(field_release:koinos.chain.object_space.zone)
  return zone_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void object_space::set_allocated_zone(std::string* zone) {
  if (zone != nullptr) {
    
  } else {
    
  }
  zone_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), zone,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.object_space.zone)
}

// uint32 id = 3;
inline void object_space::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 object_space::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 object_space::id() const {
  // @@protoc_insertion_point(field_get:koinos.chain.object_space.id)
  return _internal_id();
}
inline void object_space::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void object_space::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:koinos.chain.object_space.id)
}

// -------------------------------------------------------------------

// head_info

// .koinos.block_topology head_topology = 1;
inline bool head_info::_internal_has_head_topology() const {
  return this != internal_default_instance() && head_topology_ != nullptr;
}
inline bool head_info::has_head_topology() const {
  return _internal_has_head_topology();
}
inline const ::koinos::block_topology& head_info::_internal_head_topology() const {
  const ::koinos::block_topology* p = head_topology_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::block_topology&>(
      ::koinos::_block_topology_default_instance_);
}
inline const ::koinos::block_topology& head_info::head_topology() const {
  // @@protoc_insertion_point(field_get:koinos.chain.head_info.head_topology)
  return _internal_head_topology();
}
inline void head_info::unsafe_arena_set_allocated_head_topology(
    ::koinos::block_topology* head_topology) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_topology_);
  }
  head_topology_ = head_topology;
  if (head_topology) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.head_info.head_topology)
}
inline ::koinos::block_topology* head_info::release_head_topology() {
  
  ::koinos::block_topology* temp = head_topology_;
  head_topology_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::block_topology* head_info::unsafe_arena_release_head_topology() {
  // @@protoc_insertion_point(field_release:koinos.chain.head_info.head_topology)
  
  ::koinos::block_topology* temp = head_topology_;
  head_topology_ = nullptr;
  return temp;
}
inline ::koinos::block_topology* head_info::_internal_mutable_head_topology() {
  
  if (head_topology_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::block_topology>(GetArenaForAllocation());
    head_topology_ = p;
  }
  return head_topology_;
}
inline ::koinos::block_topology* head_info::mutable_head_topology() {
  ::koinos::block_topology* _msg = _internal_mutable_head_topology();
  // @@protoc_insertion_point(field_mutable:koinos.chain.head_info.head_topology)
  return _msg;
}
inline void head_info::set_allocated_head_topology(::koinos::block_topology* head_topology) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_topology_);
  }
  if (head_topology) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_topology));
    if (message_arena != submessage_arena) {
      head_topology = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head_topology, submessage_arena);
    }
    
  } else {
    
  }
  head_topology_ = head_topology;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.head_info.head_topology)
}

// uint64 head_block_time = 2 [jstype = JS_STRING];
inline void head_info::clear_head_block_time() {
  head_block_time_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 head_info::_internal_head_block_time() const {
  return head_block_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 head_info::head_block_time() const {
  // @@protoc_insertion_point(field_get:koinos.chain.head_info.head_block_time)
  return _internal_head_block_time();
}
inline void head_info::_internal_set_head_block_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  head_block_time_ = value;
}
inline void head_info::set_head_block_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_head_block_time(value);
  // @@protoc_insertion_point(field_set:koinos.chain.head_info.head_block_time)
}

// uint64 last_irreversible_block = 3 [jstype = JS_STRING];
inline void head_info::clear_last_irreversible_block() {
  last_irreversible_block_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 head_info::_internal_last_irreversible_block() const {
  return last_irreversible_block_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 head_info::last_irreversible_block() const {
  // @@protoc_insertion_point(field_get:koinos.chain.head_info.last_irreversible_block)
  return _internal_last_irreversible_block();
}
inline void head_info::_internal_set_last_irreversible_block(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  last_irreversible_block_ = value;
}
inline void head_info::set_last_irreversible_block(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_last_irreversible_block(value);
  // @@protoc_insertion_point(field_set:koinos.chain.head_info.last_irreversible_block)
}

// -------------------------------------------------------------------

// caller_data

// bytes caller = 1;
inline void caller_data::clear_caller() {
  caller_.ClearToEmpty();
}
inline const std::string& caller_data::caller() const {
  // @@protoc_insertion_point(field_get:koinos.chain.caller_data.caller)
  return _internal_caller();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void caller_data::set_caller(ArgT0&& arg0, ArgT... args) {
 
 caller_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.caller_data.caller)
}
inline std::string* caller_data::mutable_caller() {
  std::string* _s = _internal_mutable_caller();
  // @@protoc_insertion_point(field_mutable:koinos.chain.caller_data.caller)
  return _s;
}
inline const std::string& caller_data::_internal_caller() const {
  return caller_.Get();
}
inline void caller_data::_internal_set_caller(const std::string& value) {
  
  caller_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* caller_data::_internal_mutable_caller() {
  
  return caller_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* caller_data::release_caller() {
  // @@protoc_insertion_point(field_release:koinos.chain.caller_data.caller)
  return caller_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void caller_data::set_allocated_caller(std::string* caller) {
  if (caller != nullptr) {
    
  } else {
    
  }
  caller_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), caller,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.caller_data.caller)
}

// .koinos.chain.privilege caller_privilege = 2;
inline void caller_data::clear_caller_privilege() {
  caller_privilege_ = 0;
}
inline ::koinos::chain::privilege caller_data::_internal_caller_privilege() const {
  return static_cast< ::koinos::chain::privilege >(caller_privilege_);
}
inline ::koinos::chain::privilege caller_data::caller_privilege() const {
  // @@protoc_insertion_point(field_get:koinos.chain.caller_data.caller_privilege)
  return _internal_caller_privilege();
}
inline void caller_data::_internal_set_caller_privilege(::koinos::chain::privilege value) {
  
  caller_privilege_ = value;
}
inline void caller_data::set_caller_privilege(::koinos::chain::privilege value) {
  _internal_set_caller_privilege(value);
  // @@protoc_insertion_point(field_set:koinos.chain.caller_data.caller_privilege)
}

// -------------------------------------------------------------------

// resource_limit_data

// uint64 disk_storage_limit = 1 [jstype = JS_STRING];
inline void resource_limit_data::clear_disk_storage_limit() {
  disk_storage_limit_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::_internal_disk_storage_limit() const {
  return disk_storage_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::disk_storage_limit() const {
  // @@protoc_insertion_point(field_get:koinos.chain.resource_limit_data.disk_storage_limit)
  return _internal_disk_storage_limit();
}
inline void resource_limit_data::_internal_set_disk_storage_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  disk_storage_limit_ = value;
}
inline void resource_limit_data::set_disk_storage_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_disk_storage_limit(value);
  // @@protoc_insertion_point(field_set:koinos.chain.resource_limit_data.disk_storage_limit)
}

// uint64 disk_storage_cost = 2 [jstype = JS_STRING];
inline void resource_limit_data::clear_disk_storage_cost() {
  disk_storage_cost_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::_internal_disk_storage_cost() const {
  return disk_storage_cost_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::disk_storage_cost() const {
  // @@protoc_insertion_point(field_get:koinos.chain.resource_limit_data.disk_storage_cost)
  return _internal_disk_storage_cost();
}
inline void resource_limit_data::_internal_set_disk_storage_cost(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  disk_storage_cost_ = value;
}
inline void resource_limit_data::set_disk_storage_cost(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_disk_storage_cost(value);
  // @@protoc_insertion_point(field_set:koinos.chain.resource_limit_data.disk_storage_cost)
}

// uint64 network_bandwidth_limit = 3 [jstype = JS_STRING];
inline void resource_limit_data::clear_network_bandwidth_limit() {
  network_bandwidth_limit_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::_internal_network_bandwidth_limit() const {
  return network_bandwidth_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::network_bandwidth_limit() const {
  // @@protoc_insertion_point(field_get:koinos.chain.resource_limit_data.network_bandwidth_limit)
  return _internal_network_bandwidth_limit();
}
inline void resource_limit_data::_internal_set_network_bandwidth_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  network_bandwidth_limit_ = value;
}
inline void resource_limit_data::set_network_bandwidth_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_network_bandwidth_limit(value);
  // @@protoc_insertion_point(field_set:koinos.chain.resource_limit_data.network_bandwidth_limit)
}

// uint64 network_bandwidth_cost = 4 [jstype = JS_STRING];
inline void resource_limit_data::clear_network_bandwidth_cost() {
  network_bandwidth_cost_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::_internal_network_bandwidth_cost() const {
  return network_bandwidth_cost_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::network_bandwidth_cost() const {
  // @@protoc_insertion_point(field_get:koinos.chain.resource_limit_data.network_bandwidth_cost)
  return _internal_network_bandwidth_cost();
}
inline void resource_limit_data::_internal_set_network_bandwidth_cost(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  network_bandwidth_cost_ = value;
}
inline void resource_limit_data::set_network_bandwidth_cost(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_network_bandwidth_cost(value);
  // @@protoc_insertion_point(field_set:koinos.chain.resource_limit_data.network_bandwidth_cost)
}

// uint64 compute_bandwidth_limit = 5 [jstype = JS_STRING];
inline void resource_limit_data::clear_compute_bandwidth_limit() {
  compute_bandwidth_limit_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::_internal_compute_bandwidth_limit() const {
  return compute_bandwidth_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::compute_bandwidth_limit() const {
  // @@protoc_insertion_point(field_get:koinos.chain.resource_limit_data.compute_bandwidth_limit)
  return _internal_compute_bandwidth_limit();
}
inline void resource_limit_data::_internal_set_compute_bandwidth_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  compute_bandwidth_limit_ = value;
}
inline void resource_limit_data::set_compute_bandwidth_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_compute_bandwidth_limit(value);
  // @@protoc_insertion_point(field_set:koinos.chain.resource_limit_data.compute_bandwidth_limit)
}

// uint64 compute_bandwidth_cost = 6 [jstype = JS_STRING];
inline void resource_limit_data::clear_compute_bandwidth_cost() {
  compute_bandwidth_cost_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::_internal_compute_bandwidth_cost() const {
  return compute_bandwidth_cost_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::compute_bandwidth_cost() const {
  // @@protoc_insertion_point(field_get:koinos.chain.resource_limit_data.compute_bandwidth_cost)
  return _internal_compute_bandwidth_cost();
}
inline void resource_limit_data::_internal_set_compute_bandwidth_cost(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  compute_bandwidth_cost_ = value;
}
inline void resource_limit_data::set_compute_bandwidth_cost(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_compute_bandwidth_cost(value);
  // @@protoc_insertion_point(field_set:koinos.chain.resource_limit_data.compute_bandwidth_cost)
}

// -------------------------------------------------------------------

// prints_arguments

// string message = 1;
inline void prints_arguments::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& prints_arguments::message() const {
  // @@protoc_insertion_point(field_get:koinos.chain.prints_arguments.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void prints_arguments::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.prints_arguments.message)
}
inline std::string* prints_arguments::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:koinos.chain.prints_arguments.message)
  return _s;
}
inline const std::string& prints_arguments::_internal_message() const {
  return message_.Get();
}
inline void prints_arguments::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* prints_arguments::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* prints_arguments::release_message() {
  // @@protoc_insertion_point(field_release:koinos.chain.prints_arguments.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void prints_arguments::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.prints_arguments.message)
}

// -------------------------------------------------------------------

// prints_result

// -------------------------------------------------------------------

// verify_block_signature_arguments

// bytes digest = 1;
inline void verify_block_signature_arguments::clear_digest() {
  digest_.ClearToEmpty();
}
inline const std::string& verify_block_signature_arguments::digest() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_block_signature_arguments.digest)
  return _internal_digest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void verify_block_signature_arguments::set_digest(ArgT0&& arg0, ArgT... args) {
 
 digest_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.verify_block_signature_arguments.digest)
}
inline std::string* verify_block_signature_arguments::mutable_digest() {
  std::string* _s = _internal_mutable_digest();
  // @@protoc_insertion_point(field_mutable:koinos.chain.verify_block_signature_arguments.digest)
  return _s;
}
inline const std::string& verify_block_signature_arguments::_internal_digest() const {
  return digest_.Get();
}
inline void verify_block_signature_arguments::_internal_set_digest(const std::string& value) {
  
  digest_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* verify_block_signature_arguments::_internal_mutable_digest() {
  
  return digest_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* verify_block_signature_arguments::release_digest() {
  // @@protoc_insertion_point(field_release:koinos.chain.verify_block_signature_arguments.digest)
  return digest_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void verify_block_signature_arguments::set_allocated_digest(std::string* digest) {
  if (digest != nullptr) {
    
  } else {
    
  }
  digest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), digest,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.verify_block_signature_arguments.digest)
}

// bytes active = 2;
inline void verify_block_signature_arguments::clear_active() {
  active_.ClearToEmpty();
}
inline const std::string& verify_block_signature_arguments::active() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_block_signature_arguments.active)
  return _internal_active();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void verify_block_signature_arguments::set_active(ArgT0&& arg0, ArgT... args) {
 
 active_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.verify_block_signature_arguments.active)
}
inline std::string* verify_block_signature_arguments::mutable_active() {
  std::string* _s = _internal_mutable_active();
  // @@protoc_insertion_point(field_mutable:koinos.chain.verify_block_signature_arguments.active)
  return _s;
}
inline const std::string& verify_block_signature_arguments::_internal_active() const {
  return active_.Get();
}
inline void verify_block_signature_arguments::_internal_set_active(const std::string& value) {
  
  active_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* verify_block_signature_arguments::_internal_mutable_active() {
  
  return active_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* verify_block_signature_arguments::release_active() {
  // @@protoc_insertion_point(field_release:koinos.chain.verify_block_signature_arguments.active)
  return active_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void verify_block_signature_arguments::set_allocated_active(std::string* active) {
  if (active != nullptr) {
    
  } else {
    
  }
  active_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), active,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.verify_block_signature_arguments.active)
}

// bytes signature_data = 3;
inline void verify_block_signature_arguments::clear_signature_data() {
  signature_data_.ClearToEmpty();
}
inline const std::string& verify_block_signature_arguments::signature_data() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_block_signature_arguments.signature_data)
  return _internal_signature_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void verify_block_signature_arguments::set_signature_data(ArgT0&& arg0, ArgT... args) {
 
 signature_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.verify_block_signature_arguments.signature_data)
}
inline std::string* verify_block_signature_arguments::mutable_signature_data() {
  std::string* _s = _internal_mutable_signature_data();
  // @@protoc_insertion_point(field_mutable:koinos.chain.verify_block_signature_arguments.signature_data)
  return _s;
}
inline const std::string& verify_block_signature_arguments::_internal_signature_data() const {
  return signature_data_.Get();
}
inline void verify_block_signature_arguments::_internal_set_signature_data(const std::string& value) {
  
  signature_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* verify_block_signature_arguments::_internal_mutable_signature_data() {
  
  return signature_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* verify_block_signature_arguments::release_signature_data() {
  // @@protoc_insertion_point(field_release:koinos.chain.verify_block_signature_arguments.signature_data)
  return signature_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void verify_block_signature_arguments::set_allocated_signature_data(std::string* signature_data) {
  if (signature_data != nullptr) {
    
  } else {
    
  }
  signature_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.verify_block_signature_arguments.signature_data)
}

// -------------------------------------------------------------------

// verify_block_signature_result

// bool value = 1;
inline void verify_block_signature_result::clear_value() {
  value_ = false;
}
inline bool verify_block_signature_result::_internal_value() const {
  return value_;
}
inline bool verify_block_signature_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_block_signature_result.value)
  return _internal_value();
}
inline void verify_block_signature_result::_internal_set_value(bool value) {
  
  value_ = value;
}
inline void verify_block_signature_result::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.verify_block_signature_result.value)
}

// -------------------------------------------------------------------

// verify_merkle_root_arguments

// bytes root = 1;
inline void verify_merkle_root_arguments::clear_root() {
  root_.ClearToEmpty();
}
inline const std::string& verify_merkle_root_arguments::root() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_merkle_root_arguments.root)
  return _internal_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void verify_merkle_root_arguments::set_root(ArgT0&& arg0, ArgT... args) {
 
 root_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.verify_merkle_root_arguments.root)
}
inline std::string* verify_merkle_root_arguments::mutable_root() {
  std::string* _s = _internal_mutable_root();
  // @@protoc_insertion_point(field_mutable:koinos.chain.verify_merkle_root_arguments.root)
  return _s;
}
inline const std::string& verify_merkle_root_arguments::_internal_root() const {
  return root_.Get();
}
inline void verify_merkle_root_arguments::_internal_set_root(const std::string& value) {
  
  root_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* verify_merkle_root_arguments::_internal_mutable_root() {
  
  return root_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* verify_merkle_root_arguments::release_root() {
  // @@protoc_insertion_point(field_release:koinos.chain.verify_merkle_root_arguments.root)
  return root_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void verify_merkle_root_arguments::set_allocated_root(std::string* root) {
  if (root != nullptr) {
    
  } else {
    
  }
  root_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), root,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.verify_merkle_root_arguments.root)
}

// repeated bytes hashes = 2;
inline int verify_merkle_root_arguments::_internal_hashes_size() const {
  return hashes_.size();
}
inline int verify_merkle_root_arguments::hashes_size() const {
  return _internal_hashes_size();
}
inline void verify_merkle_root_arguments::clear_hashes() {
  hashes_.Clear();
}
inline std::string* verify_merkle_root_arguments::add_hashes() {
  std::string* _s = _internal_add_hashes();
  // @@protoc_insertion_point(field_add_mutable:koinos.chain.verify_merkle_root_arguments.hashes)
  return _s;
}
inline const std::string& verify_merkle_root_arguments::_internal_hashes(int index) const {
  return hashes_.Get(index);
}
inline const std::string& verify_merkle_root_arguments::hashes(int index) const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_merkle_root_arguments.hashes)
  return _internal_hashes(index);
}
inline std::string* verify_merkle_root_arguments::mutable_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:koinos.chain.verify_merkle_root_arguments.hashes)
  return hashes_.Mutable(index);
}
inline void verify_merkle_root_arguments::set_hashes(int index, const std::string& value) {
  hashes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:koinos.chain.verify_merkle_root_arguments.hashes)
}
inline void verify_merkle_root_arguments::set_hashes(int index, std::string&& value) {
  hashes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:koinos.chain.verify_merkle_root_arguments.hashes)
}
inline void verify_merkle_root_arguments::set_hashes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hashes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:koinos.chain.verify_merkle_root_arguments.hashes)
}
inline void verify_merkle_root_arguments::set_hashes(int index, const void* value, size_t size) {
  hashes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:koinos.chain.verify_merkle_root_arguments.hashes)
}
inline std::string* verify_merkle_root_arguments::_internal_add_hashes() {
  return hashes_.Add();
}
inline void verify_merkle_root_arguments::add_hashes(const std::string& value) {
  hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:koinos.chain.verify_merkle_root_arguments.hashes)
}
inline void verify_merkle_root_arguments::add_hashes(std::string&& value) {
  hashes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:koinos.chain.verify_merkle_root_arguments.hashes)
}
inline void verify_merkle_root_arguments::add_hashes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:koinos.chain.verify_merkle_root_arguments.hashes)
}
inline void verify_merkle_root_arguments::add_hashes(const void* value, size_t size) {
  hashes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:koinos.chain.verify_merkle_root_arguments.hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
verify_merkle_root_arguments::hashes() const {
  // @@protoc_insertion_point(field_list:koinos.chain.verify_merkle_root_arguments.hashes)
  return hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
verify_merkle_root_arguments::mutable_hashes() {
  // @@protoc_insertion_point(field_mutable_list:koinos.chain.verify_merkle_root_arguments.hashes)
  return &hashes_;
}

// -------------------------------------------------------------------

// verify_merkle_root_result

// bool value = 1;
inline void verify_merkle_root_result::clear_value() {
  value_ = false;
}
inline bool verify_merkle_root_result::_internal_value() const {
  return value_;
}
inline bool verify_merkle_root_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.verify_merkle_root_result.value)
  return _internal_value();
}
inline void verify_merkle_root_result::_internal_set_value(bool value) {
  
  value_ = value;
}
inline void verify_merkle_root_result::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.verify_merkle_root_result.value)
}

// -------------------------------------------------------------------

// apply_block_arguments

// .koinos.protocol.block block = 1;
inline bool apply_block_arguments::_internal_has_block() const {
  return this != internal_default_instance() && block_ != nullptr;
}
inline bool apply_block_arguments::has_block() const {
  return _internal_has_block();
}
inline const ::koinos::protocol::block& apply_block_arguments::_internal_block() const {
  const ::koinos::protocol::block* p = block_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::protocol::block&>(
      ::koinos::protocol::_block_default_instance_);
}
inline const ::koinos::protocol::block& apply_block_arguments::block() const {
  // @@protoc_insertion_point(field_get:koinos.chain.apply_block_arguments.block)
  return _internal_block();
}
inline void apply_block_arguments::unsafe_arena_set_allocated_block(
    ::koinos::protocol::block* block) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_);
  }
  block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.apply_block_arguments.block)
}
inline ::koinos::protocol::block* apply_block_arguments::release_block() {
  
  ::koinos::protocol::block* temp = block_;
  block_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::protocol::block* apply_block_arguments::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:koinos.chain.apply_block_arguments.block)
  
  ::koinos::protocol::block* temp = block_;
  block_ = nullptr;
  return temp;
}
inline ::koinos::protocol::block* apply_block_arguments::_internal_mutable_block() {
  
  if (block_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::protocol::block>(GetArenaForAllocation());
    block_ = p;
  }
  return block_;
}
inline ::koinos::protocol::block* apply_block_arguments::mutable_block() {
  ::koinos::protocol::block* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:koinos.chain.apply_block_arguments.block)
  return _msg;
}
inline void apply_block_arguments::set_allocated_block(::koinos::protocol::block* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_);
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block));
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.apply_block_arguments.block)
}

// bool check_passive_data = 2;
inline void apply_block_arguments::clear_check_passive_data() {
  check_passive_data_ = false;
}
inline bool apply_block_arguments::_internal_check_passive_data() const {
  return check_passive_data_;
}
inline bool apply_block_arguments::check_passive_data() const {
  // @@protoc_insertion_point(field_get:koinos.chain.apply_block_arguments.check_passive_data)
  return _internal_check_passive_data();
}
inline void apply_block_arguments::_internal_set_check_passive_data(bool value) {
  
  check_passive_data_ = value;
}
inline void apply_block_arguments::set_check_passive_data(bool value) {
  _internal_set_check_passive_data(value);
  // @@protoc_insertion_point(field_set:koinos.chain.apply_block_arguments.check_passive_data)
}

// bool check_block_signature = 3;
inline void apply_block_arguments::clear_check_block_signature() {
  check_block_signature_ = false;
}
inline bool apply_block_arguments::_internal_check_block_signature() const {
  return check_block_signature_;
}
inline bool apply_block_arguments::check_block_signature() const {
  // @@protoc_insertion_point(field_get:koinos.chain.apply_block_arguments.check_block_signature)
  return _internal_check_block_signature();
}
inline void apply_block_arguments::_internal_set_check_block_signature(bool value) {
  
  check_block_signature_ = value;
}
inline void apply_block_arguments::set_check_block_signature(bool value) {
  _internal_set_check_block_signature(value);
  // @@protoc_insertion_point(field_set:koinos.chain.apply_block_arguments.check_block_signature)
}

// bool check_transaction_signature = 4;
inline void apply_block_arguments::clear_check_transaction_signature() {
  check_transaction_signature_ = false;
}
inline bool apply_block_arguments::_internal_check_transaction_signature() const {
  return check_transaction_signature_;
}
inline bool apply_block_arguments::check_transaction_signature() const {
  // @@protoc_insertion_point(field_get:koinos.chain.apply_block_arguments.check_transaction_signature)
  return _internal_check_transaction_signature();
}
inline void apply_block_arguments::_internal_set_check_transaction_signature(bool value) {
  
  check_transaction_signature_ = value;
}
inline void apply_block_arguments::set_check_transaction_signature(bool value) {
  _internal_set_check_transaction_signature(value);
  // @@protoc_insertion_point(field_set:koinos.chain.apply_block_arguments.check_transaction_signature)
}

// -------------------------------------------------------------------

// apply_block_result

// -------------------------------------------------------------------

// apply_transaction_arguments

// .koinos.protocol.transaction transaction = 1;
inline bool apply_transaction_arguments::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool apply_transaction_arguments::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::koinos::protocol::transaction& apply_transaction_arguments::_internal_transaction() const {
  const ::koinos::protocol::transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::protocol::transaction&>(
      ::koinos::protocol::_transaction_default_instance_);
}
inline const ::koinos::protocol::transaction& apply_transaction_arguments::transaction() const {
  // @@protoc_insertion_point(field_get:koinos.chain.apply_transaction_arguments.transaction)
  return _internal_transaction();
}
inline void apply_transaction_arguments::unsafe_arena_set_allocated_transaction(
    ::koinos::protocol::transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.apply_transaction_arguments.transaction)
}
inline ::koinos::protocol::transaction* apply_transaction_arguments::release_transaction() {
  
  ::koinos::protocol::transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::protocol::transaction* apply_transaction_arguments::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:koinos.chain.apply_transaction_arguments.transaction)
  
  ::koinos::protocol::transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::koinos::protocol::transaction* apply_transaction_arguments::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::protocol::transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::koinos::protocol::transaction* apply_transaction_arguments::mutable_transaction() {
  ::koinos::protocol::transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:koinos.chain.apply_transaction_arguments.transaction)
  return _msg;
}
inline void apply_transaction_arguments::set_allocated_transaction(::koinos::protocol::transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.apply_transaction_arguments.transaction)
}

// -------------------------------------------------------------------

// apply_transaction_result

// -------------------------------------------------------------------

// apply_upload_contract_operation_arguments

// .koinos.protocol.upload_contract_operation op = 1;
inline bool apply_upload_contract_operation_arguments::_internal_has_op() const {
  return this != internal_default_instance() && op_ != nullptr;
}
inline bool apply_upload_contract_operation_arguments::has_op() const {
  return _internal_has_op();
}
inline const ::koinos::protocol::upload_contract_operation& apply_upload_contract_operation_arguments::_internal_op() const {
  const ::koinos::protocol::upload_contract_operation* p = op_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::protocol::upload_contract_operation&>(
      ::koinos::protocol::_upload_contract_operation_default_instance_);
}
inline const ::koinos::protocol::upload_contract_operation& apply_upload_contract_operation_arguments::op() const {
  // @@protoc_insertion_point(field_get:koinos.chain.apply_upload_contract_operation_arguments.op)
  return _internal_op();
}
inline void apply_upload_contract_operation_arguments::unsafe_arena_set_allocated_op(
    ::koinos::protocol::upload_contract_operation* op) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(op_);
  }
  op_ = op;
  if (op) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.apply_upload_contract_operation_arguments.op)
}
inline ::koinos::protocol::upload_contract_operation* apply_upload_contract_operation_arguments::release_op() {
  
  ::koinos::protocol::upload_contract_operation* temp = op_;
  op_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::protocol::upload_contract_operation* apply_upload_contract_operation_arguments::unsafe_arena_release_op() {
  // @@protoc_insertion_point(field_release:koinos.chain.apply_upload_contract_operation_arguments.op)
  
  ::koinos::protocol::upload_contract_operation* temp = op_;
  op_ = nullptr;
  return temp;
}
inline ::koinos::protocol::upload_contract_operation* apply_upload_contract_operation_arguments::_internal_mutable_op() {
  
  if (op_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::protocol::upload_contract_operation>(GetArenaForAllocation());
    op_ = p;
  }
  return op_;
}
inline ::koinos::protocol::upload_contract_operation* apply_upload_contract_operation_arguments::mutable_op() {
  ::koinos::protocol::upload_contract_operation* _msg = _internal_mutable_op();
  // @@protoc_insertion_point(field_mutable:koinos.chain.apply_upload_contract_operation_arguments.op)
  return _msg;
}
inline void apply_upload_contract_operation_arguments::set_allocated_op(::koinos::protocol::upload_contract_operation* op) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(op_);
  }
  if (op) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(op));
    if (message_arena != submessage_arena) {
      op = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, op, submessage_arena);
    }
    
  } else {
    
  }
  op_ = op;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.apply_upload_contract_operation_arguments.op)
}

// -------------------------------------------------------------------

// apply_upload_contract_operation_result

// -------------------------------------------------------------------

// apply_call_contract_operation_arguments

// .koinos.protocol.call_contract_operation op = 1;
inline bool apply_call_contract_operation_arguments::_internal_has_op() const {
  return this != internal_default_instance() && op_ != nullptr;
}
inline bool apply_call_contract_operation_arguments::has_op() const {
  return _internal_has_op();
}
inline const ::koinos::protocol::call_contract_operation& apply_call_contract_operation_arguments::_internal_op() const {
  const ::koinos::protocol::call_contract_operation* p = op_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::protocol::call_contract_operation&>(
      ::koinos::protocol::_call_contract_operation_default_instance_);
}
inline const ::koinos::protocol::call_contract_operation& apply_call_contract_operation_arguments::op() const {
  // @@protoc_insertion_point(field_get:koinos.chain.apply_call_contract_operation_arguments.op)
  return _internal_op();
}
inline void apply_call_contract_operation_arguments::unsafe_arena_set_allocated_op(
    ::koinos::protocol::call_contract_operation* op) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(op_);
  }
  op_ = op;
  if (op) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.apply_call_contract_operation_arguments.op)
}
inline ::koinos::protocol::call_contract_operation* apply_call_contract_operation_arguments::release_op() {
  
  ::koinos::protocol::call_contract_operation* temp = op_;
  op_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::protocol::call_contract_operation* apply_call_contract_operation_arguments::unsafe_arena_release_op() {
  // @@protoc_insertion_point(field_release:koinos.chain.apply_call_contract_operation_arguments.op)
  
  ::koinos::protocol::call_contract_operation* temp = op_;
  op_ = nullptr;
  return temp;
}
inline ::koinos::protocol::call_contract_operation* apply_call_contract_operation_arguments::_internal_mutable_op() {
  
  if (op_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::protocol::call_contract_operation>(GetArenaForAllocation());
    op_ = p;
  }
  return op_;
}
inline ::koinos::protocol::call_contract_operation* apply_call_contract_operation_arguments::mutable_op() {
  ::koinos::protocol::call_contract_operation* _msg = _internal_mutable_op();
  // @@protoc_insertion_point(field_mutable:koinos.chain.apply_call_contract_operation_arguments.op)
  return _msg;
}
inline void apply_call_contract_operation_arguments::set_allocated_op(::koinos::protocol::call_contract_operation* op) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(op_);
  }
  if (op) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(op));
    if (message_arena != submessage_arena) {
      op = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, op, submessage_arena);
    }
    
  } else {
    
  }
  op_ = op;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.apply_call_contract_operation_arguments.op)
}

// -------------------------------------------------------------------

// apply_call_contract_operation_result

// -------------------------------------------------------------------

// apply_set_system_call_operation_arguments

// .koinos.protocol.set_system_call_operation op = 1;
inline bool apply_set_system_call_operation_arguments::_internal_has_op() const {
  return this != internal_default_instance() && op_ != nullptr;
}
inline bool apply_set_system_call_operation_arguments::has_op() const {
  return _internal_has_op();
}
inline const ::koinos::protocol::set_system_call_operation& apply_set_system_call_operation_arguments::_internal_op() const {
  const ::koinos::protocol::set_system_call_operation* p = op_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::protocol::set_system_call_operation&>(
      ::koinos::protocol::_set_system_call_operation_default_instance_);
}
inline const ::koinos::protocol::set_system_call_operation& apply_set_system_call_operation_arguments::op() const {
  // @@protoc_insertion_point(field_get:koinos.chain.apply_set_system_call_operation_arguments.op)
  return _internal_op();
}
inline void apply_set_system_call_operation_arguments::unsafe_arena_set_allocated_op(
    ::koinos::protocol::set_system_call_operation* op) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(op_);
  }
  op_ = op;
  if (op) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.apply_set_system_call_operation_arguments.op)
}
inline ::koinos::protocol::set_system_call_operation* apply_set_system_call_operation_arguments::release_op() {
  
  ::koinos::protocol::set_system_call_operation* temp = op_;
  op_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::protocol::set_system_call_operation* apply_set_system_call_operation_arguments::unsafe_arena_release_op() {
  // @@protoc_insertion_point(field_release:koinos.chain.apply_set_system_call_operation_arguments.op)
  
  ::koinos::protocol::set_system_call_operation* temp = op_;
  op_ = nullptr;
  return temp;
}
inline ::koinos::protocol::set_system_call_operation* apply_set_system_call_operation_arguments::_internal_mutable_op() {
  
  if (op_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::protocol::set_system_call_operation>(GetArenaForAllocation());
    op_ = p;
  }
  return op_;
}
inline ::koinos::protocol::set_system_call_operation* apply_set_system_call_operation_arguments::mutable_op() {
  ::koinos::protocol::set_system_call_operation* _msg = _internal_mutable_op();
  // @@protoc_insertion_point(field_mutable:koinos.chain.apply_set_system_call_operation_arguments.op)
  return _msg;
}
inline void apply_set_system_call_operation_arguments::set_allocated_op(::koinos::protocol::set_system_call_operation* op) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(op_);
  }
  if (op) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(op));
    if (message_arena != submessage_arena) {
      op = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, op, submessage_arena);
    }
    
  } else {
    
  }
  op_ = op;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.apply_set_system_call_operation_arguments.op)
}

// -------------------------------------------------------------------

// apply_set_system_call_operation_result

// -------------------------------------------------------------------

// put_object_arguments

// .koinos.chain.object_space space = 1;
inline bool put_object_arguments::_internal_has_space() const {
  return this != internal_default_instance() && space_ != nullptr;
}
inline bool put_object_arguments::has_space() const {
  return _internal_has_space();
}
inline void put_object_arguments::clear_space() {
  if (GetArenaForAllocation() == nullptr && space_ != nullptr) {
    delete space_;
  }
  space_ = nullptr;
}
inline const ::koinos::chain::object_space& put_object_arguments::_internal_space() const {
  const ::koinos::chain::object_space* p = space_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::object_space&>(
      ::koinos::chain::_object_space_default_instance_);
}
inline const ::koinos::chain::object_space& put_object_arguments::space() const {
  // @@protoc_insertion_point(field_get:koinos.chain.put_object_arguments.space)
  return _internal_space();
}
inline void put_object_arguments::unsafe_arena_set_allocated_space(
    ::koinos::chain::object_space* space) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(space_);
  }
  space_ = space;
  if (space) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.put_object_arguments.space)
}
inline ::koinos::chain::object_space* put_object_arguments::release_space() {
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::object_space* put_object_arguments::unsafe_arena_release_space() {
  // @@protoc_insertion_point(field_release:koinos.chain.put_object_arguments.space)
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
  return temp;
}
inline ::koinos::chain::object_space* put_object_arguments::_internal_mutable_space() {
  
  if (space_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::object_space>(GetArenaForAllocation());
    space_ = p;
  }
  return space_;
}
inline ::koinos::chain::object_space* put_object_arguments::mutable_space() {
  ::koinos::chain::object_space* _msg = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:koinos.chain.put_object_arguments.space)
  return _msg;
}
inline void put_object_arguments::set_allocated_space(::koinos::chain::object_space* space) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete space_;
  }
  if (space) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::koinos::chain::object_space>::GetOwningArena(space);
    if (message_arena != submessage_arena) {
      space = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, space, submessage_arena);
    }
    
  } else {
    
  }
  space_ = space;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.put_object_arguments.space)
}

// bytes key = 2;
inline void put_object_arguments::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& put_object_arguments::key() const {
  // @@protoc_insertion_point(field_get:koinos.chain.put_object_arguments.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void put_object_arguments::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.put_object_arguments.key)
}
inline std::string* put_object_arguments::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:koinos.chain.put_object_arguments.key)
  return _s;
}
inline const std::string& put_object_arguments::_internal_key() const {
  return key_.Get();
}
inline void put_object_arguments::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* put_object_arguments::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* put_object_arguments::release_key() {
  // @@protoc_insertion_point(field_release:koinos.chain.put_object_arguments.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void put_object_arguments::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.put_object_arguments.key)
}

// bytes obj = 3;
inline void put_object_arguments::clear_obj() {
  obj_.ClearToEmpty();
}
inline const std::string& put_object_arguments::obj() const {
  // @@protoc_insertion_point(field_get:koinos.chain.put_object_arguments.obj)
  return _internal_obj();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void put_object_arguments::set_obj(ArgT0&& arg0, ArgT... args) {
 
 obj_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.put_object_arguments.obj)
}
inline std::string* put_object_arguments::mutable_obj() {
  std::string* _s = _internal_mutable_obj();
  // @@protoc_insertion_point(field_mutable:koinos.chain.put_object_arguments.obj)
  return _s;
}
inline const std::string& put_object_arguments::_internal_obj() const {
  return obj_.Get();
}
inline void put_object_arguments::_internal_set_obj(const std::string& value) {
  
  obj_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* put_object_arguments::_internal_mutable_obj() {
  
  return obj_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* put_object_arguments::release_obj() {
  // @@protoc_insertion_point(field_release:koinos.chain.put_object_arguments.obj)
  return obj_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void put_object_arguments::set_allocated_obj(std::string* obj) {
  if (obj != nullptr) {
    
  } else {
    
  }
  obj_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), obj,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.put_object_arguments.obj)
}

// -------------------------------------------------------------------

// put_object_result

// bool value = 1;
inline void put_object_result::clear_value() {
  value_ = false;
}
inline bool put_object_result::_internal_value() const {
  return value_;
}
inline bool put_object_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.put_object_result.value)
  return _internal_value();
}
inline void put_object_result::_internal_set_value(bool value) {
  
  value_ = value;
}
inline void put_object_result::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.put_object_result.value)
}

// -------------------------------------------------------------------

// get_object_arguments

// .koinos.chain.object_space space = 1;
inline bool get_object_arguments::_internal_has_space() const {
  return this != internal_default_instance() && space_ != nullptr;
}
inline bool get_object_arguments::has_space() const {
  return _internal_has_space();
}
inline void get_object_arguments::clear_space() {
  if (GetArenaForAllocation() == nullptr && space_ != nullptr) {
    delete space_;
  }
  space_ = nullptr;
}
inline const ::koinos::chain::object_space& get_object_arguments::_internal_space() const {
  const ::koinos::chain::object_space* p = space_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::object_space&>(
      ::koinos::chain::_object_space_default_instance_);
}
inline const ::koinos::chain::object_space& get_object_arguments::space() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_object_arguments.space)
  return _internal_space();
}
inline void get_object_arguments::unsafe_arena_set_allocated_space(
    ::koinos::chain::object_space* space) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(space_);
  }
  space_ = space;
  if (space) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_object_arguments.space)
}
inline ::koinos::chain::object_space* get_object_arguments::release_space() {
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::object_space* get_object_arguments::unsafe_arena_release_space() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_object_arguments.space)
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
  return temp;
}
inline ::koinos::chain::object_space* get_object_arguments::_internal_mutable_space() {
  
  if (space_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::object_space>(GetArenaForAllocation());
    space_ = p;
  }
  return space_;
}
inline ::koinos::chain::object_space* get_object_arguments::mutable_space() {
  ::koinos::chain::object_space* _msg = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_object_arguments.space)
  return _msg;
}
inline void get_object_arguments::set_allocated_space(::koinos::chain::object_space* space) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete space_;
  }
  if (space) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::koinos::chain::object_space>::GetOwningArena(space);
    if (message_arena != submessage_arena) {
      space = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, space, submessage_arena);
    }
    
  } else {
    
  }
  space_ = space;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_object_arguments.space)
}

// bytes key = 2;
inline void get_object_arguments::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& get_object_arguments::key() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_object_arguments.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_object_arguments::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_object_arguments.key)
}
inline std::string* get_object_arguments::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_object_arguments.key)
  return _s;
}
inline const std::string& get_object_arguments::_internal_key() const {
  return key_.Get();
}
inline void get_object_arguments::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_object_arguments::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_object_arguments::release_key() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_object_arguments.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_object_arguments::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_object_arguments.key)
}

// uint32 object_size_hint = 3;
inline void get_object_arguments::clear_object_size_hint() {
  object_size_hint_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 get_object_arguments::_internal_object_size_hint() const {
  return object_size_hint_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 get_object_arguments::object_size_hint() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_object_arguments.object_size_hint)
  return _internal_object_size_hint();
}
inline void get_object_arguments::_internal_set_object_size_hint(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  object_size_hint_ = value;
}
inline void get_object_arguments::set_object_size_hint(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_object_size_hint(value);
  // @@protoc_insertion_point(field_set:koinos.chain.get_object_arguments.object_size_hint)
}

// -------------------------------------------------------------------

// get_object_result

// bytes value = 3;
inline void get_object_result::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& get_object_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_object_result.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_object_result::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_object_result.value)
}
inline std::string* get_object_result::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_object_result.value)
  return _s;
}
inline const std::string& get_object_result::_internal_value() const {
  return value_.Get();
}
inline void get_object_result::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_object_result::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_object_result::release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_object_result.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_object_result::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_object_result.value)
}

// -------------------------------------------------------------------

// get_next_object_arguments

// .koinos.chain.object_space space = 1;
inline bool get_next_object_arguments::_internal_has_space() const {
  return this != internal_default_instance() && space_ != nullptr;
}
inline bool get_next_object_arguments::has_space() const {
  return _internal_has_space();
}
inline void get_next_object_arguments::clear_space() {
  if (GetArenaForAllocation() == nullptr && space_ != nullptr) {
    delete space_;
  }
  space_ = nullptr;
}
inline const ::koinos::chain::object_space& get_next_object_arguments::_internal_space() const {
  const ::koinos::chain::object_space* p = space_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::object_space&>(
      ::koinos::chain::_object_space_default_instance_);
}
inline const ::koinos::chain::object_space& get_next_object_arguments::space() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_next_object_arguments.space)
  return _internal_space();
}
inline void get_next_object_arguments::unsafe_arena_set_allocated_space(
    ::koinos::chain::object_space* space) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(space_);
  }
  space_ = space;
  if (space) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_next_object_arguments.space)
}
inline ::koinos::chain::object_space* get_next_object_arguments::release_space() {
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::object_space* get_next_object_arguments::unsafe_arena_release_space() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_next_object_arguments.space)
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
  return temp;
}
inline ::koinos::chain::object_space* get_next_object_arguments::_internal_mutable_space() {
  
  if (space_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::object_space>(GetArenaForAllocation());
    space_ = p;
  }
  return space_;
}
inline ::koinos::chain::object_space* get_next_object_arguments::mutable_space() {
  ::koinos::chain::object_space* _msg = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_next_object_arguments.space)
  return _msg;
}
inline void get_next_object_arguments::set_allocated_space(::koinos::chain::object_space* space) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete space_;
  }
  if (space) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::koinos::chain::object_space>::GetOwningArena(space);
    if (message_arena != submessage_arena) {
      space = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, space, submessage_arena);
    }
    
  } else {
    
  }
  space_ = space;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_next_object_arguments.space)
}

// bytes key = 2;
inline void get_next_object_arguments::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& get_next_object_arguments::key() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_next_object_arguments.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_next_object_arguments::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_next_object_arguments.key)
}
inline std::string* get_next_object_arguments::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_next_object_arguments.key)
  return _s;
}
inline const std::string& get_next_object_arguments::_internal_key() const {
  return key_.Get();
}
inline void get_next_object_arguments::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_next_object_arguments::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_next_object_arguments::release_key() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_next_object_arguments.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_next_object_arguments::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_next_object_arguments.key)
}

// uint32 object_size_hint = 3;
inline void get_next_object_arguments::clear_object_size_hint() {
  object_size_hint_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 get_next_object_arguments::_internal_object_size_hint() const {
  return object_size_hint_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 get_next_object_arguments::object_size_hint() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_next_object_arguments.object_size_hint)
  return _internal_object_size_hint();
}
inline void get_next_object_arguments::_internal_set_object_size_hint(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  object_size_hint_ = value;
}
inline void get_next_object_arguments::set_object_size_hint(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_object_size_hint(value);
  // @@protoc_insertion_point(field_set:koinos.chain.get_next_object_arguments.object_size_hint)
}

// -------------------------------------------------------------------

// get_next_object_result

// bytes value = 3;
inline void get_next_object_result::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& get_next_object_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_next_object_result.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_next_object_result::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_next_object_result.value)
}
inline std::string* get_next_object_result::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_next_object_result.value)
  return _s;
}
inline const std::string& get_next_object_result::_internal_value() const {
  return value_.Get();
}
inline void get_next_object_result::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_next_object_result::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_next_object_result::release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_next_object_result.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_next_object_result::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_next_object_result.value)
}

// -------------------------------------------------------------------

// get_prev_object_arguments

// .koinos.chain.object_space space = 1;
inline bool get_prev_object_arguments::_internal_has_space() const {
  return this != internal_default_instance() && space_ != nullptr;
}
inline bool get_prev_object_arguments::has_space() const {
  return _internal_has_space();
}
inline void get_prev_object_arguments::clear_space() {
  if (GetArenaForAllocation() == nullptr && space_ != nullptr) {
    delete space_;
  }
  space_ = nullptr;
}
inline const ::koinos::chain::object_space& get_prev_object_arguments::_internal_space() const {
  const ::koinos::chain::object_space* p = space_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::object_space&>(
      ::koinos::chain::_object_space_default_instance_);
}
inline const ::koinos::chain::object_space& get_prev_object_arguments::space() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_prev_object_arguments.space)
  return _internal_space();
}
inline void get_prev_object_arguments::unsafe_arena_set_allocated_space(
    ::koinos::chain::object_space* space) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(space_);
  }
  space_ = space;
  if (space) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_prev_object_arguments.space)
}
inline ::koinos::chain::object_space* get_prev_object_arguments::release_space() {
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::object_space* get_prev_object_arguments::unsafe_arena_release_space() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_prev_object_arguments.space)
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
  return temp;
}
inline ::koinos::chain::object_space* get_prev_object_arguments::_internal_mutable_space() {
  
  if (space_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::object_space>(GetArenaForAllocation());
    space_ = p;
  }
  return space_;
}
inline ::koinos::chain::object_space* get_prev_object_arguments::mutable_space() {
  ::koinos::chain::object_space* _msg = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_prev_object_arguments.space)
  return _msg;
}
inline void get_prev_object_arguments::set_allocated_space(::koinos::chain::object_space* space) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete space_;
  }
  if (space) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::koinos::chain::object_space>::GetOwningArena(space);
    if (message_arena != submessage_arena) {
      space = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, space, submessage_arena);
    }
    
  } else {
    
  }
  space_ = space;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_prev_object_arguments.space)
}

// bytes key = 2;
inline void get_prev_object_arguments::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& get_prev_object_arguments::key() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_prev_object_arguments.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_prev_object_arguments::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_prev_object_arguments.key)
}
inline std::string* get_prev_object_arguments::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_prev_object_arguments.key)
  return _s;
}
inline const std::string& get_prev_object_arguments::_internal_key() const {
  return key_.Get();
}
inline void get_prev_object_arguments::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_prev_object_arguments::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_prev_object_arguments::release_key() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_prev_object_arguments.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_prev_object_arguments::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_prev_object_arguments.key)
}

// uint32 object_size_hint = 3;
inline void get_prev_object_arguments::clear_object_size_hint() {
  object_size_hint_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 get_prev_object_arguments::_internal_object_size_hint() const {
  return object_size_hint_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 get_prev_object_arguments::object_size_hint() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_prev_object_arguments.object_size_hint)
  return _internal_object_size_hint();
}
inline void get_prev_object_arguments::_internal_set_object_size_hint(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  object_size_hint_ = value;
}
inline void get_prev_object_arguments::set_object_size_hint(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_object_size_hint(value);
  // @@protoc_insertion_point(field_set:koinos.chain.get_prev_object_arguments.object_size_hint)
}

// -------------------------------------------------------------------

// get_prev_object_result

// bytes value = 3;
inline void get_prev_object_result::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& get_prev_object_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_prev_object_result.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_prev_object_result::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_prev_object_result.value)
}
inline std::string* get_prev_object_result::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_prev_object_result.value)
  return _s;
}
inline const std::string& get_prev_object_result::_internal_value() const {
  return value_.Get();
}
inline void get_prev_object_result::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_prev_object_result::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_prev_object_result::release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_prev_object_result.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_prev_object_result::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_prev_object_result.value)
}

// -------------------------------------------------------------------

// call_contract_arguments

// bytes contract_id = 1;
inline void call_contract_arguments::clear_contract_id() {
  contract_id_.ClearToEmpty();
}
inline const std::string& call_contract_arguments::contract_id() const {
  // @@protoc_insertion_point(field_get:koinos.chain.call_contract_arguments.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void call_contract_arguments::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 contract_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.call_contract_arguments.contract_id)
}
inline std::string* call_contract_arguments::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:koinos.chain.call_contract_arguments.contract_id)
  return _s;
}
inline const std::string& call_contract_arguments::_internal_contract_id() const {
  return contract_id_.Get();
}
inline void call_contract_arguments::_internal_set_contract_id(const std::string& value) {
  
  contract_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* call_contract_arguments::_internal_mutable_contract_id() {
  
  return contract_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* call_contract_arguments::release_contract_id() {
  // @@protoc_insertion_point(field_release:koinos.chain.call_contract_arguments.contract_id)
  return contract_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void call_contract_arguments::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  contract_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.call_contract_arguments.contract_id)
}

// uint32 entry_point = 2;
inline void call_contract_arguments::clear_entry_point() {
  entry_point_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 call_contract_arguments::_internal_entry_point() const {
  return entry_point_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 call_contract_arguments::entry_point() const {
  // @@protoc_insertion_point(field_get:koinos.chain.call_contract_arguments.entry_point)
  return _internal_entry_point();
}
inline void call_contract_arguments::_internal_set_entry_point(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  entry_point_ = value;
}
inline void call_contract_arguments::set_entry_point(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_entry_point(value);
  // @@protoc_insertion_point(field_set:koinos.chain.call_contract_arguments.entry_point)
}

// bytes args = 3;
inline void call_contract_arguments::clear_args() {
  args_.ClearToEmpty();
}
inline const std::string& call_contract_arguments::args() const {
  // @@protoc_insertion_point(field_get:koinos.chain.call_contract_arguments.args)
  return _internal_args();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void call_contract_arguments::set_args(ArgT0&& arg0, ArgT... args) {
 
 args_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.call_contract_arguments.args)
}
inline std::string* call_contract_arguments::mutable_args() {
  std::string* _s = _internal_mutable_args();
  // @@protoc_insertion_point(field_mutable:koinos.chain.call_contract_arguments.args)
  return _s;
}
inline const std::string& call_contract_arguments::_internal_args() const {
  return args_.Get();
}
inline void call_contract_arguments::_internal_set_args(const std::string& value) {
  
  args_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* call_contract_arguments::_internal_mutable_args() {
  
  return args_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* call_contract_arguments::release_args() {
  // @@protoc_insertion_point(field_release:koinos.chain.call_contract_arguments.args)
  return args_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void call_contract_arguments::set_allocated_args(std::string* args) {
  if (args != nullptr) {
    
  } else {
    
  }
  args_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), args,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.call_contract_arguments.args)
}

// -------------------------------------------------------------------

// call_contract_result

// bytes value = 1;
inline void call_contract_result::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& call_contract_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.call_contract_result.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void call_contract_result::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.call_contract_result.value)
}
inline std::string* call_contract_result::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.call_contract_result.value)
  return _s;
}
inline const std::string& call_contract_result::_internal_value() const {
  return value_.Get();
}
inline void call_contract_result::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* call_contract_result::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* call_contract_result::release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.call_contract_result.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void call_contract_result::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.call_contract_result.value)
}

// -------------------------------------------------------------------

// get_entry_point_arguments

// -------------------------------------------------------------------

// get_entry_point_result

// uint32 value = 1;
inline void get_entry_point_result::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 get_entry_point_result::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 get_entry_point_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_entry_point_result.value)
  return _internal_value();
}
inline void get_entry_point_result::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
}
inline void get_entry_point_result::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.get_entry_point_result.value)
}

// -------------------------------------------------------------------

// get_contract_arguments_size_arguments

// -------------------------------------------------------------------

// get_contract_arguments_size_result

// uint32 value = 1;
inline void get_contract_arguments_size_result::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 get_contract_arguments_size_result::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 get_contract_arguments_size_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_contract_arguments_size_result.value)
  return _internal_value();
}
inline void get_contract_arguments_size_result::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
}
inline void get_contract_arguments_size_result::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.get_contract_arguments_size_result.value)
}

// -------------------------------------------------------------------

// get_contract_arguments_arguments

// -------------------------------------------------------------------

// get_contract_arguments_result

// bytes value = 1;
inline void get_contract_arguments_result::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& get_contract_arguments_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_contract_arguments_result.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_contract_arguments_result::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_contract_arguments_result.value)
}
inline std::string* get_contract_arguments_result::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_contract_arguments_result.value)
  return _s;
}
inline const std::string& get_contract_arguments_result::_internal_value() const {
  return value_.Get();
}
inline void get_contract_arguments_result::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_contract_arguments_result::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_contract_arguments_result::release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_contract_arguments_result.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_contract_arguments_result::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_contract_arguments_result.value)
}

// -------------------------------------------------------------------

// set_contract_result_arguments

// bytes value = 1;
inline void set_contract_result_arguments::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& set_contract_result_arguments::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.set_contract_result_arguments.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void set_contract_result_arguments::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.set_contract_result_arguments.value)
}
inline std::string* set_contract_result_arguments::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.set_contract_result_arguments.value)
  return _s;
}
inline const std::string& set_contract_result_arguments::_internal_value() const {
  return value_.Get();
}
inline void set_contract_result_arguments::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* set_contract_result_arguments::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* set_contract_result_arguments::release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.set_contract_result_arguments.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void set_contract_result_arguments::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.set_contract_result_arguments.value)
}

// -------------------------------------------------------------------

// set_contract_result_result

// -------------------------------------------------------------------

// exit_contract_arguments

// uint32 exit_code = 1;
inline void exit_contract_arguments::clear_exit_code() {
  exit_code_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 exit_contract_arguments::_internal_exit_code() const {
  return exit_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 exit_contract_arguments::exit_code() const {
  // @@protoc_insertion_point(field_get:koinos.chain.exit_contract_arguments.exit_code)
  return _internal_exit_code();
}
inline void exit_contract_arguments::_internal_set_exit_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  exit_code_ = value;
}
inline void exit_contract_arguments::set_exit_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_exit_code(value);
  // @@protoc_insertion_point(field_set:koinos.chain.exit_contract_arguments.exit_code)
}

// -------------------------------------------------------------------

// exit_contract_result

// -------------------------------------------------------------------

// get_head_info_arguments

// -------------------------------------------------------------------

// get_head_info_result

// .koinos.chain.head_info value = 1;
inline bool get_head_info_result::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool get_head_info_result::has_value() const {
  return _internal_has_value();
}
inline void get_head_info_result::clear_value() {
  if (GetArenaForAllocation() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::koinos::chain::head_info& get_head_info_result::_internal_value() const {
  const ::koinos::chain::head_info* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::head_info&>(
      ::koinos::chain::_head_info_default_instance_);
}
inline const ::koinos::chain::head_info& get_head_info_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_head_info_result.value)
  return _internal_value();
}
inline void get_head_info_result::unsafe_arena_set_allocated_value(
    ::koinos::chain::head_info* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_head_info_result.value)
}
inline ::koinos::chain::head_info* get_head_info_result::release_value() {
  
  ::koinos::chain::head_info* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::head_info* get_head_info_result::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_head_info_result.value)
  
  ::koinos::chain::head_info* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::koinos::chain::head_info* get_head_info_result::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::head_info>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::koinos::chain::head_info* get_head_info_result::mutable_value() {
  ::koinos::chain::head_info* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_head_info_result.value)
  return _msg;
}
inline void get_head_info_result::set_allocated_value(::koinos::chain::head_info* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::koinos::chain::head_info>::GetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_head_info_result.value)
}

// -------------------------------------------------------------------

// hash_arguments

// uint64 code = 1 [jstype = JS_STRING];
inline void hash_arguments::clear_code() {
  code_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 hash_arguments::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 hash_arguments::code() const {
  // @@protoc_insertion_point(field_get:koinos.chain.hash_arguments.code)
  return _internal_code();
}
inline void hash_arguments::_internal_set_code(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  code_ = value;
}
inline void hash_arguments::set_code(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:koinos.chain.hash_arguments.code)
}

// bytes obj = 2;
inline void hash_arguments::clear_obj() {
  obj_.ClearToEmpty();
}
inline const std::string& hash_arguments::obj() const {
  // @@protoc_insertion_point(field_get:koinos.chain.hash_arguments.obj)
  return _internal_obj();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void hash_arguments::set_obj(ArgT0&& arg0, ArgT... args) {
 
 obj_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.hash_arguments.obj)
}
inline std::string* hash_arguments::mutable_obj() {
  std::string* _s = _internal_mutable_obj();
  // @@protoc_insertion_point(field_mutable:koinos.chain.hash_arguments.obj)
  return _s;
}
inline const std::string& hash_arguments::_internal_obj() const {
  return obj_.Get();
}
inline void hash_arguments::_internal_set_obj(const std::string& value) {
  
  obj_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* hash_arguments::_internal_mutable_obj() {
  
  return obj_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* hash_arguments::release_obj() {
  // @@protoc_insertion_point(field_release:koinos.chain.hash_arguments.obj)
  return obj_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void hash_arguments::set_allocated_obj(std::string* obj) {
  if (obj != nullptr) {
    
  } else {
    
  }
  obj_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), obj,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.hash_arguments.obj)
}

// uint64 size = 3 [jstype = JS_STRING];
inline void hash_arguments::clear_size() {
  size_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 hash_arguments::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 hash_arguments::size() const {
  // @@protoc_insertion_point(field_get:koinos.chain.hash_arguments.size)
  return _internal_size();
}
inline void hash_arguments::_internal_set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  size_ = value;
}
inline void hash_arguments::set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:koinos.chain.hash_arguments.size)
}

// -------------------------------------------------------------------

// hash_result

// bytes value = 1;
inline void hash_result::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& hash_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.hash_result.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void hash_result::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.hash_result.value)
}
inline std::string* hash_result::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.hash_result.value)
  return _s;
}
inline const std::string& hash_result::_internal_value() const {
  return value_.Get();
}
inline void hash_result::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* hash_result::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* hash_result::release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.hash_result.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void hash_result::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.hash_result.value)
}

// -------------------------------------------------------------------

// recover_public_key_arguments

// bytes signature_data = 1;
inline void recover_public_key_arguments::clear_signature_data() {
  signature_data_.ClearToEmpty();
}
inline const std::string& recover_public_key_arguments::signature_data() const {
  // @@protoc_insertion_point(field_get:koinos.chain.recover_public_key_arguments.signature_data)
  return _internal_signature_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void recover_public_key_arguments::set_signature_data(ArgT0&& arg0, ArgT... args) {
 
 signature_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.recover_public_key_arguments.signature_data)
}
inline std::string* recover_public_key_arguments::mutable_signature_data() {
  std::string* _s = _internal_mutable_signature_data();
  // @@protoc_insertion_point(field_mutable:koinos.chain.recover_public_key_arguments.signature_data)
  return _s;
}
inline const std::string& recover_public_key_arguments::_internal_signature_data() const {
  return signature_data_.Get();
}
inline void recover_public_key_arguments::_internal_set_signature_data(const std::string& value) {
  
  signature_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* recover_public_key_arguments::_internal_mutable_signature_data() {
  
  return signature_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* recover_public_key_arguments::release_signature_data() {
  // @@protoc_insertion_point(field_release:koinos.chain.recover_public_key_arguments.signature_data)
  return signature_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void recover_public_key_arguments::set_allocated_signature_data(std::string* signature_data) {
  if (signature_data != nullptr) {
    
  } else {
    
  }
  signature_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.recover_public_key_arguments.signature_data)
}

// bytes digest = 2;
inline void recover_public_key_arguments::clear_digest() {
  digest_.ClearToEmpty();
}
inline const std::string& recover_public_key_arguments::digest() const {
  // @@protoc_insertion_point(field_get:koinos.chain.recover_public_key_arguments.digest)
  return _internal_digest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void recover_public_key_arguments::set_digest(ArgT0&& arg0, ArgT... args) {
 
 digest_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.recover_public_key_arguments.digest)
}
inline std::string* recover_public_key_arguments::mutable_digest() {
  std::string* _s = _internal_mutable_digest();
  // @@protoc_insertion_point(field_mutable:koinos.chain.recover_public_key_arguments.digest)
  return _s;
}
inline const std::string& recover_public_key_arguments::_internal_digest() const {
  return digest_.Get();
}
inline void recover_public_key_arguments::_internal_set_digest(const std::string& value) {
  
  digest_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* recover_public_key_arguments::_internal_mutable_digest() {
  
  return digest_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* recover_public_key_arguments::release_digest() {
  // @@protoc_insertion_point(field_release:koinos.chain.recover_public_key_arguments.digest)
  return digest_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void recover_public_key_arguments::set_allocated_digest(std::string* digest) {
  if (digest != nullptr) {
    
  } else {
    
  }
  digest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), digest,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.recover_public_key_arguments.digest)
}

// -------------------------------------------------------------------

// recover_public_key_result

// bytes value = 1;
inline void recover_public_key_result::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& recover_public_key_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.recover_public_key_result.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void recover_public_key_result::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.recover_public_key_result.value)
}
inline std::string* recover_public_key_result::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.recover_public_key_result.value)
  return _s;
}
inline const std::string& recover_public_key_result::_internal_value() const {
  return value_.Get();
}
inline void recover_public_key_result::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* recover_public_key_result::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* recover_public_key_result::release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.recover_public_key_result.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void recover_public_key_result::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.recover_public_key_result.value)
}

// -------------------------------------------------------------------

// get_transaction_payer_arguments

// .koinos.protocol.transaction transaction = 1;
inline bool get_transaction_payer_arguments::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool get_transaction_payer_arguments::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::koinos::protocol::transaction& get_transaction_payer_arguments::_internal_transaction() const {
  const ::koinos::protocol::transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::protocol::transaction&>(
      ::koinos::protocol::_transaction_default_instance_);
}
inline const ::koinos::protocol::transaction& get_transaction_payer_arguments::transaction() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_transaction_payer_arguments.transaction)
  return _internal_transaction();
}
inline void get_transaction_payer_arguments::unsafe_arena_set_allocated_transaction(
    ::koinos::protocol::transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_transaction_payer_arguments.transaction)
}
inline ::koinos::protocol::transaction* get_transaction_payer_arguments::release_transaction() {
  
  ::koinos::protocol::transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::protocol::transaction* get_transaction_payer_arguments::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_transaction_payer_arguments.transaction)
  
  ::koinos::protocol::transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::koinos::protocol::transaction* get_transaction_payer_arguments::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::protocol::transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::koinos::protocol::transaction* get_transaction_payer_arguments::mutable_transaction() {
  ::koinos::protocol::transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_transaction_payer_arguments.transaction)
  return _msg;
}
inline void get_transaction_payer_arguments::set_allocated_transaction(::koinos::protocol::transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_transaction_payer_arguments.transaction)
}

// -------------------------------------------------------------------

// get_transaction_payer_result

// bytes value = 1;
inline void get_transaction_payer_result::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& get_transaction_payer_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_transaction_payer_result.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_transaction_payer_result::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_transaction_payer_result.value)
}
inline std::string* get_transaction_payer_result::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_transaction_payer_result.value)
  return _s;
}
inline const std::string& get_transaction_payer_result::_internal_value() const {
  return value_.Get();
}
inline void get_transaction_payer_result::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_transaction_payer_result::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_transaction_payer_result::release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_transaction_payer_result.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_transaction_payer_result::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_transaction_payer_result.value)
}

// -------------------------------------------------------------------

// get_account_rc_arguments

// bytes account = 1;
inline void get_account_rc_arguments::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& get_account_rc_arguments::account() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_account_rc_arguments.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_account_rc_arguments::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_account_rc_arguments.account)
}
inline std::string* get_account_rc_arguments::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_account_rc_arguments.account)
  return _s;
}
inline const std::string& get_account_rc_arguments::_internal_account() const {
  return account_.Get();
}
inline void get_account_rc_arguments::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_account_rc_arguments::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_account_rc_arguments::release_account() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_account_rc_arguments.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_account_rc_arguments::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_account_rc_arguments.account)
}

// -------------------------------------------------------------------

// get_account_rc_result

// uint64 value = 1 [jstype = JS_STRING];
inline void get_account_rc_result::clear_value() {
  value_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 get_account_rc_result::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 get_account_rc_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_account_rc_result.value)
  return _internal_value();
}
inline void get_account_rc_result::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  value_ = value;
}
inline void get_account_rc_result::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.get_account_rc_result.value)
}

// -------------------------------------------------------------------

// consume_account_rc_arguments

// bytes account = 1;
inline void consume_account_rc_arguments::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& consume_account_rc_arguments::account() const {
  // @@protoc_insertion_point(field_get:koinos.chain.consume_account_rc_arguments.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void consume_account_rc_arguments::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.consume_account_rc_arguments.account)
}
inline std::string* consume_account_rc_arguments::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:koinos.chain.consume_account_rc_arguments.account)
  return _s;
}
inline const std::string& consume_account_rc_arguments::_internal_account() const {
  return account_.Get();
}
inline void consume_account_rc_arguments::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* consume_account_rc_arguments::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* consume_account_rc_arguments::release_account() {
  // @@protoc_insertion_point(field_release:koinos.chain.consume_account_rc_arguments.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void consume_account_rc_arguments::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.consume_account_rc_arguments.account)
}

// uint64 value = 2 [jstype = JS_STRING];
inline void consume_account_rc_arguments::clear_value() {
  value_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 consume_account_rc_arguments::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 consume_account_rc_arguments::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.consume_account_rc_arguments.value)
  return _internal_value();
}
inline void consume_account_rc_arguments::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  value_ = value;
}
inline void consume_account_rc_arguments::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.consume_account_rc_arguments.value)
}

// -------------------------------------------------------------------

// consume_account_rc_result

// bool value = 1;
inline void consume_account_rc_result::clear_value() {
  value_ = false;
}
inline bool consume_account_rc_result::_internal_value() const {
  return value_;
}
inline bool consume_account_rc_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.consume_account_rc_result.value)
  return _internal_value();
}
inline void consume_account_rc_result::_internal_set_value(bool value) {
  
  value_ = value;
}
inline void consume_account_rc_result::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.consume_account_rc_result.value)
}

// -------------------------------------------------------------------

// get_resource_limits_arguments

// -------------------------------------------------------------------

// get_resource_limits_result

// .koinos.chain.resource_limit_data value = 1;
inline bool get_resource_limits_result::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool get_resource_limits_result::has_value() const {
  return _internal_has_value();
}
inline void get_resource_limits_result::clear_value() {
  if (GetArenaForAllocation() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::koinos::chain::resource_limit_data& get_resource_limits_result::_internal_value() const {
  const ::koinos::chain::resource_limit_data* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::resource_limit_data&>(
      ::koinos::chain::_resource_limit_data_default_instance_);
}
inline const ::koinos::chain::resource_limit_data& get_resource_limits_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_resource_limits_result.value)
  return _internal_value();
}
inline void get_resource_limits_result::unsafe_arena_set_allocated_value(
    ::koinos::chain::resource_limit_data* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_resource_limits_result.value)
}
inline ::koinos::chain::resource_limit_data* get_resource_limits_result::release_value() {
  
  ::koinos::chain::resource_limit_data* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::resource_limit_data* get_resource_limits_result::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_resource_limits_result.value)
  
  ::koinos::chain::resource_limit_data* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::koinos::chain::resource_limit_data* get_resource_limits_result::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::resource_limit_data>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::koinos::chain::resource_limit_data* get_resource_limits_result::mutable_value() {
  ::koinos::chain::resource_limit_data* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_resource_limits_result.value)
  return _msg;
}
inline void get_resource_limits_result::set_allocated_value(::koinos::chain::resource_limit_data* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::koinos::chain::resource_limit_data>::GetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_resource_limits_result.value)
}

// -------------------------------------------------------------------

// consume_block_resources_arguments

// uint64 disk_storage_consumed = 1 [jstype = JS_STRING];
inline void consume_block_resources_arguments::clear_disk_storage_consumed() {
  disk_storage_consumed_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 consume_block_resources_arguments::_internal_disk_storage_consumed() const {
  return disk_storage_consumed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 consume_block_resources_arguments::disk_storage_consumed() const {
  // @@protoc_insertion_point(field_get:koinos.chain.consume_block_resources_arguments.disk_storage_consumed)
  return _internal_disk_storage_consumed();
}
inline void consume_block_resources_arguments::_internal_set_disk_storage_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  disk_storage_consumed_ = value;
}
inline void consume_block_resources_arguments::set_disk_storage_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_disk_storage_consumed(value);
  // @@protoc_insertion_point(field_set:koinos.chain.consume_block_resources_arguments.disk_storage_consumed)
}

// uint64 network_bandwidth_consumed = 2 [jstype = JS_STRING];
inline void consume_block_resources_arguments::clear_network_bandwidth_consumed() {
  network_bandwidth_consumed_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 consume_block_resources_arguments::_internal_network_bandwidth_consumed() const {
  return network_bandwidth_consumed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 consume_block_resources_arguments::network_bandwidth_consumed() const {
  // @@protoc_insertion_point(field_get:koinos.chain.consume_block_resources_arguments.network_bandwidth_consumed)
  return _internal_network_bandwidth_consumed();
}
inline void consume_block_resources_arguments::_internal_set_network_bandwidth_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  network_bandwidth_consumed_ = value;
}
inline void consume_block_resources_arguments::set_network_bandwidth_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_network_bandwidth_consumed(value);
  // @@protoc_insertion_point(field_set:koinos.chain.consume_block_resources_arguments.network_bandwidth_consumed)
}

// uint64 compute_bandwidth_consumed = 3 [jstype = JS_STRING];
inline void consume_block_resources_arguments::clear_compute_bandwidth_consumed() {
  compute_bandwidth_consumed_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 consume_block_resources_arguments::_internal_compute_bandwidth_consumed() const {
  return compute_bandwidth_consumed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 consume_block_resources_arguments::compute_bandwidth_consumed() const {
  // @@protoc_insertion_point(field_get:koinos.chain.consume_block_resources_arguments.compute_bandwidth_consumed)
  return _internal_compute_bandwidth_consumed();
}
inline void consume_block_resources_arguments::_internal_set_compute_bandwidth_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  compute_bandwidth_consumed_ = value;
}
inline void consume_block_resources_arguments::set_compute_bandwidth_consumed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_compute_bandwidth_consumed(value);
  // @@protoc_insertion_point(field_set:koinos.chain.consume_block_resources_arguments.compute_bandwidth_consumed)
}

// -------------------------------------------------------------------

// consume_block_resources_result

// bool value = 1;
inline void consume_block_resources_result::clear_value() {
  value_ = false;
}
inline bool consume_block_resources_result::_internal_value() const {
  return value_;
}
inline bool consume_block_resources_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.consume_block_resources_result.value)
  return _internal_value();
}
inline void consume_block_resources_result::_internal_set_value(bool value) {
  
  value_ = value;
}
inline void consume_block_resources_result::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.consume_block_resources_result.value)
}

// -------------------------------------------------------------------

// get_transaction_rc_limit_arguments

// .koinos.protocol.transaction transaction = 1;
inline bool get_transaction_rc_limit_arguments::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool get_transaction_rc_limit_arguments::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::koinos::protocol::transaction& get_transaction_rc_limit_arguments::_internal_transaction() const {
  const ::koinos::protocol::transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::protocol::transaction&>(
      ::koinos::protocol::_transaction_default_instance_);
}
inline const ::koinos::protocol::transaction& get_transaction_rc_limit_arguments::transaction() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_transaction_rc_limit_arguments.transaction)
  return _internal_transaction();
}
inline void get_transaction_rc_limit_arguments::unsafe_arena_set_allocated_transaction(
    ::koinos::protocol::transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_transaction_rc_limit_arguments.transaction)
}
inline ::koinos::protocol::transaction* get_transaction_rc_limit_arguments::release_transaction() {
  
  ::koinos::protocol::transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::protocol::transaction* get_transaction_rc_limit_arguments::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_transaction_rc_limit_arguments.transaction)
  
  ::koinos::protocol::transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::koinos::protocol::transaction* get_transaction_rc_limit_arguments::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::protocol::transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::koinos::protocol::transaction* get_transaction_rc_limit_arguments::mutable_transaction() {
  ::koinos::protocol::transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_transaction_rc_limit_arguments.transaction)
  return _msg;
}
inline void get_transaction_rc_limit_arguments::set_allocated_transaction(::koinos::protocol::transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_transaction_rc_limit_arguments.transaction)
}

// -------------------------------------------------------------------

// get_transaction_rc_limit_result

// uint64 value = 1 [jstype = JS_STRING];
inline void get_transaction_rc_limit_result::clear_value() {
  value_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 get_transaction_rc_limit_result::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 get_transaction_rc_limit_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_transaction_rc_limit_result.value)
  return _internal_value();
}
inline void get_transaction_rc_limit_result::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  value_ = value;
}
inline void get_transaction_rc_limit_result::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.get_transaction_rc_limit_result.value)
}

// -------------------------------------------------------------------

// get_last_irreversible_block_arguments

// -------------------------------------------------------------------

// get_last_irreversible_block_result

// uint64 value = 1 [jstype = JS_STRING];
inline void get_last_irreversible_block_result::clear_value() {
  value_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 get_last_irreversible_block_result::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 get_last_irreversible_block_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_last_irreversible_block_result.value)
  return _internal_value();
}
inline void get_last_irreversible_block_result::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  value_ = value;
}
inline void get_last_irreversible_block_result::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.get_last_irreversible_block_result.value)
}

// -------------------------------------------------------------------

// get_caller_arguments

// -------------------------------------------------------------------

// get_caller_result

// .koinos.chain.caller_data value = 1;
inline bool get_caller_result::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool get_caller_result::has_value() const {
  return _internal_has_value();
}
inline void get_caller_result::clear_value() {
  if (GetArenaForAllocation() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::koinos::chain::caller_data& get_caller_result::_internal_value() const {
  const ::koinos::chain::caller_data* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::caller_data&>(
      ::koinos::chain::_caller_data_default_instance_);
}
inline const ::koinos::chain::caller_data& get_caller_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_caller_result.value)
  return _internal_value();
}
inline void get_caller_result::unsafe_arena_set_allocated_value(
    ::koinos::chain::caller_data* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.get_caller_result.value)
}
inline ::koinos::chain::caller_data* get_caller_result::release_value() {
  
  ::koinos::chain::caller_data* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::caller_data* get_caller_result::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_caller_result.value)
  
  ::koinos::chain::caller_data* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::koinos::chain::caller_data* get_caller_result::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::caller_data>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::koinos::chain::caller_data* get_caller_result::mutable_value() {
  ::koinos::chain::caller_data* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_caller_result.value)
  return _msg;
}
inline void get_caller_result::set_allocated_value(::koinos::chain::caller_data* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::koinos::chain::caller_data>::GetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_caller_result.value)
}

// -------------------------------------------------------------------

// require_authority_arguments

// bytes account = 1;
inline void require_authority_arguments::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& require_authority_arguments::account() const {
  // @@protoc_insertion_point(field_get:koinos.chain.require_authority_arguments.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void require_authority_arguments::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.require_authority_arguments.account)
}
inline std::string* require_authority_arguments::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:koinos.chain.require_authority_arguments.account)
  return _s;
}
inline const std::string& require_authority_arguments::_internal_account() const {
  return account_.Get();
}
inline void require_authority_arguments::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* require_authority_arguments::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* require_authority_arguments::release_account() {
  // @@protoc_insertion_point(field_release:koinos.chain.require_authority_arguments.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void require_authority_arguments::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.require_authority_arguments.account)
}

// -------------------------------------------------------------------

// require_authority_result

// -------------------------------------------------------------------

// get_transaction_signature_arguments

// -------------------------------------------------------------------

// get_transaction_signature_result

// bytes value = 1;
inline void get_transaction_signature_result::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& get_transaction_signature_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_transaction_signature_result.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_transaction_signature_result::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_transaction_signature_result.value)
}
inline std::string* get_transaction_signature_result::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_transaction_signature_result.value)
  return _s;
}
inline const std::string& get_transaction_signature_result::_internal_value() const {
  return value_.Get();
}
inline void get_transaction_signature_result::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_transaction_signature_result::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_transaction_signature_result::release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_transaction_signature_result.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_transaction_signature_result::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_transaction_signature_result.value)
}

// -------------------------------------------------------------------

// get_contract_id_arguments

// -------------------------------------------------------------------

// get_contract_id_result

// bytes value = 1;
inline void get_contract_id_result::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& get_contract_id_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_contract_id_result.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_contract_id_result::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_contract_id_result.value)
}
inline std::string* get_contract_id_result::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_contract_id_result.value)
  return _s;
}
inline const std::string& get_contract_id_result::_internal_value() const {
  return value_.Get();
}
inline void get_contract_id_result::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_contract_id_result::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_contract_id_result::release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_contract_id_result.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_contract_id_result::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_contract_id_result.value)
}

// -------------------------------------------------------------------

// get_account_nonce_arguments

// bytes account = 1;
inline void get_account_nonce_arguments::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& get_account_nonce_arguments::account() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_account_nonce_arguments.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void get_account_nonce_arguments::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.get_account_nonce_arguments.account)
}
inline std::string* get_account_nonce_arguments::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:koinos.chain.get_account_nonce_arguments.account)
  return _s;
}
inline const std::string& get_account_nonce_arguments::_internal_account() const {
  return account_.Get();
}
inline void get_account_nonce_arguments::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* get_account_nonce_arguments::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* get_account_nonce_arguments::release_account() {
  // @@protoc_insertion_point(field_release:koinos.chain.get_account_nonce_arguments.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void get_account_nonce_arguments::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.get_account_nonce_arguments.account)
}

// -------------------------------------------------------------------

// get_account_nonce_result

// uint64 value = 1 [jstype = JS_STRING];
inline void get_account_nonce_result::clear_value() {
  value_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 get_account_nonce_result::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 get_account_nonce_result::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.get_account_nonce_result.value)
  return _internal_value();
}
inline void get_account_nonce_result::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  value_ = value;
}
inline void get_account_nonce_result::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.get_account_nonce_result.value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chain
}  // namespace koinos

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::koinos::chain::privilege> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::koinos::chain::privilege>() {
  return ::koinos::chain::privilege_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_koinos_2fchain_2fchain_2eproto
