// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: koinos/chain/chain.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_koinos_2fchain_2fchain_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_koinos_2fchain_2fchain_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "koinos/options.pb.h"
#include "koinos/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_koinos_2fchain_2fchain_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_koinos_2fchain_2fchain_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_koinos_2fchain_2fchain_2eproto;
namespace koinos {
namespace chain {
class argument_data;
struct argument_dataDefaultTypeInternal;
extern argument_dataDefaultTypeInternal _argument_data_default_instance_;
class caller_data;
struct caller_dataDefaultTypeInternal;
extern caller_dataDefaultTypeInternal _caller_data_default_instance_;
class compute_bandwidth_entry;
struct compute_bandwidth_entryDefaultTypeInternal;
extern compute_bandwidth_entryDefaultTypeInternal _compute_bandwidth_entry_default_instance_;
class compute_bandwidth_registry;
struct compute_bandwidth_registryDefaultTypeInternal;
extern compute_bandwidth_registryDefaultTypeInternal _compute_bandwidth_registry_default_instance_;
class contract_metadata_object;
struct contract_metadata_objectDefaultTypeInternal;
extern contract_metadata_objectDefaultTypeInternal _contract_metadata_object_default_instance_;
class database_key;
struct database_keyDefaultTypeInternal;
extern database_keyDefaultTypeInternal _database_key_default_instance_;
class error_data;
struct error_dataDefaultTypeInternal;
extern error_dataDefaultTypeInternal _error_data_default_instance_;
class genesis_data;
struct genesis_dataDefaultTypeInternal;
extern genesis_dataDefaultTypeInternal _genesis_data_default_instance_;
class genesis_entry;
struct genesis_entryDefaultTypeInternal;
extern genesis_entryDefaultTypeInternal _genesis_entry_default_instance_;
class head_info;
struct head_infoDefaultTypeInternal;
extern head_infoDefaultTypeInternal _head_info_default_instance_;
class max_account_resources;
struct max_account_resourcesDefaultTypeInternal;
extern max_account_resourcesDefaultTypeInternal _max_account_resources_default_instance_;
class object_space;
struct object_spaceDefaultTypeInternal;
extern object_spaceDefaultTypeInternal _object_space_default_instance_;
class resource_limit_data;
struct resource_limit_dataDefaultTypeInternal;
extern resource_limit_dataDefaultTypeInternal _resource_limit_data_default_instance_;
class result;
struct resultDefaultTypeInternal;
extern resultDefaultTypeInternal _result_default_instance_;
}  // namespace chain
}  // namespace koinos
PROTOBUF_NAMESPACE_OPEN
template<> ::koinos::chain::argument_data* Arena::CreateMaybeMessage<::koinos::chain::argument_data>(Arena*);
template<> ::koinos::chain::caller_data* Arena::CreateMaybeMessage<::koinos::chain::caller_data>(Arena*);
template<> ::koinos::chain::compute_bandwidth_entry* Arena::CreateMaybeMessage<::koinos::chain::compute_bandwidth_entry>(Arena*);
template<> ::koinos::chain::compute_bandwidth_registry* Arena::CreateMaybeMessage<::koinos::chain::compute_bandwidth_registry>(Arena*);
template<> ::koinos::chain::contract_metadata_object* Arena::CreateMaybeMessage<::koinos::chain::contract_metadata_object>(Arena*);
template<> ::koinos::chain::database_key* Arena::CreateMaybeMessage<::koinos::chain::database_key>(Arena*);
template<> ::koinos::chain::error_data* Arena::CreateMaybeMessage<::koinos::chain::error_data>(Arena*);
template<> ::koinos::chain::genesis_data* Arena::CreateMaybeMessage<::koinos::chain::genesis_data>(Arena*);
template<> ::koinos::chain::genesis_entry* Arena::CreateMaybeMessage<::koinos::chain::genesis_entry>(Arena*);
template<> ::koinos::chain::head_info* Arena::CreateMaybeMessage<::koinos::chain::head_info>(Arena*);
template<> ::koinos::chain::max_account_resources* Arena::CreateMaybeMessage<::koinos::chain::max_account_resources>(Arena*);
template<> ::koinos::chain::object_space* Arena::CreateMaybeMessage<::koinos::chain::object_space>(Arena*);
template<> ::koinos::chain::resource_limit_data* Arena::CreateMaybeMessage<::koinos::chain::resource_limit_data>(Arena*);
template<> ::koinos::chain::result* Arena::CreateMaybeMessage<::koinos::chain::result>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace koinos {
namespace chain {

enum privilege : int {
  kernel_mode = 0,
  user_mode = 1,
  privilege_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  privilege_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool privilege_IsValid(int value);
constexpr privilege privilege_MIN = kernel_mode;
constexpr privilege privilege_MAX = user_mode;
constexpr int privilege_ARRAYSIZE = privilege_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* privilege_descriptor();
template<typename T>
inline const std::string& privilege_Name(T enum_t_value) {
  static_assert(::std::is_same<T, privilege>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function privilege_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    privilege_descriptor(), enum_t_value);
}
inline bool privilege_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, privilege* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<privilege>(
    privilege_descriptor(), name, value);
}
enum dsa : int {
  ecdsa_secp256k1 = 0,
  dsa_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  dsa_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool dsa_IsValid(int value);
constexpr dsa dsa_MIN = ecdsa_secp256k1;
constexpr dsa dsa_MAX = ecdsa_secp256k1;
constexpr int dsa_ARRAYSIZE = dsa_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* dsa_descriptor();
template<typename T>
inline const std::string& dsa_Name(T enum_t_value) {
  static_assert(::std::is_same<T, dsa>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function dsa_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    dsa_descriptor(), enum_t_value);
}
inline bool dsa_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, dsa* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<dsa>(
    dsa_descriptor(), name, value);
}
// ===================================================================

class error_data final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.error_data) */ {
 public:
  inline error_data() : error_data(nullptr) {}
  ~error_data() override;
  explicit constexpr error_data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  error_data(const error_data& from);
  error_data(error_data&& from) noexcept
    : error_data() {
    *this = ::std::move(from);
  }

  inline error_data& operator=(const error_data& from) {
    CopyFrom(from);
    return *this;
  }
  inline error_data& operator=(error_data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const error_data& default_instance() {
    return *internal_default_instance();
  }
  static inline const error_data* internal_default_instance() {
    return reinterpret_cast<const error_data*>(
               &_error_data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(error_data& a, error_data& b) {
    a.Swap(&b);
  }
  inline void Swap(error_data* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(error_data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline error_data* New() const final {
    return new error_data();
  }

  error_data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<error_data>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const error_data& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const error_data& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(error_data* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.error_data";
  }
  protected:
  explicit error_data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.error_data)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.result) */ {
 public:
  inline result() : result(nullptr) {}
  ~result() override;
  explicit constexpr result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  result(const result& from);
  result(result&& from) noexcept
    : result() {
    *this = ::std::move(from);
  }

  inline result& operator=(const result& from) {
    CopyFrom(from);
    return *this;
  }
  inline result& operator=(result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const result& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kObject = 1,
    kError = 2,
    VALUE_NOT_SET = 0,
  };

  static inline const result* internal_default_instance() {
    return reinterpret_cast<const result*>(
               &_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(result& a, result& b) {
    a.Swap(&b);
  }
  inline void Swap(result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline result* New() const final {
    return new result();
  }

  result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.result";
  }
  protected:
  explicit result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // bytes object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const std::string& object() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_object(ArgT0&& arg0, ArgT... args);
  std::string* mutable_object();
  PROTOBUF_MUST_USE_RESULT std::string* release_object();
  void set_allocated_object(std::string* object);
  private:
  const std::string& _internal_object() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object(const std::string& value);
  std::string* _internal_mutable_object();
  public:

  // .koinos.chain.error_data error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::koinos::chain::error_data& error() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::error_data* release_error();
  ::koinos::chain::error_data* mutable_error();
  void set_allocated_error(::koinos::chain::error_data* error);
  private:
  const ::koinos::chain::error_data& _internal_error() const;
  ::koinos::chain::error_data* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::koinos::chain::error_data* error);
  ::koinos::chain::error_data* unsafe_arena_release_error();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:koinos.chain.result)
 private:
  class _Internal;
  void set_has_object();
  void set_has_error();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_;
    ::koinos::chain::error_data* error_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class object_space final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.object_space) */ {
 public:
  inline object_space() : object_space(nullptr) {}
  ~object_space() override;
  explicit constexpr object_space(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  object_space(const object_space& from);
  object_space(object_space&& from) noexcept
    : object_space() {
    *this = ::std::move(from);
  }

  inline object_space& operator=(const object_space& from) {
    CopyFrom(from);
    return *this;
  }
  inline object_space& operator=(object_space&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const object_space& default_instance() {
    return *internal_default_instance();
  }
  static inline const object_space* internal_default_instance() {
    return reinterpret_cast<const object_space*>(
               &_object_space_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(object_space& a, object_space& b) {
    a.Swap(&b);
  }
  inline void Swap(object_space* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(object_space* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline object_space* New() const final {
    return new object_space();
  }

  object_space* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<object_space>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const object_space& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const object_space& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(object_space* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.object_space";
  }
  protected:
  explicit object_space(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZoneFieldNumber = 2,
    kSystemFieldNumber = 1,
    kIdFieldNumber = 3,
  };
  // bytes zone = 2;
  void clear_zone();
  const std::string& zone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_zone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_zone();
  PROTOBUF_MUST_USE_RESULT std::string* release_zone();
  void set_allocated_zone(std::string* zone);
  private:
  const std::string& _internal_zone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_zone(const std::string& value);
  std::string* _internal_mutable_zone();
  public:

  // bool system = 1;
  void clear_system();
  bool system() const;
  void set_system(bool value);
  private:
  bool _internal_system() const;
  void _internal_set_system(bool value);
  public:

  // uint32 id = 3;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.object_space)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr zone_;
  bool system_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class database_key final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.database_key) */ {
 public:
  inline database_key() : database_key(nullptr) {}
  ~database_key() override;
  explicit constexpr database_key(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  database_key(const database_key& from);
  database_key(database_key&& from) noexcept
    : database_key() {
    *this = ::std::move(from);
  }

  inline database_key& operator=(const database_key& from) {
    CopyFrom(from);
    return *this;
  }
  inline database_key& operator=(database_key&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const database_key& default_instance() {
    return *internal_default_instance();
  }
  static inline const database_key* internal_default_instance() {
    return reinterpret_cast<const database_key*>(
               &_database_key_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(database_key& a, database_key& b) {
    a.Swap(&b);
  }
  inline void Swap(database_key* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(database_key* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline database_key* New() const final {
    return new database_key();
  }

  database_key* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<database_key>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const database_key& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const database_key& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(database_key* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.database_key";
  }
  protected:
  explicit database_key(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kSpaceFieldNumber = 1,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .koinos.chain.object_space space = 1;
  bool has_space() const;
  private:
  bool _internal_has_space() const;
  public:
  void clear_space();
  const ::koinos::chain::object_space& space() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::object_space* release_space();
  ::koinos::chain::object_space* mutable_space();
  void set_allocated_space(::koinos::chain::object_space* space);
  private:
  const ::koinos::chain::object_space& _internal_space() const;
  ::koinos::chain::object_space* _internal_mutable_space();
  public:
  void unsafe_arena_set_allocated_space(
      ::koinos::chain::object_space* space);
  ::koinos::chain::object_space* unsafe_arena_release_space();

  // @@protoc_insertion_point(class_scope:koinos.chain.database_key)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::koinos::chain::object_space* space_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class max_account_resources final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.max_account_resources) */ {
 public:
  inline max_account_resources() : max_account_resources(nullptr) {}
  ~max_account_resources() override;
  explicit constexpr max_account_resources(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  max_account_resources(const max_account_resources& from);
  max_account_resources(max_account_resources&& from) noexcept
    : max_account_resources() {
    *this = ::std::move(from);
  }

  inline max_account_resources& operator=(const max_account_resources& from) {
    CopyFrom(from);
    return *this;
  }
  inline max_account_resources& operator=(max_account_resources&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const max_account_resources& default_instance() {
    return *internal_default_instance();
  }
  static inline const max_account_resources* internal_default_instance() {
    return reinterpret_cast<const max_account_resources*>(
               &_max_account_resources_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(max_account_resources& a, max_account_resources& b) {
    a.Swap(&b);
  }
  inline void Swap(max_account_resources* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(max_account_resources* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline max_account_resources* New() const final {
    return new max_account_resources();
  }

  max_account_resources* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<max_account_resources>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const max_account_resources& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const max_account_resources& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(max_account_resources* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.max_account_resources";
  }
  protected:
  explicit max_account_resources(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint64 value = 1 [jstype = JS_STRING];
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.max_account_resources)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class head_info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.head_info) */ {
 public:
  inline head_info() : head_info(nullptr) {}
  ~head_info() override;
  explicit constexpr head_info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  head_info(const head_info& from);
  head_info(head_info&& from) noexcept
    : head_info() {
    *this = ::std::move(from);
  }

  inline head_info& operator=(const head_info& from) {
    CopyFrom(from);
    return *this;
  }
  inline head_info& operator=(head_info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const head_info& default_instance() {
    return *internal_default_instance();
  }
  static inline const head_info* internal_default_instance() {
    return reinterpret_cast<const head_info*>(
               &_head_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(head_info& a, head_info& b) {
    a.Swap(&b);
  }
  inline void Swap(head_info* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(head_info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline head_info* New() const final {
    return new head_info();
  }

  head_info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<head_info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const head_info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const head_info& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(head_info* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.head_info";
  }
  protected:
  explicit head_info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadTopologyFieldNumber = 1,
    kHeadBlockTimeFieldNumber = 2,
    kLastIrreversibleBlockFieldNumber = 3,
  };
  // .koinos.block_topology head_topology = 1;
  bool has_head_topology() const;
  private:
  bool _internal_has_head_topology() const;
  public:
  void clear_head_topology();
  const ::koinos::block_topology& head_topology() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::block_topology* release_head_topology();
  ::koinos::block_topology* mutable_head_topology();
  void set_allocated_head_topology(::koinos::block_topology* head_topology);
  private:
  const ::koinos::block_topology& _internal_head_topology() const;
  ::koinos::block_topology* _internal_mutable_head_topology();
  public:
  void unsafe_arena_set_allocated_head_topology(
      ::koinos::block_topology* head_topology);
  ::koinos::block_topology* unsafe_arena_release_head_topology();

  // uint64 head_block_time = 2 [jstype = JS_STRING];
  void clear_head_block_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 head_block_time() const;
  void set_head_block_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_head_block_time() const;
  void _internal_set_head_block_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 last_irreversible_block = 3 [jstype = JS_STRING];
  void clear_last_irreversible_block();
  ::PROTOBUF_NAMESPACE_ID::uint64 last_irreversible_block() const;
  void set_last_irreversible_block(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_last_irreversible_block() const;
  void _internal_set_last_irreversible_block(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.head_info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::koinos::block_topology* head_topology_;
  ::PROTOBUF_NAMESPACE_ID::uint64 head_block_time_;
  ::PROTOBUF_NAMESPACE_ID::uint64 last_irreversible_block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class caller_data final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.caller_data) */ {
 public:
  inline caller_data() : caller_data(nullptr) {}
  ~caller_data() override;
  explicit constexpr caller_data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  caller_data(const caller_data& from);
  caller_data(caller_data&& from) noexcept
    : caller_data() {
    *this = ::std::move(from);
  }

  inline caller_data& operator=(const caller_data& from) {
    CopyFrom(from);
    return *this;
  }
  inline caller_data& operator=(caller_data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const caller_data& default_instance() {
    return *internal_default_instance();
  }
  static inline const caller_data* internal_default_instance() {
    return reinterpret_cast<const caller_data*>(
               &_caller_data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(caller_data& a, caller_data& b) {
    a.Swap(&b);
  }
  inline void Swap(caller_data* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(caller_data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline caller_data* New() const final {
    return new caller_data();
  }

  caller_data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<caller_data>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const caller_data& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const caller_data& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(caller_data* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.caller_data";
  }
  protected:
  explicit caller_data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallerFieldNumber = 1,
    kCallerPrivilegeFieldNumber = 2,
  };
  // bytes caller = 1 [(.koinos.btype) = ADDRESS];
  void clear_caller();
  const std::string& caller() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caller(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caller();
  PROTOBUF_MUST_USE_RESULT std::string* release_caller();
  void set_allocated_caller(std::string* caller);
  private:
  const std::string& _internal_caller() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caller(const std::string& value);
  std::string* _internal_mutable_caller();
  public:

  // .koinos.chain.privilege caller_privilege = 2;
  void clear_caller_privilege();
  ::koinos::chain::privilege caller_privilege() const;
  void set_caller_privilege(::koinos::chain::privilege value);
  private:
  ::koinos::chain::privilege _internal_caller_privilege() const;
  void _internal_set_caller_privilege(::koinos::chain::privilege value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.caller_data)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caller_;
  int caller_privilege_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class argument_data final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.argument_data) */ {
 public:
  inline argument_data() : argument_data(nullptr) {}
  ~argument_data() override;
  explicit constexpr argument_data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  argument_data(const argument_data& from);
  argument_data(argument_data&& from) noexcept
    : argument_data() {
    *this = ::std::move(from);
  }

  inline argument_data& operator=(const argument_data& from) {
    CopyFrom(from);
    return *this;
  }
  inline argument_data& operator=(argument_data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const argument_data& default_instance() {
    return *internal_default_instance();
  }
  static inline const argument_data* internal_default_instance() {
    return reinterpret_cast<const argument_data*>(
               &_argument_data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(argument_data& a, argument_data& b) {
    a.Swap(&b);
  }
  inline void Swap(argument_data* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(argument_data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline argument_data* New() const final {
    return new argument_data();
  }

  argument_data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<argument_data>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const argument_data& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const argument_data& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(argument_data* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.argument_data";
  }
  protected:
  explicit argument_data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgumentsFieldNumber = 2,
    kEntryPointFieldNumber = 1,
  };
  // bytes arguments = 2;
  void clear_arguments();
  const std::string& arguments() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arguments(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arguments();
  PROTOBUF_MUST_USE_RESULT std::string* release_arguments();
  void set_allocated_arguments(std::string* arguments);
  private:
  const std::string& _internal_arguments() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arguments(const std::string& value);
  std::string* _internal_mutable_arguments();
  public:

  // uint32 entry_point = 1;
  void clear_entry_point();
  ::PROTOBUF_NAMESPACE_ID::uint32 entry_point() const;
  void set_entry_point(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_entry_point() const;
  void _internal_set_entry_point(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.argument_data)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arguments_;
  ::PROTOBUF_NAMESPACE_ID::uint32 entry_point_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class resource_limit_data final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.resource_limit_data) */ {
 public:
  inline resource_limit_data() : resource_limit_data(nullptr) {}
  ~resource_limit_data() override;
  explicit constexpr resource_limit_data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resource_limit_data(const resource_limit_data& from);
  resource_limit_data(resource_limit_data&& from) noexcept
    : resource_limit_data() {
    *this = ::std::move(from);
  }

  inline resource_limit_data& operator=(const resource_limit_data& from) {
    CopyFrom(from);
    return *this;
  }
  inline resource_limit_data& operator=(resource_limit_data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resource_limit_data& default_instance() {
    return *internal_default_instance();
  }
  static inline const resource_limit_data* internal_default_instance() {
    return reinterpret_cast<const resource_limit_data*>(
               &_resource_limit_data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(resource_limit_data& a, resource_limit_data& b) {
    a.Swap(&b);
  }
  inline void Swap(resource_limit_data* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resource_limit_data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline resource_limit_data* New() const final {
    return new resource_limit_data();
  }

  resource_limit_data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<resource_limit_data>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const resource_limit_data& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const resource_limit_data& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(resource_limit_data* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.resource_limit_data";
  }
  protected:
  explicit resource_limit_data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiskStorageLimitFieldNumber = 1,
    kDiskStorageCostFieldNumber = 2,
    kNetworkBandwidthLimitFieldNumber = 3,
    kNetworkBandwidthCostFieldNumber = 4,
    kComputeBandwidthLimitFieldNumber = 5,
    kComputeBandwidthCostFieldNumber = 6,
  };
  // uint64 disk_storage_limit = 1 [jstype = JS_STRING];
  void clear_disk_storage_limit();
  ::PROTOBUF_NAMESPACE_ID::uint64 disk_storage_limit() const;
  void set_disk_storage_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_disk_storage_limit() const;
  void _internal_set_disk_storage_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 disk_storage_cost = 2 [jstype = JS_STRING];
  void clear_disk_storage_cost();
  ::PROTOBUF_NAMESPACE_ID::uint64 disk_storage_cost() const;
  void set_disk_storage_cost(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_disk_storage_cost() const;
  void _internal_set_disk_storage_cost(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 network_bandwidth_limit = 3 [jstype = JS_STRING];
  void clear_network_bandwidth_limit();
  ::PROTOBUF_NAMESPACE_ID::uint64 network_bandwidth_limit() const;
  void set_network_bandwidth_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_network_bandwidth_limit() const;
  void _internal_set_network_bandwidth_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 network_bandwidth_cost = 4 [jstype = JS_STRING];
  void clear_network_bandwidth_cost();
  ::PROTOBUF_NAMESPACE_ID::uint64 network_bandwidth_cost() const;
  void set_network_bandwidth_cost(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_network_bandwidth_cost() const;
  void _internal_set_network_bandwidth_cost(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 compute_bandwidth_limit = 5 [jstype = JS_STRING];
  void clear_compute_bandwidth_limit();
  ::PROTOBUF_NAMESPACE_ID::uint64 compute_bandwidth_limit() const;
  void set_compute_bandwidth_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_compute_bandwidth_limit() const;
  void _internal_set_compute_bandwidth_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 compute_bandwidth_cost = 6 [jstype = JS_STRING];
  void clear_compute_bandwidth_cost();
  ::PROTOBUF_NAMESPACE_ID::uint64 compute_bandwidth_cost() const;
  void set_compute_bandwidth_cost(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_compute_bandwidth_cost() const;
  void _internal_set_compute_bandwidth_cost(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.resource_limit_data)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 disk_storage_limit_;
  ::PROTOBUF_NAMESPACE_ID::uint64 disk_storage_cost_;
  ::PROTOBUF_NAMESPACE_ID::uint64 network_bandwidth_limit_;
  ::PROTOBUF_NAMESPACE_ID::uint64 network_bandwidth_cost_;
  ::PROTOBUF_NAMESPACE_ID::uint64 compute_bandwidth_limit_;
  ::PROTOBUF_NAMESPACE_ID::uint64 compute_bandwidth_cost_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class contract_metadata_object final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.contract_metadata_object) */ {
 public:
  inline contract_metadata_object() : contract_metadata_object(nullptr) {}
  ~contract_metadata_object() override;
  explicit constexpr contract_metadata_object(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  contract_metadata_object(const contract_metadata_object& from);
  contract_metadata_object(contract_metadata_object&& from) noexcept
    : contract_metadata_object() {
    *this = ::std::move(from);
  }

  inline contract_metadata_object& operator=(const contract_metadata_object& from) {
    CopyFrom(from);
    return *this;
  }
  inline contract_metadata_object& operator=(contract_metadata_object&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const contract_metadata_object& default_instance() {
    return *internal_default_instance();
  }
  static inline const contract_metadata_object* internal_default_instance() {
    return reinterpret_cast<const contract_metadata_object*>(
               &_contract_metadata_object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(contract_metadata_object& a, contract_metadata_object& b) {
    a.Swap(&b);
  }
  inline void Swap(contract_metadata_object* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(contract_metadata_object* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline contract_metadata_object* New() const final {
    return new contract_metadata_object();
  }

  contract_metadata_object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<contract_metadata_object>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const contract_metadata_object& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const contract_metadata_object& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(contract_metadata_object* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.contract_metadata_object";
  }
  protected:
  explicit contract_metadata_object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
    kSystemFieldNumber = 2,
    kAuthorizesCallContractFieldNumber = 3,
    kAuthorizesTransactionApplicationFieldNumber = 4,
    kAuthorizesUploadContractFieldNumber = 5,
  };
  // bytes hash = 1;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_MUST_USE_RESULT std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // bool system = 2;
  void clear_system();
  bool system() const;
  void set_system(bool value);
  private:
  bool _internal_system() const;
  void _internal_set_system(bool value);
  public:

  // bool authorizes_call_contract = 3;
  void clear_authorizes_call_contract();
  bool authorizes_call_contract() const;
  void set_authorizes_call_contract(bool value);
  private:
  bool _internal_authorizes_call_contract() const;
  void _internal_set_authorizes_call_contract(bool value);
  public:

  // bool authorizes_transaction_application = 4;
  void clear_authorizes_transaction_application();
  bool authorizes_transaction_application() const;
  void set_authorizes_transaction_application(bool value);
  private:
  bool _internal_authorizes_transaction_application() const;
  void _internal_set_authorizes_transaction_application(bool value);
  public:

  // bool authorizes_upload_contract = 5;
  void clear_authorizes_upload_contract();
  bool authorizes_upload_contract() const;
  void set_authorizes_upload_contract(bool value);
  private:
  bool _internal_authorizes_upload_contract() const;
  void _internal_set_authorizes_upload_contract(bool value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.contract_metadata_object)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  bool system_;
  bool authorizes_call_contract_;
  bool authorizes_transaction_application_;
  bool authorizes_upload_contract_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class compute_bandwidth_entry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.compute_bandwidth_entry) */ {
 public:
  inline compute_bandwidth_entry() : compute_bandwidth_entry(nullptr) {}
  ~compute_bandwidth_entry() override;
  explicit constexpr compute_bandwidth_entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  compute_bandwidth_entry(const compute_bandwidth_entry& from);
  compute_bandwidth_entry(compute_bandwidth_entry&& from) noexcept
    : compute_bandwidth_entry() {
    *this = ::std::move(from);
  }

  inline compute_bandwidth_entry& operator=(const compute_bandwidth_entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline compute_bandwidth_entry& operator=(compute_bandwidth_entry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const compute_bandwidth_entry& default_instance() {
    return *internal_default_instance();
  }
  static inline const compute_bandwidth_entry* internal_default_instance() {
    return reinterpret_cast<const compute_bandwidth_entry*>(
               &_compute_bandwidth_entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(compute_bandwidth_entry& a, compute_bandwidth_entry& b) {
    a.Swap(&b);
  }
  inline void Swap(compute_bandwidth_entry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(compute_bandwidth_entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline compute_bandwidth_entry* New() const final {
    return new compute_bandwidth_entry();
  }

  compute_bandwidth_entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<compute_bandwidth_entry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const compute_bandwidth_entry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const compute_bandwidth_entry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(compute_bandwidth_entry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.compute_bandwidth_entry";
  }
  protected:
  explicit compute_bandwidth_entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kComputeFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 compute = 2;
  void clear_compute();
  ::PROTOBUF_NAMESPACE_ID::uint64 compute() const;
  void set_compute(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_compute() const;
  void _internal_set_compute(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:koinos.chain.compute_bandwidth_entry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 compute_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class compute_bandwidth_registry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.compute_bandwidth_registry) */ {
 public:
  inline compute_bandwidth_registry() : compute_bandwidth_registry(nullptr) {}
  ~compute_bandwidth_registry() override;
  explicit constexpr compute_bandwidth_registry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  compute_bandwidth_registry(const compute_bandwidth_registry& from);
  compute_bandwidth_registry(compute_bandwidth_registry&& from) noexcept
    : compute_bandwidth_registry() {
    *this = ::std::move(from);
  }

  inline compute_bandwidth_registry& operator=(const compute_bandwidth_registry& from) {
    CopyFrom(from);
    return *this;
  }
  inline compute_bandwidth_registry& operator=(compute_bandwidth_registry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const compute_bandwidth_registry& default_instance() {
    return *internal_default_instance();
  }
  static inline const compute_bandwidth_registry* internal_default_instance() {
    return reinterpret_cast<const compute_bandwidth_registry*>(
               &_compute_bandwidth_registry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(compute_bandwidth_registry& a, compute_bandwidth_registry& b) {
    a.Swap(&b);
  }
  inline void Swap(compute_bandwidth_registry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(compute_bandwidth_registry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline compute_bandwidth_registry* New() const final {
    return new compute_bandwidth_registry();
  }

  compute_bandwidth_registry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<compute_bandwidth_registry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const compute_bandwidth_registry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const compute_bandwidth_registry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(compute_bandwidth_registry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.compute_bandwidth_registry";
  }
  protected:
  explicit compute_bandwidth_registry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .koinos.chain.compute_bandwidth_entry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::koinos::chain::compute_bandwidth_entry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::koinos::chain::compute_bandwidth_entry >*
      mutable_entries();
  private:
  const ::koinos::chain::compute_bandwidth_entry& _internal_entries(int index) const;
  ::koinos::chain::compute_bandwidth_entry* _internal_add_entries();
  public:
  const ::koinos::chain::compute_bandwidth_entry& entries(int index) const;
  ::koinos::chain::compute_bandwidth_entry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::koinos::chain::compute_bandwidth_entry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:koinos.chain.compute_bandwidth_registry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::koinos::chain::compute_bandwidth_entry > entries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class genesis_entry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.genesis_entry) */ {
 public:
  inline genesis_entry() : genesis_entry(nullptr) {}
  ~genesis_entry() override;
  explicit constexpr genesis_entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  genesis_entry(const genesis_entry& from);
  genesis_entry(genesis_entry&& from) noexcept
    : genesis_entry() {
    *this = ::std::move(from);
  }

  inline genesis_entry& operator=(const genesis_entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline genesis_entry& operator=(genesis_entry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const genesis_entry& default_instance() {
    return *internal_default_instance();
  }
  static inline const genesis_entry* internal_default_instance() {
    return reinterpret_cast<const genesis_entry*>(
               &_genesis_entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(genesis_entry& a, genesis_entry& b) {
    a.Swap(&b);
  }
  inline void Swap(genesis_entry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(genesis_entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline genesis_entry* New() const final {
    return new genesis_entry();
  }

  genesis_entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<genesis_entry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const genesis_entry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const genesis_entry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(genesis_entry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.genesis_entry";
  }
  protected:
  explicit genesis_entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kValueFieldNumber = 3,
    kSpaceFieldNumber = 1,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .koinos.chain.object_space space = 1;
  bool has_space() const;
  private:
  bool _internal_has_space() const;
  public:
  void clear_space();
  const ::koinos::chain::object_space& space() const;
  PROTOBUF_MUST_USE_RESULT ::koinos::chain::object_space* release_space();
  ::koinos::chain::object_space* mutable_space();
  void set_allocated_space(::koinos::chain::object_space* space);
  private:
  const ::koinos::chain::object_space& _internal_space() const;
  ::koinos::chain::object_space* _internal_mutable_space();
  public:
  void unsafe_arena_set_allocated_space(
      ::koinos::chain::object_space* space);
  ::koinos::chain::object_space* unsafe_arena_release_space();

  // @@protoc_insertion_point(class_scope:koinos.chain.genesis_entry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::koinos::chain::object_space* space_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// -------------------------------------------------------------------

class genesis_data final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:koinos.chain.genesis_data) */ {
 public:
  inline genesis_data() : genesis_data(nullptr) {}
  ~genesis_data() override;
  explicit constexpr genesis_data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  genesis_data(const genesis_data& from);
  genesis_data(genesis_data&& from) noexcept
    : genesis_data() {
    *this = ::std::move(from);
  }

  inline genesis_data& operator=(const genesis_data& from) {
    CopyFrom(from);
    return *this;
  }
  inline genesis_data& operator=(genesis_data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const genesis_data& default_instance() {
    return *internal_default_instance();
  }
  static inline const genesis_data* internal_default_instance() {
    return reinterpret_cast<const genesis_data*>(
               &_genesis_data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(genesis_data& a, genesis_data& b) {
    a.Swap(&b);
  }
  inline void Swap(genesis_data* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(genesis_data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline genesis_data* New() const final {
    return new genesis_data();
  }

  genesis_data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<genesis_data>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const genesis_data& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const genesis_data& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(genesis_data* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "koinos.chain.genesis_data";
  }
  protected:
  explicit genesis_data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .koinos.chain.genesis_entry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::koinos::chain::genesis_entry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::koinos::chain::genesis_entry >*
      mutable_entries();
  private:
  const ::koinos::chain::genesis_entry& _internal_entries(int index) const;
  ::koinos::chain::genesis_entry* _internal_add_entries();
  public:
  const ::koinos::chain::genesis_entry& entries(int index) const;
  ::koinos::chain::genesis_entry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::koinos::chain::genesis_entry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:koinos.chain.genesis_data)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::koinos::chain::genesis_entry > entries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_koinos_2fchain_2fchain_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// error_data

// string message = 1;
inline void error_data::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& error_data::message() const {
  // @@protoc_insertion_point(field_get:koinos.chain.error_data.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void error_data::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.error_data.message)
}
inline std::string* error_data::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:koinos.chain.error_data.message)
  return _s;
}
inline const std::string& error_data::_internal_message() const {
  return message_.Get();
}
inline void error_data::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* error_data::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* error_data::release_message() {
  // @@protoc_insertion_point(field_release:koinos.chain.error_data.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void error_data::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.error_data.message)
}

// -------------------------------------------------------------------

// result

// bytes object = 1;
inline bool result::_internal_has_object() const {
  return value_case() == kObject;
}
inline bool result::has_object() const {
  return _internal_has_object();
}
inline void result::set_has_object() {
  _oneof_case_[0] = kObject;
}
inline void result::clear_object() {
  if (_internal_has_object()) {
    value_.object_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_value();
  }
}
inline const std::string& result::object() const {
  // @@protoc_insertion_point(field_get:koinos.chain.result.object)
  return _internal_object();
}
template <typename ArgT0, typename... ArgT>
inline void result::set_object(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_object()) {
    clear_value();
    set_has_object();
    value_.object_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.object_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.result.object)
}
inline std::string* result::mutable_object() {
  std::string* _s = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:koinos.chain.result.object)
  return _s;
}
inline const std::string& result::_internal_object() const {
  if (_internal_has_object()) {
    return value_.object_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void result::_internal_set_object(const std::string& value) {
  if (!_internal_has_object()) {
    clear_value();
    set_has_object();
    value_.object_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.object_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* result::_internal_mutable_object() {
  if (!_internal_has_object()) {
    clear_value();
    set_has_object();
    value_.object_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return value_.object_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* result::release_object() {
  // @@protoc_insertion_point(field_release:koinos.chain.result.object)
  if (_internal_has_object()) {
    clear_has_value();
    return value_.object_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void result::set_allocated_object(std::string* object) {
  if (has_value()) {
    clear_value();
  }
  if (object != nullptr) {
    set_has_object();
    value_.object_.UnsafeSetDefault(object);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(object);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.result.object)
}

// .koinos.chain.error_data error = 2;
inline bool result::_internal_has_error() const {
  return value_case() == kError;
}
inline bool result::has_error() const {
  return _internal_has_error();
}
inline void result::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void result::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.error_;
    }
    clear_has_value();
  }
}
inline ::koinos::chain::error_data* result::release_error() {
  // @@protoc_insertion_point(field_release:koinos.chain.result.error)
  if (_internal_has_error()) {
    clear_has_value();
      ::koinos::chain::error_data* temp = value_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::koinos::chain::error_data& result::_internal_error() const {
  return _internal_has_error()
      ? *value_.error_
      : reinterpret_cast< ::koinos::chain::error_data&>(::koinos::chain::_error_data_default_instance_);
}
inline const ::koinos::chain::error_data& result::error() const {
  // @@protoc_insertion_point(field_get:koinos.chain.result.error)
  return _internal_error();
}
inline ::koinos::chain::error_data* result::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:koinos.chain.result.error)
  if (_internal_has_error()) {
    clear_has_value();
    ::koinos::chain::error_data* temp = value_.error_;
    value_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void result::unsafe_arena_set_allocated_error(::koinos::chain::error_data* error) {
  clear_value();
  if (error) {
    set_has_error();
    value_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.result.error)
}
inline ::koinos::chain::error_data* result::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_value();
    set_has_error();
    value_.error_ = CreateMaybeMessage< ::koinos::chain::error_data >(GetArenaForAllocation());
  }
  return value_.error_;
}
inline ::koinos::chain::error_data* result::mutable_error() {
  ::koinos::chain::error_data* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:koinos.chain.result.error)
  return _msg;
}

inline bool result::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void result::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline result::ValueCase result::value_case() const {
  return result::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// object_space

// bool system = 1;
inline void object_space::clear_system() {
  system_ = false;
}
inline bool object_space::_internal_system() const {
  return system_;
}
inline bool object_space::system() const {
  // @@protoc_insertion_point(field_get:koinos.chain.object_space.system)
  return _internal_system();
}
inline void object_space::_internal_set_system(bool value) {
  
  system_ = value;
}
inline void object_space::set_system(bool value) {
  _internal_set_system(value);
  // @@protoc_insertion_point(field_set:koinos.chain.object_space.system)
}

// bytes zone = 2;
inline void object_space::clear_zone() {
  zone_.ClearToEmpty();
}
inline const std::string& object_space::zone() const {
  // @@protoc_insertion_point(field_get:koinos.chain.object_space.zone)
  return _internal_zone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void object_space::set_zone(ArgT0&& arg0, ArgT... args) {
 
 zone_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.object_space.zone)
}
inline std::string* object_space::mutable_zone() {
  std::string* _s = _internal_mutable_zone();
  // @@protoc_insertion_point(field_mutable:koinos.chain.object_space.zone)
  return _s;
}
inline const std::string& object_space::_internal_zone() const {
  return zone_.Get();
}
inline void object_space::_internal_set_zone(const std::string& value) {
  
  zone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* object_space::_internal_mutable_zone() {
  
  return zone_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* object_space::release_zone() {
  // @@protoc_insertion_point(field_release:koinos.chain.object_space.zone)
  return zone_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void object_space::set_allocated_zone(std::string* zone) {
  if (zone != nullptr) {
    
  } else {
    
  }
  zone_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), zone,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.object_space.zone)
}

// uint32 id = 3;
inline void object_space::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 object_space::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 object_space::id() const {
  // @@protoc_insertion_point(field_get:koinos.chain.object_space.id)
  return _internal_id();
}
inline void object_space::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void object_space::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:koinos.chain.object_space.id)
}

// -------------------------------------------------------------------

// database_key

// .koinos.chain.object_space space = 1;
inline bool database_key::_internal_has_space() const {
  return this != internal_default_instance() && space_ != nullptr;
}
inline bool database_key::has_space() const {
  return _internal_has_space();
}
inline void database_key::clear_space() {
  if (GetArenaForAllocation() == nullptr && space_ != nullptr) {
    delete space_;
  }
  space_ = nullptr;
}
inline const ::koinos::chain::object_space& database_key::_internal_space() const {
  const ::koinos::chain::object_space* p = space_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::object_space&>(
      ::koinos::chain::_object_space_default_instance_);
}
inline const ::koinos::chain::object_space& database_key::space() const {
  // @@protoc_insertion_point(field_get:koinos.chain.database_key.space)
  return _internal_space();
}
inline void database_key::unsafe_arena_set_allocated_space(
    ::koinos::chain::object_space* space) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(space_);
  }
  space_ = space;
  if (space) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.database_key.space)
}
inline ::koinos::chain::object_space* database_key::release_space() {
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::object_space* database_key::unsafe_arena_release_space() {
  // @@protoc_insertion_point(field_release:koinos.chain.database_key.space)
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
  return temp;
}
inline ::koinos::chain::object_space* database_key::_internal_mutable_space() {
  
  if (space_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::object_space>(GetArenaForAllocation());
    space_ = p;
  }
  return space_;
}
inline ::koinos::chain::object_space* database_key::mutable_space() {
  ::koinos::chain::object_space* _msg = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:koinos.chain.database_key.space)
  return _msg;
}
inline void database_key::set_allocated_space(::koinos::chain::object_space* space) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete space_;
  }
  if (space) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::koinos::chain::object_space>::GetOwningArena(space);
    if (message_arena != submessage_arena) {
      space = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, space, submessage_arena);
    }
    
  } else {
    
  }
  space_ = space;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.database_key.space)
}

// bytes key = 2;
inline void database_key::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& database_key::key() const {
  // @@protoc_insertion_point(field_get:koinos.chain.database_key.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void database_key::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.database_key.key)
}
inline std::string* database_key::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:koinos.chain.database_key.key)
  return _s;
}
inline const std::string& database_key::_internal_key() const {
  return key_.Get();
}
inline void database_key::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* database_key::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* database_key::release_key() {
  // @@protoc_insertion_point(field_release:koinos.chain.database_key.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void database_key::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.database_key.key)
}

// -------------------------------------------------------------------

// max_account_resources

// uint64 value = 1 [jstype = JS_STRING];
inline void max_account_resources::clear_value() {
  value_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 max_account_resources::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 max_account_resources::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.max_account_resources.value)
  return _internal_value();
}
inline void max_account_resources::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  value_ = value;
}
inline void max_account_resources::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:koinos.chain.max_account_resources.value)
}

// -------------------------------------------------------------------

// head_info

// .koinos.block_topology head_topology = 1;
inline bool head_info::_internal_has_head_topology() const {
  return this != internal_default_instance() && head_topology_ != nullptr;
}
inline bool head_info::has_head_topology() const {
  return _internal_has_head_topology();
}
inline const ::koinos::block_topology& head_info::_internal_head_topology() const {
  const ::koinos::block_topology* p = head_topology_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::block_topology&>(
      ::koinos::_block_topology_default_instance_);
}
inline const ::koinos::block_topology& head_info::head_topology() const {
  // @@protoc_insertion_point(field_get:koinos.chain.head_info.head_topology)
  return _internal_head_topology();
}
inline void head_info::unsafe_arena_set_allocated_head_topology(
    ::koinos::block_topology* head_topology) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_topology_);
  }
  head_topology_ = head_topology;
  if (head_topology) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.head_info.head_topology)
}
inline ::koinos::block_topology* head_info::release_head_topology() {
  
  ::koinos::block_topology* temp = head_topology_;
  head_topology_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::block_topology* head_info::unsafe_arena_release_head_topology() {
  // @@protoc_insertion_point(field_release:koinos.chain.head_info.head_topology)
  
  ::koinos::block_topology* temp = head_topology_;
  head_topology_ = nullptr;
  return temp;
}
inline ::koinos::block_topology* head_info::_internal_mutable_head_topology() {
  
  if (head_topology_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::block_topology>(GetArenaForAllocation());
    head_topology_ = p;
  }
  return head_topology_;
}
inline ::koinos::block_topology* head_info::mutable_head_topology() {
  ::koinos::block_topology* _msg = _internal_mutable_head_topology();
  // @@protoc_insertion_point(field_mutable:koinos.chain.head_info.head_topology)
  return _msg;
}
inline void head_info::set_allocated_head_topology(::koinos::block_topology* head_topology) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_topology_);
  }
  if (head_topology) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_topology));
    if (message_arena != submessage_arena) {
      head_topology = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head_topology, submessage_arena);
    }
    
  } else {
    
  }
  head_topology_ = head_topology;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.head_info.head_topology)
}

// uint64 head_block_time = 2 [jstype = JS_STRING];
inline void head_info::clear_head_block_time() {
  head_block_time_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 head_info::_internal_head_block_time() const {
  return head_block_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 head_info::head_block_time() const {
  // @@protoc_insertion_point(field_get:koinos.chain.head_info.head_block_time)
  return _internal_head_block_time();
}
inline void head_info::_internal_set_head_block_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  head_block_time_ = value;
}
inline void head_info::set_head_block_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_head_block_time(value);
  // @@protoc_insertion_point(field_set:koinos.chain.head_info.head_block_time)
}

// uint64 last_irreversible_block = 3 [jstype = JS_STRING];
inline void head_info::clear_last_irreversible_block() {
  last_irreversible_block_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 head_info::_internal_last_irreversible_block() const {
  return last_irreversible_block_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 head_info::last_irreversible_block() const {
  // @@protoc_insertion_point(field_get:koinos.chain.head_info.last_irreversible_block)
  return _internal_last_irreversible_block();
}
inline void head_info::_internal_set_last_irreversible_block(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  last_irreversible_block_ = value;
}
inline void head_info::set_last_irreversible_block(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_last_irreversible_block(value);
  // @@protoc_insertion_point(field_set:koinos.chain.head_info.last_irreversible_block)
}

// -------------------------------------------------------------------

// caller_data

// bytes caller = 1 [(.koinos.btype) = ADDRESS];
inline void caller_data::clear_caller() {
  caller_.ClearToEmpty();
}
inline const std::string& caller_data::caller() const {
  // @@protoc_insertion_point(field_get:koinos.chain.caller_data.caller)
  return _internal_caller();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void caller_data::set_caller(ArgT0&& arg0, ArgT... args) {
 
 caller_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.caller_data.caller)
}
inline std::string* caller_data::mutable_caller() {
  std::string* _s = _internal_mutable_caller();
  // @@protoc_insertion_point(field_mutable:koinos.chain.caller_data.caller)
  return _s;
}
inline const std::string& caller_data::_internal_caller() const {
  return caller_.Get();
}
inline void caller_data::_internal_set_caller(const std::string& value) {
  
  caller_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* caller_data::_internal_mutable_caller() {
  
  return caller_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* caller_data::release_caller() {
  // @@protoc_insertion_point(field_release:koinos.chain.caller_data.caller)
  return caller_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void caller_data::set_allocated_caller(std::string* caller) {
  if (caller != nullptr) {
    
  } else {
    
  }
  caller_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), caller,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.caller_data.caller)
}

// .koinos.chain.privilege caller_privilege = 2;
inline void caller_data::clear_caller_privilege() {
  caller_privilege_ = 0;
}
inline ::koinos::chain::privilege caller_data::_internal_caller_privilege() const {
  return static_cast< ::koinos::chain::privilege >(caller_privilege_);
}
inline ::koinos::chain::privilege caller_data::caller_privilege() const {
  // @@protoc_insertion_point(field_get:koinos.chain.caller_data.caller_privilege)
  return _internal_caller_privilege();
}
inline void caller_data::_internal_set_caller_privilege(::koinos::chain::privilege value) {
  
  caller_privilege_ = value;
}
inline void caller_data::set_caller_privilege(::koinos::chain::privilege value) {
  _internal_set_caller_privilege(value);
  // @@protoc_insertion_point(field_set:koinos.chain.caller_data.caller_privilege)
}

// -------------------------------------------------------------------

// argument_data

// uint32 entry_point = 1;
inline void argument_data::clear_entry_point() {
  entry_point_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 argument_data::_internal_entry_point() const {
  return entry_point_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 argument_data::entry_point() const {
  // @@protoc_insertion_point(field_get:koinos.chain.argument_data.entry_point)
  return _internal_entry_point();
}
inline void argument_data::_internal_set_entry_point(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  entry_point_ = value;
}
inline void argument_data::set_entry_point(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_entry_point(value);
  // @@protoc_insertion_point(field_set:koinos.chain.argument_data.entry_point)
}

// bytes arguments = 2;
inline void argument_data::clear_arguments() {
  arguments_.ClearToEmpty();
}
inline const std::string& argument_data::arguments() const {
  // @@protoc_insertion_point(field_get:koinos.chain.argument_data.arguments)
  return _internal_arguments();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void argument_data::set_arguments(ArgT0&& arg0, ArgT... args) {
 
 arguments_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.argument_data.arguments)
}
inline std::string* argument_data::mutable_arguments() {
  std::string* _s = _internal_mutable_arguments();
  // @@protoc_insertion_point(field_mutable:koinos.chain.argument_data.arguments)
  return _s;
}
inline const std::string& argument_data::_internal_arguments() const {
  return arguments_.Get();
}
inline void argument_data::_internal_set_arguments(const std::string& value) {
  
  arguments_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* argument_data::_internal_mutable_arguments() {
  
  return arguments_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* argument_data::release_arguments() {
  // @@protoc_insertion_point(field_release:koinos.chain.argument_data.arguments)
  return arguments_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void argument_data::set_allocated_arguments(std::string* arguments) {
  if (arguments != nullptr) {
    
  } else {
    
  }
  arguments_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), arguments,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.argument_data.arguments)
}

// -------------------------------------------------------------------

// resource_limit_data

// uint64 disk_storage_limit = 1 [jstype = JS_STRING];
inline void resource_limit_data::clear_disk_storage_limit() {
  disk_storage_limit_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::_internal_disk_storage_limit() const {
  return disk_storage_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::disk_storage_limit() const {
  // @@protoc_insertion_point(field_get:koinos.chain.resource_limit_data.disk_storage_limit)
  return _internal_disk_storage_limit();
}
inline void resource_limit_data::_internal_set_disk_storage_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  disk_storage_limit_ = value;
}
inline void resource_limit_data::set_disk_storage_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_disk_storage_limit(value);
  // @@protoc_insertion_point(field_set:koinos.chain.resource_limit_data.disk_storage_limit)
}

// uint64 disk_storage_cost = 2 [jstype = JS_STRING];
inline void resource_limit_data::clear_disk_storage_cost() {
  disk_storage_cost_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::_internal_disk_storage_cost() const {
  return disk_storage_cost_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::disk_storage_cost() const {
  // @@protoc_insertion_point(field_get:koinos.chain.resource_limit_data.disk_storage_cost)
  return _internal_disk_storage_cost();
}
inline void resource_limit_data::_internal_set_disk_storage_cost(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  disk_storage_cost_ = value;
}
inline void resource_limit_data::set_disk_storage_cost(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_disk_storage_cost(value);
  // @@protoc_insertion_point(field_set:koinos.chain.resource_limit_data.disk_storage_cost)
}

// uint64 network_bandwidth_limit = 3 [jstype = JS_STRING];
inline void resource_limit_data::clear_network_bandwidth_limit() {
  network_bandwidth_limit_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::_internal_network_bandwidth_limit() const {
  return network_bandwidth_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::network_bandwidth_limit() const {
  // @@protoc_insertion_point(field_get:koinos.chain.resource_limit_data.network_bandwidth_limit)
  return _internal_network_bandwidth_limit();
}
inline void resource_limit_data::_internal_set_network_bandwidth_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  network_bandwidth_limit_ = value;
}
inline void resource_limit_data::set_network_bandwidth_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_network_bandwidth_limit(value);
  // @@protoc_insertion_point(field_set:koinos.chain.resource_limit_data.network_bandwidth_limit)
}

// uint64 network_bandwidth_cost = 4 [jstype = JS_STRING];
inline void resource_limit_data::clear_network_bandwidth_cost() {
  network_bandwidth_cost_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::_internal_network_bandwidth_cost() const {
  return network_bandwidth_cost_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::network_bandwidth_cost() const {
  // @@protoc_insertion_point(field_get:koinos.chain.resource_limit_data.network_bandwidth_cost)
  return _internal_network_bandwidth_cost();
}
inline void resource_limit_data::_internal_set_network_bandwidth_cost(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  network_bandwidth_cost_ = value;
}
inline void resource_limit_data::set_network_bandwidth_cost(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_network_bandwidth_cost(value);
  // @@protoc_insertion_point(field_set:koinos.chain.resource_limit_data.network_bandwidth_cost)
}

// uint64 compute_bandwidth_limit = 5 [jstype = JS_STRING];
inline void resource_limit_data::clear_compute_bandwidth_limit() {
  compute_bandwidth_limit_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::_internal_compute_bandwidth_limit() const {
  return compute_bandwidth_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::compute_bandwidth_limit() const {
  // @@protoc_insertion_point(field_get:koinos.chain.resource_limit_data.compute_bandwidth_limit)
  return _internal_compute_bandwidth_limit();
}
inline void resource_limit_data::_internal_set_compute_bandwidth_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  compute_bandwidth_limit_ = value;
}
inline void resource_limit_data::set_compute_bandwidth_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_compute_bandwidth_limit(value);
  // @@protoc_insertion_point(field_set:koinos.chain.resource_limit_data.compute_bandwidth_limit)
}

// uint64 compute_bandwidth_cost = 6 [jstype = JS_STRING];
inline void resource_limit_data::clear_compute_bandwidth_cost() {
  compute_bandwidth_cost_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::_internal_compute_bandwidth_cost() const {
  return compute_bandwidth_cost_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 resource_limit_data::compute_bandwidth_cost() const {
  // @@protoc_insertion_point(field_get:koinos.chain.resource_limit_data.compute_bandwidth_cost)
  return _internal_compute_bandwidth_cost();
}
inline void resource_limit_data::_internal_set_compute_bandwidth_cost(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  compute_bandwidth_cost_ = value;
}
inline void resource_limit_data::set_compute_bandwidth_cost(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_compute_bandwidth_cost(value);
  // @@protoc_insertion_point(field_set:koinos.chain.resource_limit_data.compute_bandwidth_cost)
}

// -------------------------------------------------------------------

// contract_metadata_object

// bytes hash = 1;
inline void contract_metadata_object::clear_hash() {
  hash_.ClearToEmpty();
}
inline const std::string& contract_metadata_object::hash() const {
  // @@protoc_insertion_point(field_get:koinos.chain.contract_metadata_object.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void contract_metadata_object::set_hash(ArgT0&& arg0, ArgT... args) {
 
 hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.contract_metadata_object.hash)
}
inline std::string* contract_metadata_object::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:koinos.chain.contract_metadata_object.hash)
  return _s;
}
inline const std::string& contract_metadata_object::_internal_hash() const {
  return hash_.Get();
}
inline void contract_metadata_object::_internal_set_hash(const std::string& value) {
  
  hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* contract_metadata_object::_internal_mutable_hash() {
  
  return hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* contract_metadata_object::release_hash() {
  // @@protoc_insertion_point(field_release:koinos.chain.contract_metadata_object.hash)
  return hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void contract_metadata_object::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.contract_metadata_object.hash)
}

// bool system = 2;
inline void contract_metadata_object::clear_system() {
  system_ = false;
}
inline bool contract_metadata_object::_internal_system() const {
  return system_;
}
inline bool contract_metadata_object::system() const {
  // @@protoc_insertion_point(field_get:koinos.chain.contract_metadata_object.system)
  return _internal_system();
}
inline void contract_metadata_object::_internal_set_system(bool value) {
  
  system_ = value;
}
inline void contract_metadata_object::set_system(bool value) {
  _internal_set_system(value);
  // @@protoc_insertion_point(field_set:koinos.chain.contract_metadata_object.system)
}

// bool authorizes_call_contract = 3;
inline void contract_metadata_object::clear_authorizes_call_contract() {
  authorizes_call_contract_ = false;
}
inline bool contract_metadata_object::_internal_authorizes_call_contract() const {
  return authorizes_call_contract_;
}
inline bool contract_metadata_object::authorizes_call_contract() const {
  // @@protoc_insertion_point(field_get:koinos.chain.contract_metadata_object.authorizes_call_contract)
  return _internal_authorizes_call_contract();
}
inline void contract_metadata_object::_internal_set_authorizes_call_contract(bool value) {
  
  authorizes_call_contract_ = value;
}
inline void contract_metadata_object::set_authorizes_call_contract(bool value) {
  _internal_set_authorizes_call_contract(value);
  // @@protoc_insertion_point(field_set:koinos.chain.contract_metadata_object.authorizes_call_contract)
}

// bool authorizes_transaction_application = 4;
inline void contract_metadata_object::clear_authorizes_transaction_application() {
  authorizes_transaction_application_ = false;
}
inline bool contract_metadata_object::_internal_authorizes_transaction_application() const {
  return authorizes_transaction_application_;
}
inline bool contract_metadata_object::authorizes_transaction_application() const {
  // @@protoc_insertion_point(field_get:koinos.chain.contract_metadata_object.authorizes_transaction_application)
  return _internal_authorizes_transaction_application();
}
inline void contract_metadata_object::_internal_set_authorizes_transaction_application(bool value) {
  
  authorizes_transaction_application_ = value;
}
inline void contract_metadata_object::set_authorizes_transaction_application(bool value) {
  _internal_set_authorizes_transaction_application(value);
  // @@protoc_insertion_point(field_set:koinos.chain.contract_metadata_object.authorizes_transaction_application)
}

// bool authorizes_upload_contract = 5;
inline void contract_metadata_object::clear_authorizes_upload_contract() {
  authorizes_upload_contract_ = false;
}
inline bool contract_metadata_object::_internal_authorizes_upload_contract() const {
  return authorizes_upload_contract_;
}
inline bool contract_metadata_object::authorizes_upload_contract() const {
  // @@protoc_insertion_point(field_get:koinos.chain.contract_metadata_object.authorizes_upload_contract)
  return _internal_authorizes_upload_contract();
}
inline void contract_metadata_object::_internal_set_authorizes_upload_contract(bool value) {
  
  authorizes_upload_contract_ = value;
}
inline void contract_metadata_object::set_authorizes_upload_contract(bool value) {
  _internal_set_authorizes_upload_contract(value);
  // @@protoc_insertion_point(field_set:koinos.chain.contract_metadata_object.authorizes_upload_contract)
}

// -------------------------------------------------------------------

// compute_bandwidth_entry

// string name = 1;
inline void compute_bandwidth_entry::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& compute_bandwidth_entry::name() const {
  // @@protoc_insertion_point(field_get:koinos.chain.compute_bandwidth_entry.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void compute_bandwidth_entry::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.compute_bandwidth_entry.name)
}
inline std::string* compute_bandwidth_entry::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:koinos.chain.compute_bandwidth_entry.name)
  return _s;
}
inline const std::string& compute_bandwidth_entry::_internal_name() const {
  return name_.Get();
}
inline void compute_bandwidth_entry::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* compute_bandwidth_entry::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* compute_bandwidth_entry::release_name() {
  // @@protoc_insertion_point(field_release:koinos.chain.compute_bandwidth_entry.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void compute_bandwidth_entry::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.compute_bandwidth_entry.name)
}

// uint64 compute = 2;
inline void compute_bandwidth_entry::clear_compute() {
  compute_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 compute_bandwidth_entry::_internal_compute() const {
  return compute_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 compute_bandwidth_entry::compute() const {
  // @@protoc_insertion_point(field_get:koinos.chain.compute_bandwidth_entry.compute)
  return _internal_compute();
}
inline void compute_bandwidth_entry::_internal_set_compute(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  compute_ = value;
}
inline void compute_bandwidth_entry::set_compute(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_compute(value);
  // @@protoc_insertion_point(field_set:koinos.chain.compute_bandwidth_entry.compute)
}

// -------------------------------------------------------------------

// compute_bandwidth_registry

// repeated .koinos.chain.compute_bandwidth_entry entries = 1;
inline int compute_bandwidth_registry::_internal_entries_size() const {
  return entries_.size();
}
inline int compute_bandwidth_registry::entries_size() const {
  return _internal_entries_size();
}
inline void compute_bandwidth_registry::clear_entries() {
  entries_.Clear();
}
inline ::koinos::chain::compute_bandwidth_entry* compute_bandwidth_registry::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:koinos.chain.compute_bandwidth_registry.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::koinos::chain::compute_bandwidth_entry >*
compute_bandwidth_registry::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:koinos.chain.compute_bandwidth_registry.entries)
  return &entries_;
}
inline const ::koinos::chain::compute_bandwidth_entry& compute_bandwidth_registry::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::koinos::chain::compute_bandwidth_entry& compute_bandwidth_registry::entries(int index) const {
  // @@protoc_insertion_point(field_get:koinos.chain.compute_bandwidth_registry.entries)
  return _internal_entries(index);
}
inline ::koinos::chain::compute_bandwidth_entry* compute_bandwidth_registry::_internal_add_entries() {
  return entries_.Add();
}
inline ::koinos::chain::compute_bandwidth_entry* compute_bandwidth_registry::add_entries() {
  ::koinos::chain::compute_bandwidth_entry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:koinos.chain.compute_bandwidth_registry.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::koinos::chain::compute_bandwidth_entry >&
compute_bandwidth_registry::entries() const {
  // @@protoc_insertion_point(field_list:koinos.chain.compute_bandwidth_registry.entries)
  return entries_;
}

// -------------------------------------------------------------------

// genesis_entry

// .koinos.chain.object_space space = 1;
inline bool genesis_entry::_internal_has_space() const {
  return this != internal_default_instance() && space_ != nullptr;
}
inline bool genesis_entry::has_space() const {
  return _internal_has_space();
}
inline void genesis_entry::clear_space() {
  if (GetArenaForAllocation() == nullptr && space_ != nullptr) {
    delete space_;
  }
  space_ = nullptr;
}
inline const ::koinos::chain::object_space& genesis_entry::_internal_space() const {
  const ::koinos::chain::object_space* p = space_;
  return p != nullptr ? *p : reinterpret_cast<const ::koinos::chain::object_space&>(
      ::koinos::chain::_object_space_default_instance_);
}
inline const ::koinos::chain::object_space& genesis_entry::space() const {
  // @@protoc_insertion_point(field_get:koinos.chain.genesis_entry.space)
  return _internal_space();
}
inline void genesis_entry::unsafe_arena_set_allocated_space(
    ::koinos::chain::object_space* space) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(space_);
  }
  space_ = space;
  if (space) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:koinos.chain.genesis_entry.space)
}
inline ::koinos::chain::object_space* genesis_entry::release_space() {
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::koinos::chain::object_space* genesis_entry::unsafe_arena_release_space() {
  // @@protoc_insertion_point(field_release:koinos.chain.genesis_entry.space)
  
  ::koinos::chain::object_space* temp = space_;
  space_ = nullptr;
  return temp;
}
inline ::koinos::chain::object_space* genesis_entry::_internal_mutable_space() {
  
  if (space_ == nullptr) {
    auto* p = CreateMaybeMessage<::koinos::chain::object_space>(GetArenaForAllocation());
    space_ = p;
  }
  return space_;
}
inline ::koinos::chain::object_space* genesis_entry::mutable_space() {
  ::koinos::chain::object_space* _msg = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:koinos.chain.genesis_entry.space)
  return _msg;
}
inline void genesis_entry::set_allocated_space(::koinos::chain::object_space* space) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete space_;
  }
  if (space) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::koinos::chain::object_space>::GetOwningArena(space);
    if (message_arena != submessage_arena) {
      space = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, space, submessage_arena);
    }
    
  } else {
    
  }
  space_ = space;
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.genesis_entry.space)
}

// bytes key = 2;
inline void genesis_entry::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& genesis_entry::key() const {
  // @@protoc_insertion_point(field_get:koinos.chain.genesis_entry.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void genesis_entry::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.genesis_entry.key)
}
inline std::string* genesis_entry::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:koinos.chain.genesis_entry.key)
  return _s;
}
inline const std::string& genesis_entry::_internal_key() const {
  return key_.Get();
}
inline void genesis_entry::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* genesis_entry::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* genesis_entry::release_key() {
  // @@protoc_insertion_point(field_release:koinos.chain.genesis_entry.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void genesis_entry::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.genesis_entry.key)
}

// bytes value = 3;
inline void genesis_entry::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& genesis_entry::value() const {
  // @@protoc_insertion_point(field_get:koinos.chain.genesis_entry.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void genesis_entry::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:koinos.chain.genesis_entry.value)
}
inline std::string* genesis_entry::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:koinos.chain.genesis_entry.value)
  return _s;
}
inline const std::string& genesis_entry::_internal_value() const {
  return value_.Get();
}
inline void genesis_entry::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* genesis_entry::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* genesis_entry::release_value() {
  // @@protoc_insertion_point(field_release:koinos.chain.genesis_entry.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void genesis_entry::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.genesis_entry.value)
}

// -------------------------------------------------------------------

// genesis_data

// repeated .koinos.chain.genesis_entry entries = 1;
inline int genesis_data::_internal_entries_size() const {
  return entries_.size();
}
inline int genesis_data::entries_size() const {
  return _internal_entries_size();
}
inline void genesis_data::clear_entries() {
  entries_.Clear();
}
inline ::koinos::chain::genesis_entry* genesis_data::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:koinos.chain.genesis_data.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::koinos::chain::genesis_entry >*
genesis_data::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:koinos.chain.genesis_data.entries)
  return &entries_;
}
inline const ::koinos::chain::genesis_entry& genesis_data::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::koinos::chain::genesis_entry& genesis_data::entries(int index) const {
  // @@protoc_insertion_point(field_get:koinos.chain.genesis_data.entries)
  return _internal_entries(index);
}
inline ::koinos::chain::genesis_entry* genesis_data::_internal_add_entries() {
  return entries_.Add();
}
inline ::koinos::chain::genesis_entry* genesis_data::add_entries() {
  ::koinos::chain::genesis_entry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:koinos.chain.genesis_data.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::koinos::chain::genesis_entry >&
genesis_data::entries() const {
  // @@protoc_insertion_point(field_list:koinos.chain.genesis_data.entries)
  return entries_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chain
}  // namespace koinos

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::koinos::chain::privilege> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::koinos::chain::privilege>() {
  return ::koinos::chain::privilege_descriptor();
}
template <> struct is_proto_enum< ::koinos::chain::dsa> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::koinos::chain::dsa>() {
  return ::koinos::chain::dsa_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_koinos_2fchain_2fchain_2eproto
