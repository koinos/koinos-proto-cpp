// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: koinos/chain/chain.proto

#include "koinos/chain/chain.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace koinos {
namespace chain {
constexpr error_data::error_data(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct error_dataDefaultTypeInternal {
  constexpr error_dataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~error_dataDefaultTypeInternal() {}
  union {
    error_data _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT error_dataDefaultTypeInternal _error_data_default_instance_;
constexpr result::result(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct resultDefaultTypeInternal {
  constexpr resultDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~resultDefaultTypeInternal() {}
  union {
    result _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT resultDefaultTypeInternal _result_default_instance_;
constexpr object_space::object_space(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : zone_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , system_(false)
  , id_(0u){}
struct object_spaceDefaultTypeInternal {
  constexpr object_spaceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~object_spaceDefaultTypeInternal() {}
  union {
    object_space _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT object_spaceDefaultTypeInternal _object_space_default_instance_;
constexpr database_key::database_key(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , space_(nullptr){}
struct database_keyDefaultTypeInternal {
  constexpr database_keyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~database_keyDefaultTypeInternal() {}
  union {
    database_key _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT database_keyDefaultTypeInternal _database_key_default_instance_;
constexpr max_account_resources::max_account_resources(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : value_(uint64_t{0u}){}
struct max_account_resourcesDefaultTypeInternal {
  constexpr max_account_resourcesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~max_account_resourcesDefaultTypeInternal() {}
  union {
    max_account_resources _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT max_account_resourcesDefaultTypeInternal _max_account_resources_default_instance_;
constexpr head_info::head_info(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : head_topology_(nullptr)
  , head_block_time_(uint64_t{0u})
  , last_irreversible_block_(uint64_t{0u}){}
struct head_infoDefaultTypeInternal {
  constexpr head_infoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~head_infoDefaultTypeInternal() {}
  union {
    head_info _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT head_infoDefaultTypeInternal _head_info_default_instance_;
constexpr caller_data::caller_data(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : caller_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , caller_privilege_(0)
{}
struct caller_dataDefaultTypeInternal {
  constexpr caller_dataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~caller_dataDefaultTypeInternal() {}
  union {
    caller_data _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT caller_dataDefaultTypeInternal _caller_data_default_instance_;
constexpr argument_data::argument_data(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : arguments_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , entry_point_(0u){}
struct argument_dataDefaultTypeInternal {
  constexpr argument_dataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~argument_dataDefaultTypeInternal() {}
  union {
    argument_data _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT argument_dataDefaultTypeInternal _argument_data_default_instance_;
constexpr resource_limit_data::resource_limit_data(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : disk_storage_limit_(uint64_t{0u})
  , disk_storage_cost_(uint64_t{0u})
  , network_bandwidth_limit_(uint64_t{0u})
  , network_bandwidth_cost_(uint64_t{0u})
  , compute_bandwidth_limit_(uint64_t{0u})
  , compute_bandwidth_cost_(uint64_t{0u}){}
struct resource_limit_dataDefaultTypeInternal {
  constexpr resource_limit_dataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~resource_limit_dataDefaultTypeInternal() {}
  union {
    resource_limit_data _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT resource_limit_dataDefaultTypeInternal _resource_limit_data_default_instance_;
constexpr contract_metadata_object::contract_metadata_object(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : hash_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , system_(false)
  , authorizes_call_contract_(false)
  , authorizes_transaction_application_(false)
  , authorizes_upload_contract_(false){}
struct contract_metadata_objectDefaultTypeInternal {
  constexpr contract_metadata_objectDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~contract_metadata_objectDefaultTypeInternal() {}
  union {
    contract_metadata_object _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT contract_metadata_objectDefaultTypeInternal _contract_metadata_object_default_instance_;
constexpr compute_bandwidth_entry::compute_bandwidth_entry(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , compute_(uint64_t{0u}){}
struct compute_bandwidth_entryDefaultTypeInternal {
  constexpr compute_bandwidth_entryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~compute_bandwidth_entryDefaultTypeInternal() {}
  union {
    compute_bandwidth_entry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT compute_bandwidth_entryDefaultTypeInternal _compute_bandwidth_entry_default_instance_;
constexpr compute_bandwidth_registry::compute_bandwidth_registry(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : entries_(){}
struct compute_bandwidth_registryDefaultTypeInternal {
  constexpr compute_bandwidth_registryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~compute_bandwidth_registryDefaultTypeInternal() {}
  union {
    compute_bandwidth_registry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT compute_bandwidth_registryDefaultTypeInternal _compute_bandwidth_registry_default_instance_;
constexpr genesis_entry::genesis_entry(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , value_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , space_(nullptr){}
struct genesis_entryDefaultTypeInternal {
  constexpr genesis_entryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~genesis_entryDefaultTypeInternal() {}
  union {
    genesis_entry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT genesis_entryDefaultTypeInternal _genesis_entry_default_instance_;
constexpr genesis_data::genesis_data(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : entries_(){}
struct genesis_dataDefaultTypeInternal {
  constexpr genesis_dataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~genesis_dataDefaultTypeInternal() {}
  union {
    genesis_data _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT genesis_dataDefaultTypeInternal _genesis_data_default_instance_;
}  // namespace chain
}  // namespace koinos
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_koinos_2fchain_2fchain_2eproto[14];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_koinos_2fchain_2fchain_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_koinos_2fchain_2fchain_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_koinos_2fchain_2fchain_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::error_data, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::error_data, message_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::result, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::result, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::koinos::chain::result, value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::object_space, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::object_space, system_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::object_space, zone_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::object_space, id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::database_key, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::database_key, space_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::database_key, key_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::max_account_resources, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::max_account_resources, value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::head_info, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::head_info, head_topology_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::head_info, head_block_time_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::head_info, last_irreversible_block_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::caller_data, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::caller_data, caller_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::caller_data, caller_privilege_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::argument_data, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::argument_data, entry_point_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::argument_data, arguments_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::resource_limit_data, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::resource_limit_data, disk_storage_limit_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::resource_limit_data, disk_storage_cost_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::resource_limit_data, network_bandwidth_limit_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::resource_limit_data, network_bandwidth_cost_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::resource_limit_data, compute_bandwidth_limit_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::resource_limit_data, compute_bandwidth_cost_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::contract_metadata_object, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::contract_metadata_object, hash_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::contract_metadata_object, system_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::contract_metadata_object, authorizes_call_contract_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::contract_metadata_object, authorizes_transaction_application_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::contract_metadata_object, authorizes_upload_contract_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::compute_bandwidth_entry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::compute_bandwidth_entry, name_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::compute_bandwidth_entry, compute_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::compute_bandwidth_registry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::compute_bandwidth_registry, entries_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::genesis_entry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::genesis_entry, space_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::genesis_entry, key_),
  PROTOBUF_FIELD_OFFSET(::koinos::chain::genesis_entry, value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::genesis_data, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::koinos::chain::genesis_data, entries_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::koinos::chain::error_data)},
  { 6, -1, sizeof(::koinos::chain::result)},
  { 14, -1, sizeof(::koinos::chain::object_space)},
  { 22, -1, sizeof(::koinos::chain::database_key)},
  { 29, -1, sizeof(::koinos::chain::max_account_resources)},
  { 35, -1, sizeof(::koinos::chain::head_info)},
  { 43, -1, sizeof(::koinos::chain::caller_data)},
  { 50, -1, sizeof(::koinos::chain::argument_data)},
  { 57, -1, sizeof(::koinos::chain::resource_limit_data)},
  { 68, -1, sizeof(::koinos::chain::contract_metadata_object)},
  { 78, -1, sizeof(::koinos::chain::compute_bandwidth_entry)},
  { 85, -1, sizeof(::koinos::chain::compute_bandwidth_registry)},
  { 91, -1, sizeof(::koinos::chain::genesis_entry)},
  { 99, -1, sizeof(::koinos::chain::genesis_data)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::koinos::chain::_error_data_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::koinos::chain::_result_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::koinos::chain::_object_space_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::koinos::chain::_database_key_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::koinos::chain::_max_account_resources_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::koinos::chain::_head_info_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::koinos::chain::_caller_data_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::koinos::chain::_argument_data_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::koinos::chain::_resource_limit_data_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::koinos::chain::_contract_metadata_object_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::koinos::chain::_compute_bandwidth_entry_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::koinos::chain::_compute_bandwidth_registry_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::koinos::chain::_genesis_entry_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::koinos::chain::_genesis_data_default_instance_),
};

const char descriptor_table_protodef_koinos_2fchain_2fchain_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\030koinos/chain/chain.proto\022\014koinos.chain"
  "\032\024koinos/options.proto\032\023koinos/common.pr"
  "oto\"\035\n\nerror_data\022\017\n\007message\030\001 \001(\t\"N\n\006re"
  "sult\022\020\n\006object\030\001 \001(\014H\000\022)\n\005error\030\002 \001(\0132\030."
  "koinos.chain.error_dataH\000B\007\n\005value\"8\n\014ob"
  "ject_space\022\016\n\006system\030\001 \001(\010\022\014\n\004zone\030\002 \001(\014"
  "\022\n\n\002id\030\003 \001(\r\"F\n\014database_key\022)\n\005space\030\001 "
  "\001(\0132\032.koinos.chain.object_space\022\013\n\003key\030\002"
  " \001(\014\"*\n\025max_account_resources\022\021\n\005value\030\001"
  " \001(\004B\0020\001\"|\n\thead_info\022-\n\rhead_topology\030\001"
  " \001(\0132\026.koinos.block_topology\022\033\n\017head_blo"
  "ck_time\030\002 \001(\004B\0020\001\022#\n\027last_irreversible_b"
  "lock\030\003 \001(\004B\0020\001\"V\n\013caller_data\022\024\n\006caller\030"
  "\001 \001(\014B\004\200\265\030\006\0221\n\020caller_privilege\030\002 \001(\0162\027."
  "koinos.chain.privilege\"7\n\rargument_data\022"
  "\023\n\013entry_point\030\001 \001(\r\022\021\n\targuments\030\002 \001(\014\""
  "\346\001\n\023resource_limit_data\022\036\n\022disk_storage_"
  "limit\030\001 \001(\004B\0020\001\022\035\n\021disk_storage_cost\030\002 \001"
  "(\004B\0020\001\022#\n\027network_bandwidth_limit\030\003 \001(\004B"
  "\0020\001\022\"\n\026network_bandwidth_cost\030\004 \001(\004B\0020\001\022"
  "#\n\027compute_bandwidth_limit\030\005 \001(\004B\0020\001\022\"\n\026"
  "compute_bandwidth_cost\030\006 \001(\004B\0020\001\"\252\001\n\030con"
  "tract_metadata_object\022\014\n\004hash\030\001 \001(\014\022\016\n\006s"
  "ystem\030\002 \001(\010\022 \n\030authorizes_call_contract\030"
  "\003 \001(\010\022*\n\"authorizes_transaction_applicat"
  "ion\030\004 \001(\010\022\"\n\032authorizes_upload_contract\030"
  "\005 \001(\010\"8\n\027compute_bandwidth_entry\022\014\n\004name"
  "\030\001 \001(\t\022\017\n\007compute\030\002 \001(\004\"T\n\032compute_bandw"
  "idth_registry\0226\n\007entries\030\001 \003(\0132%.koinos."
  "chain.compute_bandwidth_entry\"V\n\rgenesis"
  "_entry\022)\n\005space\030\001 \001(\0132\032.koinos.chain.obj"
  "ect_space\022\013\n\003key\030\002 \001(\014\022\r\n\005value\030\003 \001(\014\"<\n"
  "\014genesis_data\022,\n\007entries\030\001 \003(\0132\033.koinos."
  "chain.genesis_entry*+\n\tprivilege\022\017\n\013kern"
  "el_mode\020\000\022\r\n\tuser_mode\020\001*\032\n\003dsa\022\023\n\017ecdsa"
  "_secp256k1\020\000B7Z5github.com/koinos/koinos"
  "-proto-golang/v2/koinos/chainb\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_koinos_2fchain_2fchain_2eproto_deps[2] = {
  &::descriptor_table_koinos_2fcommon_2eproto,
  &::descriptor_table_koinos_2foptions_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_koinos_2fchain_2fchain_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_koinos_2fchain_2fchain_2eproto = {
  false, false, 1477, descriptor_table_protodef_koinos_2fchain_2fchain_2eproto, "koinos/chain/chain.proto", 
  &descriptor_table_koinos_2fchain_2fchain_2eproto_once, descriptor_table_koinos_2fchain_2fchain_2eproto_deps, 2, 14,
  schemas, file_default_instances, TableStruct_koinos_2fchain_2fchain_2eproto::offsets,
  file_level_metadata_koinos_2fchain_2fchain_2eproto, file_level_enum_descriptors_koinos_2fchain_2fchain_2eproto, file_level_service_descriptors_koinos_2fchain_2fchain_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_koinos_2fchain_2fchain_2eproto_getter() {
  return &descriptor_table_koinos_2fchain_2fchain_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_koinos_2fchain_2fchain_2eproto(&descriptor_table_koinos_2fchain_2fchain_2eproto);
namespace koinos {
namespace chain {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* privilege_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_koinos_2fchain_2fchain_2eproto);
  return file_level_enum_descriptors_koinos_2fchain_2fchain_2eproto[0];
}
bool privilege_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* dsa_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_koinos_2fchain_2fchain_2eproto);
  return file_level_enum_descriptors_koinos_2fchain_2fchain_2eproto[1];
}
bool dsa_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class error_data::_Internal {
 public:
};

error_data::error_data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:koinos.chain.error_data)
}
error_data::error_data(const error_data& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_message().empty()) {
    message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_message(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:koinos.chain.error_data)
}

inline void error_data::SharedCtor() {
message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

error_data::~error_data() {
  // @@protoc_insertion_point(destructor:koinos.chain.error_data)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void error_data::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void error_data::ArenaDtor(void* object) {
  error_data* _this = reinterpret_cast< error_data* >(object);
  (void)_this;
}
void error_data::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void error_data::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void error_data::Clear() {
// @@protoc_insertion_point(message_clear_start:koinos.chain.error_data)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  message_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* error_data::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "koinos.chain.error_data.message"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* error_data::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:koinos.chain.error_data)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "koinos.chain.error_data.message");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:koinos.chain.error_data)
  return target;
}

size_t error_data::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:koinos.chain.error_data)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData error_data::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    error_data::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*error_data::GetClassData() const { return &_class_data_; }

void error_data::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<error_data *>(to)->MergeFrom(
      static_cast<const error_data &>(from));
}


void error_data::MergeFrom(const error_data& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:koinos.chain.error_data)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _internal_set_message(from._internal_message());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void error_data::CopyFrom(const error_data& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:koinos.chain.error_data)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool error_data::IsInitialized() const {
  return true;
}

void error_data::InternalSwap(error_data* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &message_, GetArenaForAllocation(),
      &other->message_, other->GetArenaForAllocation()
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata error_data::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_koinos_2fchain_2fchain_2eproto_getter, &descriptor_table_koinos_2fchain_2fchain_2eproto_once,
      file_level_metadata_koinos_2fchain_2fchain_2eproto[0]);
}

// ===================================================================

class result::_Internal {
 public:
  static const ::koinos::chain::error_data& error(const result* msg);
};

const ::koinos::chain::error_data&
result::_Internal::error(const result* msg) {
  return *msg->value_.error_;
}
void result::set_allocated_error(::koinos::chain::error_data* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::koinos::chain::error_data>::GetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    set_has_error();
    value_.error_ = error;
  }
  // @@protoc_insertion_point(field_set_allocated:koinos.chain.result.error)
}
result::result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:koinos.chain.result)
}
result::result(const result& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_value();
  switch (from.value_case()) {
    case kObject: {
      _internal_set_object(from._internal_object());
      break;
    }
    case kError: {
      _internal_mutable_error()->::koinos::chain::error_data::MergeFrom(from._internal_error());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:koinos.chain.result)
}

inline void result::SharedCtor() {
clear_has_value();
}

result::~result() {
  // @@protoc_insertion_point(destructor:koinos.chain.result)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void result::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_value()) {
    clear_value();
  }
}

void result::ArenaDtor(void* object) {
  result* _this = reinterpret_cast< result* >(object);
  (void)_this;
}
void result::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void result::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void result::clear_value() {
// @@protoc_insertion_point(one_of_clear_start:koinos.chain.result)
  switch (value_case()) {
    case kObject: {
      value_.object_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
      break;
    }
    case kError: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_.error_;
      }
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = VALUE_NOT_SET;
}


void result::Clear() {
// @@protoc_insertion_point(message_clear_start:koinos.chain.result)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_value();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* result::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes object = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_object();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .koinos.chain.error_data error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_error(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* result::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:koinos.chain.result)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes object = 1;
  if (_internal_has_object()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_object(), target);
  }

  // .koinos.chain.error_data error = 2;
  if (_internal_has_error()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::error(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:koinos.chain.result)
  return target;
}

size_t result::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:koinos.chain.result)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (value_case()) {
    // bytes object = 1;
    case kObject: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_object());
      break;
    }
    // .koinos.chain.error_data error = 2;
    case kError: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_.error_);
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData result::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    result::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*result::GetClassData() const { return &_class_data_; }

void result::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<result *>(to)->MergeFrom(
      static_cast<const result &>(from));
}


void result::MergeFrom(const result& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:koinos.chain.result)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.value_case()) {
    case kObject: {
      _internal_set_object(from._internal_object());
      break;
    }
    case kError: {
      _internal_mutable_error()->::koinos::chain::error_data::MergeFrom(from._internal_error());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void result::CopyFrom(const result& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:koinos.chain.result)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool result::IsInitialized() const {
  return true;
}

void result::InternalSwap(result* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(value_, other->value_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata result::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_koinos_2fchain_2fchain_2eproto_getter, &descriptor_table_koinos_2fchain_2fchain_2eproto_once,
      file_level_metadata_koinos_2fchain_2fchain_2eproto[1]);
}

// ===================================================================

class object_space::_Internal {
 public:
};

object_space::object_space(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:koinos.chain.object_space)
}
object_space::object_space(const object_space& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  zone_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_zone().empty()) {
    zone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_zone(), 
      GetArenaForAllocation());
  }
  ::memcpy(&system_, &from.system_,
    static_cast<size_t>(reinterpret_cast<char*>(&id_) -
    reinterpret_cast<char*>(&system_)) + sizeof(id_));
  // @@protoc_insertion_point(copy_constructor:koinos.chain.object_space)
}

inline void object_space::SharedCtor() {
zone_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&system_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&id_) -
    reinterpret_cast<char*>(&system_)) + sizeof(id_));
}

object_space::~object_space() {
  // @@protoc_insertion_point(destructor:koinos.chain.object_space)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void object_space::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  zone_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void object_space::ArenaDtor(void* object) {
  object_space* _this = reinterpret_cast< object_space* >(object);
  (void)_this;
}
void object_space::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void object_space::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void object_space::Clear() {
// @@protoc_insertion_point(message_clear_start:koinos.chain.object_space)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  zone_.ClearToEmpty();
  ::memset(&system_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&system_)) + sizeof(id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* object_space::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool system = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          system_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bytes zone = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_zone();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* object_space::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:koinos.chain.object_space)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bool system = 1;
  if (this->_internal_system() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_system(), target);
  }

  // bytes zone = 2;
  if (!this->_internal_zone().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_zone(), target);
  }

  // uint32 id = 3;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:koinos.chain.object_space)
  return target;
}

size_t object_space::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:koinos.chain.object_space)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes zone = 2;
  if (!this->_internal_zone().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_zone());
  }

  // bool system = 1;
  if (this->_internal_system() != 0) {
    total_size += 1 + 1;
  }

  // uint32 id = 3;
  if (this->_internal_id() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData object_space::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    object_space::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*object_space::GetClassData() const { return &_class_data_; }

void object_space::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<object_space *>(to)->MergeFrom(
      static_cast<const object_space &>(from));
}


void object_space::MergeFrom(const object_space& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:koinos.chain.object_space)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_zone().empty()) {
    _internal_set_zone(from._internal_zone());
  }
  if (from._internal_system() != 0) {
    _internal_set_system(from._internal_system());
  }
  if (from._internal_id() != 0) {
    _internal_set_id(from._internal_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void object_space::CopyFrom(const object_space& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:koinos.chain.object_space)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool object_space::IsInitialized() const {
  return true;
}

void object_space::InternalSwap(object_space* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &zone_, GetArenaForAllocation(),
      &other->zone_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(object_space, id_)
      + sizeof(object_space::id_)
      - PROTOBUF_FIELD_OFFSET(object_space, system_)>(
          reinterpret_cast<char*>(&system_),
          reinterpret_cast<char*>(&other->system_));
}

::PROTOBUF_NAMESPACE_ID::Metadata object_space::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_koinos_2fchain_2fchain_2eproto_getter, &descriptor_table_koinos_2fchain_2fchain_2eproto_once,
      file_level_metadata_koinos_2fchain_2fchain_2eproto[2]);
}

// ===================================================================

class database_key::_Internal {
 public:
  static const ::koinos::chain::object_space& space(const database_key* msg);
};

const ::koinos::chain::object_space&
database_key::_Internal::space(const database_key* msg) {
  return *msg->space_;
}
database_key::database_key(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:koinos.chain.database_key)
}
database_key::database_key(const database_key& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_key().empty()) {
    key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_space()) {
    space_ = new ::koinos::chain::object_space(*from.space_);
  } else {
    space_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:koinos.chain.database_key)
}

inline void database_key::SharedCtor() {
key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
space_ = nullptr;
}

database_key::~database_key() {
  // @@protoc_insertion_point(destructor:koinos.chain.database_key)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void database_key::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete space_;
}

void database_key::ArenaDtor(void* object) {
  database_key* _this = reinterpret_cast< database_key* >(object);
  (void)_this;
}
void database_key::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void database_key::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void database_key::Clear() {
// @@protoc_insertion_point(message_clear_start:koinos.chain.database_key)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  key_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && space_ != nullptr) {
    delete space_;
  }
  space_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* database_key::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .koinos.chain.object_space space = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_space(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bytes key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* database_key::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:koinos.chain.database_key)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .koinos.chain.object_space space = 1;
  if (this->_internal_has_space()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::space(this), target, stream);
  }

  // bytes key = 2;
  if (!this->_internal_key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:koinos.chain.database_key)
  return target;
}

size_t database_key::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:koinos.chain.database_key)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes key = 2;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());
  }

  // .koinos.chain.object_space space = 1;
  if (this->_internal_has_space()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *space_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData database_key::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    database_key::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*database_key::GetClassData() const { return &_class_data_; }

void database_key::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<database_key *>(to)->MergeFrom(
      static_cast<const database_key &>(from));
}


void database_key::MergeFrom(const database_key& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:koinos.chain.database_key)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _internal_set_key(from._internal_key());
  }
  if (from._internal_has_space()) {
    _internal_mutable_space()->::koinos::chain::object_space::MergeFrom(from._internal_space());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void database_key::CopyFrom(const database_key& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:koinos.chain.database_key)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool database_key::IsInitialized() const {
  return true;
}

void database_key::InternalSwap(database_key* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_, GetArenaForAllocation(),
      &other->key_, other->GetArenaForAllocation()
  );
  swap(space_, other->space_);
}

::PROTOBUF_NAMESPACE_ID::Metadata database_key::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_koinos_2fchain_2fchain_2eproto_getter, &descriptor_table_koinos_2fchain_2fchain_2eproto_once,
      file_level_metadata_koinos_2fchain_2fchain_2eproto[3]);
}

// ===================================================================

class max_account_resources::_Internal {
 public:
};

max_account_resources::max_account_resources(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:koinos.chain.max_account_resources)
}
max_account_resources::max_account_resources(const max_account_resources& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  value_ = from.value_;
  // @@protoc_insertion_point(copy_constructor:koinos.chain.max_account_resources)
}

inline void max_account_resources::SharedCtor() {
value_ = uint64_t{0u};
}

max_account_resources::~max_account_resources() {
  // @@protoc_insertion_point(destructor:koinos.chain.max_account_resources)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void max_account_resources::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void max_account_resources::ArenaDtor(void* object) {
  max_account_resources* _this = reinterpret_cast< max_account_resources* >(object);
  (void)_this;
}
void max_account_resources::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void max_account_resources::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void max_account_resources::Clear() {
// @@protoc_insertion_point(message_clear_start:koinos.chain.max_account_resources)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  value_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* max_account_resources::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 value = 1 [jstype = JS_STRING];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* max_account_resources::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:koinos.chain.max_account_resources)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 value = 1 [jstype = JS_STRING];
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:koinos.chain.max_account_resources)
  return target;
}

size_t max_account_resources::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:koinos.chain.max_account_resources)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 value = 1 [jstype = JS_STRING];
  if (this->_internal_value() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_value());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData max_account_resources::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    max_account_resources::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*max_account_resources::GetClassData() const { return &_class_data_; }

void max_account_resources::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<max_account_resources *>(to)->MergeFrom(
      static_cast<const max_account_resources &>(from));
}


void max_account_resources::MergeFrom(const max_account_resources& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:koinos.chain.max_account_resources)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _internal_set_value(from._internal_value());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void max_account_resources::CopyFrom(const max_account_resources& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:koinos.chain.max_account_resources)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool max_account_resources::IsInitialized() const {
  return true;
}

void max_account_resources::InternalSwap(max_account_resources* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(value_, other->value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata max_account_resources::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_koinos_2fchain_2fchain_2eproto_getter, &descriptor_table_koinos_2fchain_2fchain_2eproto_once,
      file_level_metadata_koinos_2fchain_2fchain_2eproto[4]);
}

// ===================================================================

class head_info::_Internal {
 public:
  static const ::koinos::block_topology& head_topology(const head_info* msg);
};

const ::koinos::block_topology&
head_info::_Internal::head_topology(const head_info* msg) {
  return *msg->head_topology_;
}
void head_info::clear_head_topology() {
  if (GetArenaForAllocation() == nullptr && head_topology_ != nullptr) {
    delete head_topology_;
  }
  head_topology_ = nullptr;
}
head_info::head_info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:koinos.chain.head_info)
}
head_info::head_info(const head_info& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_head_topology()) {
    head_topology_ = new ::koinos::block_topology(*from.head_topology_);
  } else {
    head_topology_ = nullptr;
  }
  ::memcpy(&head_block_time_, &from.head_block_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&last_irreversible_block_) -
    reinterpret_cast<char*>(&head_block_time_)) + sizeof(last_irreversible_block_));
  // @@protoc_insertion_point(copy_constructor:koinos.chain.head_info)
}

inline void head_info::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&head_topology_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&last_irreversible_block_) -
    reinterpret_cast<char*>(&head_topology_)) + sizeof(last_irreversible_block_));
}

head_info::~head_info() {
  // @@protoc_insertion_point(destructor:koinos.chain.head_info)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void head_info::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete head_topology_;
}

void head_info::ArenaDtor(void* object) {
  head_info* _this = reinterpret_cast< head_info* >(object);
  (void)_this;
}
void head_info::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void head_info::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void head_info::Clear() {
// @@protoc_insertion_point(message_clear_start:koinos.chain.head_info)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && head_topology_ != nullptr) {
    delete head_topology_;
  }
  head_topology_ = nullptr;
  ::memset(&head_block_time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&last_irreversible_block_) -
      reinterpret_cast<char*>(&head_block_time_)) + sizeof(last_irreversible_block_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* head_info::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .koinos.block_topology head_topology = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_head_topology(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 head_block_time = 2 [jstype = JS_STRING];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          head_block_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 last_irreversible_block = 3 [jstype = JS_STRING];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          last_irreversible_block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* head_info::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:koinos.chain.head_info)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .koinos.block_topology head_topology = 1;
  if (this->_internal_has_head_topology()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::head_topology(this), target, stream);
  }

  // uint64 head_block_time = 2 [jstype = JS_STRING];
  if (this->_internal_head_block_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_head_block_time(), target);
  }

  // uint64 last_irreversible_block = 3 [jstype = JS_STRING];
  if (this->_internal_last_irreversible_block() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_last_irreversible_block(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:koinos.chain.head_info)
  return target;
}

size_t head_info::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:koinos.chain.head_info)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .koinos.block_topology head_topology = 1;
  if (this->_internal_has_head_topology()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *head_topology_);
  }

  // uint64 head_block_time = 2 [jstype = JS_STRING];
  if (this->_internal_head_block_time() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_head_block_time());
  }

  // uint64 last_irreversible_block = 3 [jstype = JS_STRING];
  if (this->_internal_last_irreversible_block() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_last_irreversible_block());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData head_info::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    head_info::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*head_info::GetClassData() const { return &_class_data_; }

void head_info::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<head_info *>(to)->MergeFrom(
      static_cast<const head_info &>(from));
}


void head_info::MergeFrom(const head_info& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:koinos.chain.head_info)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_head_topology()) {
    _internal_mutable_head_topology()->::koinos::block_topology::MergeFrom(from._internal_head_topology());
  }
  if (from._internal_head_block_time() != 0) {
    _internal_set_head_block_time(from._internal_head_block_time());
  }
  if (from._internal_last_irreversible_block() != 0) {
    _internal_set_last_irreversible_block(from._internal_last_irreversible_block());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void head_info::CopyFrom(const head_info& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:koinos.chain.head_info)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool head_info::IsInitialized() const {
  return true;
}

void head_info::InternalSwap(head_info* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(head_info, last_irreversible_block_)
      + sizeof(head_info::last_irreversible_block_)
      - PROTOBUF_FIELD_OFFSET(head_info, head_topology_)>(
          reinterpret_cast<char*>(&head_topology_),
          reinterpret_cast<char*>(&other->head_topology_));
}

::PROTOBUF_NAMESPACE_ID::Metadata head_info::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_koinos_2fchain_2fchain_2eproto_getter, &descriptor_table_koinos_2fchain_2fchain_2eproto_once,
      file_level_metadata_koinos_2fchain_2fchain_2eproto[5]);
}

// ===================================================================

class caller_data::_Internal {
 public:
};

caller_data::caller_data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:koinos.chain.caller_data)
}
caller_data::caller_data(const caller_data& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  caller_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_caller().empty()) {
    caller_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_caller(), 
      GetArenaForAllocation());
  }
  caller_privilege_ = from.caller_privilege_;
  // @@protoc_insertion_point(copy_constructor:koinos.chain.caller_data)
}

inline void caller_data::SharedCtor() {
caller_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
caller_privilege_ = 0;
}

caller_data::~caller_data() {
  // @@protoc_insertion_point(destructor:koinos.chain.caller_data)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void caller_data::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  caller_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void caller_data::ArenaDtor(void* object) {
  caller_data* _this = reinterpret_cast< caller_data* >(object);
  (void)_this;
}
void caller_data::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void caller_data::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void caller_data::Clear() {
// @@protoc_insertion_point(message_clear_start:koinos.chain.caller_data)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  caller_.ClearToEmpty();
  caller_privilege_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* caller_data::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes caller = 1 [(.koinos.btype) = ADDRESS];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_caller();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .koinos.chain.privilege caller_privilege = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_caller_privilege(static_cast<::koinos::chain::privilege>(val));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* caller_data::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:koinos.chain.caller_data)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes caller = 1 [(.koinos.btype) = ADDRESS];
  if (!this->_internal_caller().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_caller(), target);
  }

  // .koinos.chain.privilege caller_privilege = 2;
  if (this->_internal_caller_privilege() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_caller_privilege(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:koinos.chain.caller_data)
  return target;
}

size_t caller_data::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:koinos.chain.caller_data)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes caller = 1 [(.koinos.btype) = ADDRESS];
  if (!this->_internal_caller().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_caller());
  }

  // .koinos.chain.privilege caller_privilege = 2;
  if (this->_internal_caller_privilege() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_caller_privilege());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData caller_data::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    caller_data::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*caller_data::GetClassData() const { return &_class_data_; }

void caller_data::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<caller_data *>(to)->MergeFrom(
      static_cast<const caller_data &>(from));
}


void caller_data::MergeFrom(const caller_data& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:koinos.chain.caller_data)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_caller().empty()) {
    _internal_set_caller(from._internal_caller());
  }
  if (from._internal_caller_privilege() != 0) {
    _internal_set_caller_privilege(from._internal_caller_privilege());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void caller_data::CopyFrom(const caller_data& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:koinos.chain.caller_data)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool caller_data::IsInitialized() const {
  return true;
}

void caller_data::InternalSwap(caller_data* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &caller_, GetArenaForAllocation(),
      &other->caller_, other->GetArenaForAllocation()
  );
  swap(caller_privilege_, other->caller_privilege_);
}

::PROTOBUF_NAMESPACE_ID::Metadata caller_data::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_koinos_2fchain_2fchain_2eproto_getter, &descriptor_table_koinos_2fchain_2fchain_2eproto_once,
      file_level_metadata_koinos_2fchain_2fchain_2eproto[6]);
}

// ===================================================================

class argument_data::_Internal {
 public:
};

argument_data::argument_data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:koinos.chain.argument_data)
}
argument_data::argument_data(const argument_data& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  arguments_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_arguments().empty()) {
    arguments_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_arguments(), 
      GetArenaForAllocation());
  }
  entry_point_ = from.entry_point_;
  // @@protoc_insertion_point(copy_constructor:koinos.chain.argument_data)
}

inline void argument_data::SharedCtor() {
arguments_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
entry_point_ = 0u;
}

argument_data::~argument_data() {
  // @@protoc_insertion_point(destructor:koinos.chain.argument_data)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void argument_data::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  arguments_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void argument_data::ArenaDtor(void* object) {
  argument_data* _this = reinterpret_cast< argument_data* >(object);
  (void)_this;
}
void argument_data::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void argument_data::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void argument_data::Clear() {
// @@protoc_insertion_point(message_clear_start:koinos.chain.argument_data)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  arguments_.ClearToEmpty();
  entry_point_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* argument_data::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 entry_point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          entry_point_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bytes arguments = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_arguments();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* argument_data::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:koinos.chain.argument_data)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 entry_point = 1;
  if (this->_internal_entry_point() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_entry_point(), target);
  }

  // bytes arguments = 2;
  if (!this->_internal_arguments().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_arguments(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:koinos.chain.argument_data)
  return target;
}

size_t argument_data::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:koinos.chain.argument_data)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes arguments = 2;
  if (!this->_internal_arguments().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_arguments());
  }

  // uint32 entry_point = 1;
  if (this->_internal_entry_point() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_entry_point());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData argument_data::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    argument_data::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*argument_data::GetClassData() const { return &_class_data_; }

void argument_data::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<argument_data *>(to)->MergeFrom(
      static_cast<const argument_data &>(from));
}


void argument_data::MergeFrom(const argument_data& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:koinos.chain.argument_data)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_arguments().empty()) {
    _internal_set_arguments(from._internal_arguments());
  }
  if (from._internal_entry_point() != 0) {
    _internal_set_entry_point(from._internal_entry_point());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void argument_data::CopyFrom(const argument_data& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:koinos.chain.argument_data)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool argument_data::IsInitialized() const {
  return true;
}

void argument_data::InternalSwap(argument_data* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &arguments_, GetArenaForAllocation(),
      &other->arguments_, other->GetArenaForAllocation()
  );
  swap(entry_point_, other->entry_point_);
}

::PROTOBUF_NAMESPACE_ID::Metadata argument_data::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_koinos_2fchain_2fchain_2eproto_getter, &descriptor_table_koinos_2fchain_2fchain_2eproto_once,
      file_level_metadata_koinos_2fchain_2fchain_2eproto[7]);
}

// ===================================================================

class resource_limit_data::_Internal {
 public:
};

resource_limit_data::resource_limit_data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:koinos.chain.resource_limit_data)
}
resource_limit_data::resource_limit_data(const resource_limit_data& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&disk_storage_limit_, &from.disk_storage_limit_,
    static_cast<size_t>(reinterpret_cast<char*>(&compute_bandwidth_cost_) -
    reinterpret_cast<char*>(&disk_storage_limit_)) + sizeof(compute_bandwidth_cost_));
  // @@protoc_insertion_point(copy_constructor:koinos.chain.resource_limit_data)
}

inline void resource_limit_data::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&disk_storage_limit_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&compute_bandwidth_cost_) -
    reinterpret_cast<char*>(&disk_storage_limit_)) + sizeof(compute_bandwidth_cost_));
}

resource_limit_data::~resource_limit_data() {
  // @@protoc_insertion_point(destructor:koinos.chain.resource_limit_data)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void resource_limit_data::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void resource_limit_data::ArenaDtor(void* object) {
  resource_limit_data* _this = reinterpret_cast< resource_limit_data* >(object);
  (void)_this;
}
void resource_limit_data::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void resource_limit_data::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void resource_limit_data::Clear() {
// @@protoc_insertion_point(message_clear_start:koinos.chain.resource_limit_data)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&disk_storage_limit_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&compute_bandwidth_cost_) -
      reinterpret_cast<char*>(&disk_storage_limit_)) + sizeof(compute_bandwidth_cost_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* resource_limit_data::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 disk_storage_limit = 1 [jstype = JS_STRING];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          disk_storage_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 disk_storage_cost = 2 [jstype = JS_STRING];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          disk_storage_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 network_bandwidth_limit = 3 [jstype = JS_STRING];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          network_bandwidth_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 network_bandwidth_cost = 4 [jstype = JS_STRING];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          network_bandwidth_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 compute_bandwidth_limit = 5 [jstype = JS_STRING];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          compute_bandwidth_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 compute_bandwidth_cost = 6 [jstype = JS_STRING];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          compute_bandwidth_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* resource_limit_data::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:koinos.chain.resource_limit_data)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 disk_storage_limit = 1 [jstype = JS_STRING];
  if (this->_internal_disk_storage_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_disk_storage_limit(), target);
  }

  // uint64 disk_storage_cost = 2 [jstype = JS_STRING];
  if (this->_internal_disk_storage_cost() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_disk_storage_cost(), target);
  }

  // uint64 network_bandwidth_limit = 3 [jstype = JS_STRING];
  if (this->_internal_network_bandwidth_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_network_bandwidth_limit(), target);
  }

  // uint64 network_bandwidth_cost = 4 [jstype = JS_STRING];
  if (this->_internal_network_bandwidth_cost() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_network_bandwidth_cost(), target);
  }

  // uint64 compute_bandwidth_limit = 5 [jstype = JS_STRING];
  if (this->_internal_compute_bandwidth_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_compute_bandwidth_limit(), target);
  }

  // uint64 compute_bandwidth_cost = 6 [jstype = JS_STRING];
  if (this->_internal_compute_bandwidth_cost() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_compute_bandwidth_cost(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:koinos.chain.resource_limit_data)
  return target;
}

size_t resource_limit_data::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:koinos.chain.resource_limit_data)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 disk_storage_limit = 1 [jstype = JS_STRING];
  if (this->_internal_disk_storage_limit() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_disk_storage_limit());
  }

  // uint64 disk_storage_cost = 2 [jstype = JS_STRING];
  if (this->_internal_disk_storage_cost() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_disk_storage_cost());
  }

  // uint64 network_bandwidth_limit = 3 [jstype = JS_STRING];
  if (this->_internal_network_bandwidth_limit() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_network_bandwidth_limit());
  }

  // uint64 network_bandwidth_cost = 4 [jstype = JS_STRING];
  if (this->_internal_network_bandwidth_cost() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_network_bandwidth_cost());
  }

  // uint64 compute_bandwidth_limit = 5 [jstype = JS_STRING];
  if (this->_internal_compute_bandwidth_limit() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_compute_bandwidth_limit());
  }

  // uint64 compute_bandwidth_cost = 6 [jstype = JS_STRING];
  if (this->_internal_compute_bandwidth_cost() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_compute_bandwidth_cost());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData resource_limit_data::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    resource_limit_data::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*resource_limit_data::GetClassData() const { return &_class_data_; }

void resource_limit_data::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<resource_limit_data *>(to)->MergeFrom(
      static_cast<const resource_limit_data &>(from));
}


void resource_limit_data::MergeFrom(const resource_limit_data& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:koinos.chain.resource_limit_data)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_disk_storage_limit() != 0) {
    _internal_set_disk_storage_limit(from._internal_disk_storage_limit());
  }
  if (from._internal_disk_storage_cost() != 0) {
    _internal_set_disk_storage_cost(from._internal_disk_storage_cost());
  }
  if (from._internal_network_bandwidth_limit() != 0) {
    _internal_set_network_bandwidth_limit(from._internal_network_bandwidth_limit());
  }
  if (from._internal_network_bandwidth_cost() != 0) {
    _internal_set_network_bandwidth_cost(from._internal_network_bandwidth_cost());
  }
  if (from._internal_compute_bandwidth_limit() != 0) {
    _internal_set_compute_bandwidth_limit(from._internal_compute_bandwidth_limit());
  }
  if (from._internal_compute_bandwidth_cost() != 0) {
    _internal_set_compute_bandwidth_cost(from._internal_compute_bandwidth_cost());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void resource_limit_data::CopyFrom(const resource_limit_data& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:koinos.chain.resource_limit_data)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool resource_limit_data::IsInitialized() const {
  return true;
}

void resource_limit_data::InternalSwap(resource_limit_data* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(resource_limit_data, compute_bandwidth_cost_)
      + sizeof(resource_limit_data::compute_bandwidth_cost_)
      - PROTOBUF_FIELD_OFFSET(resource_limit_data, disk_storage_limit_)>(
          reinterpret_cast<char*>(&disk_storage_limit_),
          reinterpret_cast<char*>(&other->disk_storage_limit_));
}

::PROTOBUF_NAMESPACE_ID::Metadata resource_limit_data::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_koinos_2fchain_2fchain_2eproto_getter, &descriptor_table_koinos_2fchain_2fchain_2eproto_once,
      file_level_metadata_koinos_2fchain_2fchain_2eproto[8]);
}

// ===================================================================

class contract_metadata_object::_Internal {
 public:
};

contract_metadata_object::contract_metadata_object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:koinos.chain.contract_metadata_object)
}
contract_metadata_object::contract_metadata_object(const contract_metadata_object& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_hash().empty()) {
    hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_hash(), 
      GetArenaForAllocation());
  }
  ::memcpy(&system_, &from.system_,
    static_cast<size_t>(reinterpret_cast<char*>(&authorizes_upload_contract_) -
    reinterpret_cast<char*>(&system_)) + sizeof(authorizes_upload_contract_));
  // @@protoc_insertion_point(copy_constructor:koinos.chain.contract_metadata_object)
}

inline void contract_metadata_object::SharedCtor() {
hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&system_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&authorizes_upload_contract_) -
    reinterpret_cast<char*>(&system_)) + sizeof(authorizes_upload_contract_));
}

contract_metadata_object::~contract_metadata_object() {
  // @@protoc_insertion_point(destructor:koinos.chain.contract_metadata_object)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void contract_metadata_object::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void contract_metadata_object::ArenaDtor(void* object) {
  contract_metadata_object* _this = reinterpret_cast< contract_metadata_object* >(object);
  (void)_this;
}
void contract_metadata_object::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void contract_metadata_object::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void contract_metadata_object::Clear() {
// @@protoc_insertion_point(message_clear_start:koinos.chain.contract_metadata_object)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  hash_.ClearToEmpty();
  ::memset(&system_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&authorizes_upload_contract_) -
      reinterpret_cast<char*>(&system_)) + sizeof(authorizes_upload_contract_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* contract_metadata_object::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_hash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool system = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          system_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool authorizes_call_contract = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          authorizes_call_contract_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool authorizes_transaction_application = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          authorizes_transaction_application_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool authorizes_upload_contract = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          authorizes_upload_contract_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* contract_metadata_object::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:koinos.chain.contract_metadata_object)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes hash = 1;
  if (!this->_internal_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_hash(), target);
  }

  // bool system = 2;
  if (this->_internal_system() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_system(), target);
  }

  // bool authorizes_call_contract = 3;
  if (this->_internal_authorizes_call_contract() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_authorizes_call_contract(), target);
  }

  // bool authorizes_transaction_application = 4;
  if (this->_internal_authorizes_transaction_application() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_authorizes_transaction_application(), target);
  }

  // bool authorizes_upload_contract = 5;
  if (this->_internal_authorizes_upload_contract() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_authorizes_upload_contract(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:koinos.chain.contract_metadata_object)
  return target;
}

size_t contract_metadata_object::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:koinos.chain.contract_metadata_object)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes hash = 1;
  if (!this->_internal_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_hash());
  }

  // bool system = 2;
  if (this->_internal_system() != 0) {
    total_size += 1 + 1;
  }

  // bool authorizes_call_contract = 3;
  if (this->_internal_authorizes_call_contract() != 0) {
    total_size += 1 + 1;
  }

  // bool authorizes_transaction_application = 4;
  if (this->_internal_authorizes_transaction_application() != 0) {
    total_size += 1 + 1;
  }

  // bool authorizes_upload_contract = 5;
  if (this->_internal_authorizes_upload_contract() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData contract_metadata_object::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    contract_metadata_object::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*contract_metadata_object::GetClassData() const { return &_class_data_; }

void contract_metadata_object::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<contract_metadata_object *>(to)->MergeFrom(
      static_cast<const contract_metadata_object &>(from));
}


void contract_metadata_object::MergeFrom(const contract_metadata_object& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:koinos.chain.contract_metadata_object)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_hash().empty()) {
    _internal_set_hash(from._internal_hash());
  }
  if (from._internal_system() != 0) {
    _internal_set_system(from._internal_system());
  }
  if (from._internal_authorizes_call_contract() != 0) {
    _internal_set_authorizes_call_contract(from._internal_authorizes_call_contract());
  }
  if (from._internal_authorizes_transaction_application() != 0) {
    _internal_set_authorizes_transaction_application(from._internal_authorizes_transaction_application());
  }
  if (from._internal_authorizes_upload_contract() != 0) {
    _internal_set_authorizes_upload_contract(from._internal_authorizes_upload_contract());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void contract_metadata_object::CopyFrom(const contract_metadata_object& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:koinos.chain.contract_metadata_object)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool contract_metadata_object::IsInitialized() const {
  return true;
}

void contract_metadata_object::InternalSwap(contract_metadata_object* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &hash_, GetArenaForAllocation(),
      &other->hash_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(contract_metadata_object, authorizes_upload_contract_)
      + sizeof(contract_metadata_object::authorizes_upload_contract_)
      - PROTOBUF_FIELD_OFFSET(contract_metadata_object, system_)>(
          reinterpret_cast<char*>(&system_),
          reinterpret_cast<char*>(&other->system_));
}

::PROTOBUF_NAMESPACE_ID::Metadata contract_metadata_object::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_koinos_2fchain_2fchain_2eproto_getter, &descriptor_table_koinos_2fchain_2fchain_2eproto_once,
      file_level_metadata_koinos_2fchain_2fchain_2eproto[9]);
}

// ===================================================================

class compute_bandwidth_entry::_Internal {
 public:
};

compute_bandwidth_entry::compute_bandwidth_entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:koinos.chain.compute_bandwidth_entry)
}
compute_bandwidth_entry::compute_bandwidth_entry(const compute_bandwidth_entry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  compute_ = from.compute_;
  // @@protoc_insertion_point(copy_constructor:koinos.chain.compute_bandwidth_entry)
}

inline void compute_bandwidth_entry::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
compute_ = uint64_t{0u};
}

compute_bandwidth_entry::~compute_bandwidth_entry() {
  // @@protoc_insertion_point(destructor:koinos.chain.compute_bandwidth_entry)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void compute_bandwidth_entry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void compute_bandwidth_entry::ArenaDtor(void* object) {
  compute_bandwidth_entry* _this = reinterpret_cast< compute_bandwidth_entry* >(object);
  (void)_this;
}
void compute_bandwidth_entry::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void compute_bandwidth_entry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void compute_bandwidth_entry::Clear() {
// @@protoc_insertion_point(message_clear_start:koinos.chain.compute_bandwidth_entry)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  compute_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* compute_bandwidth_entry::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "koinos.chain.compute_bandwidth_entry.name"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 compute = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          compute_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* compute_bandwidth_entry::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:koinos.chain.compute_bandwidth_entry)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "koinos.chain.compute_bandwidth_entry.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // uint64 compute = 2;
  if (this->_internal_compute() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_compute(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:koinos.chain.compute_bandwidth_entry)
  return target;
}

size_t compute_bandwidth_entry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:koinos.chain.compute_bandwidth_entry)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // uint64 compute = 2;
  if (this->_internal_compute() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_compute());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData compute_bandwidth_entry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    compute_bandwidth_entry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*compute_bandwidth_entry::GetClassData() const { return &_class_data_; }

void compute_bandwidth_entry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<compute_bandwidth_entry *>(to)->MergeFrom(
      static_cast<const compute_bandwidth_entry &>(from));
}


void compute_bandwidth_entry::MergeFrom(const compute_bandwidth_entry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:koinos.chain.compute_bandwidth_entry)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_compute() != 0) {
    _internal_set_compute(from._internal_compute());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void compute_bandwidth_entry::CopyFrom(const compute_bandwidth_entry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:koinos.chain.compute_bandwidth_entry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool compute_bandwidth_entry::IsInitialized() const {
  return true;
}

void compute_bandwidth_entry::InternalSwap(compute_bandwidth_entry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, GetArenaForAllocation(),
      &other->name_, other->GetArenaForAllocation()
  );
  swap(compute_, other->compute_);
}

::PROTOBUF_NAMESPACE_ID::Metadata compute_bandwidth_entry::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_koinos_2fchain_2fchain_2eproto_getter, &descriptor_table_koinos_2fchain_2fchain_2eproto_once,
      file_level_metadata_koinos_2fchain_2fchain_2eproto[10]);
}

// ===================================================================

class compute_bandwidth_registry::_Internal {
 public:
};

compute_bandwidth_registry::compute_bandwidth_registry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  entries_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:koinos.chain.compute_bandwidth_registry)
}
compute_bandwidth_registry::compute_bandwidth_registry(const compute_bandwidth_registry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      entries_(from.entries_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:koinos.chain.compute_bandwidth_registry)
}

inline void compute_bandwidth_registry::SharedCtor() {
}

compute_bandwidth_registry::~compute_bandwidth_registry() {
  // @@protoc_insertion_point(destructor:koinos.chain.compute_bandwidth_registry)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void compute_bandwidth_registry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void compute_bandwidth_registry::ArenaDtor(void* object) {
  compute_bandwidth_registry* _this = reinterpret_cast< compute_bandwidth_registry* >(object);
  (void)_this;
}
void compute_bandwidth_registry::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void compute_bandwidth_registry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void compute_bandwidth_registry::Clear() {
// @@protoc_insertion_point(message_clear_start:koinos.chain.compute_bandwidth_registry)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entries_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* compute_bandwidth_registry::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .koinos.chain.compute_bandwidth_entry entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* compute_bandwidth_registry::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:koinos.chain.compute_bandwidth_registry)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .koinos.chain.compute_bandwidth_entry entries = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_entries_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_entries(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:koinos.chain.compute_bandwidth_registry)
  return target;
}

size_t compute_bandwidth_registry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:koinos.chain.compute_bandwidth_registry)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .koinos.chain.compute_bandwidth_entry entries = 1;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData compute_bandwidth_registry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    compute_bandwidth_registry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*compute_bandwidth_registry::GetClassData() const { return &_class_data_; }

void compute_bandwidth_registry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<compute_bandwidth_registry *>(to)->MergeFrom(
      static_cast<const compute_bandwidth_registry &>(from));
}


void compute_bandwidth_registry::MergeFrom(const compute_bandwidth_registry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:koinos.chain.compute_bandwidth_registry)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  entries_.MergeFrom(from.entries_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void compute_bandwidth_registry::CopyFrom(const compute_bandwidth_registry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:koinos.chain.compute_bandwidth_registry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool compute_bandwidth_registry::IsInitialized() const {
  return true;
}

void compute_bandwidth_registry::InternalSwap(compute_bandwidth_registry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  entries_.InternalSwap(&other->entries_);
}

::PROTOBUF_NAMESPACE_ID::Metadata compute_bandwidth_registry::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_koinos_2fchain_2fchain_2eproto_getter, &descriptor_table_koinos_2fchain_2fchain_2eproto_once,
      file_level_metadata_koinos_2fchain_2fchain_2eproto[11]);
}

// ===================================================================

class genesis_entry::_Internal {
 public:
  static const ::koinos::chain::object_space& space(const genesis_entry* msg);
};

const ::koinos::chain::object_space&
genesis_entry::_Internal::space(const genesis_entry* msg) {
  return *msg->space_;
}
genesis_entry::genesis_entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:koinos.chain.genesis_entry)
}
genesis_entry::genesis_entry(const genesis_entry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_key().empty()) {
    key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key(), 
      GetArenaForAllocation());
  }
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_value().empty()) {
    value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_value(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_space()) {
    space_ = new ::koinos::chain::object_space(*from.space_);
  } else {
    space_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:koinos.chain.genesis_entry)
}

inline void genesis_entry::SharedCtor() {
key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
space_ = nullptr;
}

genesis_entry::~genesis_entry() {
  // @@protoc_insertion_point(destructor:koinos.chain.genesis_entry)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void genesis_entry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete space_;
}

void genesis_entry::ArenaDtor(void* object) {
  genesis_entry* _this = reinterpret_cast< genesis_entry* >(object);
  (void)_this;
}
void genesis_entry::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void genesis_entry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void genesis_entry::Clear() {
// @@protoc_insertion_point(message_clear_start:koinos.chain.genesis_entry)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  key_.ClearToEmpty();
  value_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && space_ != nullptr) {
    delete space_;
  }
  space_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* genesis_entry::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .koinos.chain.object_space space = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_space(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bytes key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bytes value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* genesis_entry::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:koinos.chain.genesis_entry)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .koinos.chain.object_space space = 1;
  if (this->_internal_has_space()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::space(this), target, stream);
  }

  // bytes key = 2;
  if (!this->_internal_key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_key(), target);
  }

  // bytes value = 3;
  if (!this->_internal_value().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:koinos.chain.genesis_entry)
  return target;
}

size_t genesis_entry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:koinos.chain.genesis_entry)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes key = 2;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());
  }

  // bytes value = 3;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_value());
  }

  // .koinos.chain.object_space space = 1;
  if (this->_internal_has_space()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *space_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData genesis_entry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    genesis_entry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*genesis_entry::GetClassData() const { return &_class_data_; }

void genesis_entry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<genesis_entry *>(to)->MergeFrom(
      static_cast<const genesis_entry &>(from));
}


void genesis_entry::MergeFrom(const genesis_entry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:koinos.chain.genesis_entry)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _internal_set_key(from._internal_key());
  }
  if (!from._internal_value().empty()) {
    _internal_set_value(from._internal_value());
  }
  if (from._internal_has_space()) {
    _internal_mutable_space()->::koinos::chain::object_space::MergeFrom(from._internal_space());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void genesis_entry::CopyFrom(const genesis_entry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:koinos.chain.genesis_entry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool genesis_entry::IsInitialized() const {
  return true;
}

void genesis_entry::InternalSwap(genesis_entry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_, GetArenaForAllocation(),
      &other->key_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &value_, GetArenaForAllocation(),
      &other->value_, other->GetArenaForAllocation()
  );
  swap(space_, other->space_);
}

::PROTOBUF_NAMESPACE_ID::Metadata genesis_entry::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_koinos_2fchain_2fchain_2eproto_getter, &descriptor_table_koinos_2fchain_2fchain_2eproto_once,
      file_level_metadata_koinos_2fchain_2fchain_2eproto[12]);
}

// ===================================================================

class genesis_data::_Internal {
 public:
};

genesis_data::genesis_data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  entries_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:koinos.chain.genesis_data)
}
genesis_data::genesis_data(const genesis_data& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      entries_(from.entries_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:koinos.chain.genesis_data)
}

inline void genesis_data::SharedCtor() {
}

genesis_data::~genesis_data() {
  // @@protoc_insertion_point(destructor:koinos.chain.genesis_data)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void genesis_data::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void genesis_data::ArenaDtor(void* object) {
  genesis_data* _this = reinterpret_cast< genesis_data* >(object);
  (void)_this;
}
void genesis_data::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void genesis_data::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void genesis_data::Clear() {
// @@protoc_insertion_point(message_clear_start:koinos.chain.genesis_data)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entries_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* genesis_data::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .koinos.chain.genesis_entry entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* genesis_data::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:koinos.chain.genesis_data)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .koinos.chain.genesis_entry entries = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_entries_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_entries(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:koinos.chain.genesis_data)
  return target;
}

size_t genesis_data::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:koinos.chain.genesis_data)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .koinos.chain.genesis_entry entries = 1;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData genesis_data::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    genesis_data::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*genesis_data::GetClassData() const { return &_class_data_; }

void genesis_data::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<genesis_data *>(to)->MergeFrom(
      static_cast<const genesis_data &>(from));
}


void genesis_data::MergeFrom(const genesis_data& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:koinos.chain.genesis_data)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  entries_.MergeFrom(from.entries_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void genesis_data::CopyFrom(const genesis_data& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:koinos.chain.genesis_data)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool genesis_data::IsInitialized() const {
  return true;
}

void genesis_data::InternalSwap(genesis_data* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  entries_.InternalSwap(&other->entries_);
}

::PROTOBUF_NAMESPACE_ID::Metadata genesis_data::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_koinos_2fchain_2fchain_2eproto_getter, &descriptor_table_koinos_2fchain_2fchain_2eproto_once,
      file_level_metadata_koinos_2fchain_2fchain_2eproto[13]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace chain
}  // namespace koinos
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::koinos::chain::error_data* Arena::CreateMaybeMessage< ::koinos::chain::error_data >(Arena* arena) {
  return Arena::CreateMessageInternal< ::koinos::chain::error_data >(arena);
}
template<> PROTOBUF_NOINLINE ::koinos::chain::result* Arena::CreateMaybeMessage< ::koinos::chain::result >(Arena* arena) {
  return Arena::CreateMessageInternal< ::koinos::chain::result >(arena);
}
template<> PROTOBUF_NOINLINE ::koinos::chain::object_space* Arena::CreateMaybeMessage< ::koinos::chain::object_space >(Arena* arena) {
  return Arena::CreateMessageInternal< ::koinos::chain::object_space >(arena);
}
template<> PROTOBUF_NOINLINE ::koinos::chain::database_key* Arena::CreateMaybeMessage< ::koinos::chain::database_key >(Arena* arena) {
  return Arena::CreateMessageInternal< ::koinos::chain::database_key >(arena);
}
template<> PROTOBUF_NOINLINE ::koinos::chain::max_account_resources* Arena::CreateMaybeMessage< ::koinos::chain::max_account_resources >(Arena* arena) {
  return Arena::CreateMessageInternal< ::koinos::chain::max_account_resources >(arena);
}
template<> PROTOBUF_NOINLINE ::koinos::chain::head_info* Arena::CreateMaybeMessage< ::koinos::chain::head_info >(Arena* arena) {
  return Arena::CreateMessageInternal< ::koinos::chain::head_info >(arena);
}
template<> PROTOBUF_NOINLINE ::koinos::chain::caller_data* Arena::CreateMaybeMessage< ::koinos::chain::caller_data >(Arena* arena) {
  return Arena::CreateMessageInternal< ::koinos::chain::caller_data >(arena);
}
template<> PROTOBUF_NOINLINE ::koinos::chain::argument_data* Arena::CreateMaybeMessage< ::koinos::chain::argument_data >(Arena* arena) {
  return Arena::CreateMessageInternal< ::koinos::chain::argument_data >(arena);
}
template<> PROTOBUF_NOINLINE ::koinos::chain::resource_limit_data* Arena::CreateMaybeMessage< ::koinos::chain::resource_limit_data >(Arena* arena) {
  return Arena::CreateMessageInternal< ::koinos::chain::resource_limit_data >(arena);
}
template<> PROTOBUF_NOINLINE ::koinos::chain::contract_metadata_object* Arena::CreateMaybeMessage< ::koinos::chain::contract_metadata_object >(Arena* arena) {
  return Arena::CreateMessageInternal< ::koinos::chain::contract_metadata_object >(arena);
}
template<> PROTOBUF_NOINLINE ::koinos::chain::compute_bandwidth_entry* Arena::CreateMaybeMessage< ::koinos::chain::compute_bandwidth_entry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::koinos::chain::compute_bandwidth_entry >(arena);
}
template<> PROTOBUF_NOINLINE ::koinos::chain::compute_bandwidth_registry* Arena::CreateMaybeMessage< ::koinos::chain::compute_bandwidth_registry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::koinos::chain::compute_bandwidth_registry >(arena);
}
template<> PROTOBUF_NOINLINE ::koinos::chain::genesis_entry* Arena::CreateMaybeMessage< ::koinos::chain::genesis_entry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::koinos::chain::genesis_entry >(arena);
}
template<> PROTOBUF_NOINLINE ::koinos::chain::genesis_data* Arena::CreateMaybeMessage< ::koinos::chain::genesis_data >(Arena* arena) {
  return Arena::CreateMessageInternal< ::koinos::chain::genesis_data >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
