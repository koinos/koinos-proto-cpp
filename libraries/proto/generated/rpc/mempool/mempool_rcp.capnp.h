// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: mempool_rcp.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 8000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "../../protocol/protocol.capnp.h"
#include "../rpc.capnp.h"

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(e308cfcad1d2a029);
CAPNP_DECLARE_SCHEMA(c797e21ceb4b22dd);
CAPNP_DECLARE_SCHEMA(ff4847a1cca6dda0);
CAPNP_DECLARE_SCHEMA(ca8abc89f18ff6cb);
CAPNP_DECLARE_SCHEMA(b114df104ffb0bd3);
CAPNP_DECLARE_SCHEMA(92a2408b299d3477);
CAPNP_DECLARE_SCHEMA(f48b72eeabe033a4);
CAPNP_DECLARE_SCHEMA(9648a61c8170654b);

}  // namespace schemas
}  // namespace capnp

namespace koinos {
namespace rpc {
namespace mempool {

struct MempoolReservedRequest {
  MempoolReservedRequest() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e308cfcad1d2a029, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CheckPendingAccountResourcesRequest {
  CheckPendingAccountResourcesRequest() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c797e21ceb4b22dd, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GetPendingTransactionsRequest {
  GetPendingTransactionsRequest() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ff4847a1cca6dda0, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MempoolRPCRequest {
  MempoolRPCRequest() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    MEMPOOL_RESERVED,
    CHECK_PENDING_ACCOUNT_RESOURCES,
    GET_PENDING_TRANSACTIONS,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ca8abc89f18ff6cb, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MempoolReservedResponse {
  MempoolReservedResponse() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b114df104ffb0bd3, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CheckPendingAccountResourcesResponse {
  CheckPendingAccountResourcesResponse() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(92a2408b299d3477, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GetPendingTransctionsResponse {
  GetPendingTransctionsResponse() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f48b72eeabe033a4, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MempoolRPCResponse {
  MempoolRPCResponse() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    MEMPOOL_RESERVED,
    MEMPOOL_ERROR,
    CHECK_PENDING_ACCOUNT_RESOURCES,
    GET_PENDING_TRANSACTIONS,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9648a61c8170654b, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class MempoolReservedRequest::Reader {
public:
  typedef MempoolReservedRequest Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MempoolReservedRequest::Builder {
public:
  typedef MempoolReservedRequest Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MempoolReservedRequest::Pipeline {
public:
  typedef MempoolReservedRequest Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CheckPendingAccountResourcesRequest::Reader {
public:
  typedef CheckPendingAccountResourcesRequest Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPayer() const;
  inline  ::capnp::Data::Reader getPayer() const;

  inline  ::uint64_t getMaxPayerResources() const;

  inline  ::uint64_t getTrxResourceLimit() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CheckPendingAccountResourcesRequest::Builder {
public:
  typedef CheckPendingAccountResourcesRequest Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPayer();
  inline  ::capnp::Data::Builder getPayer();
  inline void setPayer( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initPayer(unsigned int size);
  inline void adoptPayer(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownPayer();

  inline  ::uint64_t getMaxPayerResources();
  inline void setMaxPayerResources( ::uint64_t value);

  inline  ::uint64_t getTrxResourceLimit();
  inline void setTrxResourceLimit( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CheckPendingAccountResourcesRequest::Pipeline {
public:
  typedef CheckPendingAccountResourcesRequest Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GetPendingTransactionsRequest::Reader {
public:
  typedef GetPendingTransactionsRequest Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLimit() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GetPendingTransactionsRequest::Builder {
public:
  typedef GetPendingTransactionsRequest Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLimit();
  inline void setLimit( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GetPendingTransactionsRequest::Pipeline {
public:
  typedef GetPendingTransactionsRequest Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MempoolRPCRequest::Reader {
public:
  typedef MempoolRPCRequest Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isMempoolReserved() const;
  inline bool hasMempoolReserved() const;
  inline  ::koinos::rpc::mempool::MempoolReservedRequest::Reader getMempoolReserved() const;

  inline bool isCheckPendingAccountResources() const;
  inline bool hasCheckPendingAccountResources() const;
  inline  ::koinos::rpc::mempool::CheckPendingAccountResourcesRequest::Reader getCheckPendingAccountResources() const;

  inline bool isGetPendingTransactions() const;
  inline bool hasGetPendingTransactions() const;
  inline  ::koinos::rpc::mempool::GetPendingTransactionsRequest::Reader getGetPendingTransactions() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MempoolRPCRequest::Builder {
public:
  typedef MempoolRPCRequest Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isMempoolReserved();
  inline bool hasMempoolReserved();
  inline  ::koinos::rpc::mempool::MempoolReservedRequest::Builder getMempoolReserved();
  inline void setMempoolReserved( ::koinos::rpc::mempool::MempoolReservedRequest::Reader value);
  inline  ::koinos::rpc::mempool::MempoolReservedRequest::Builder initMempoolReserved();
  inline void adoptMempoolReserved(::capnp::Orphan< ::koinos::rpc::mempool::MempoolReservedRequest>&& value);
  inline ::capnp::Orphan< ::koinos::rpc::mempool::MempoolReservedRequest> disownMempoolReserved();

  inline bool isCheckPendingAccountResources();
  inline bool hasCheckPendingAccountResources();
  inline  ::koinos::rpc::mempool::CheckPendingAccountResourcesRequest::Builder getCheckPendingAccountResources();
  inline void setCheckPendingAccountResources( ::koinos::rpc::mempool::CheckPendingAccountResourcesRequest::Reader value);
  inline  ::koinos::rpc::mempool::CheckPendingAccountResourcesRequest::Builder initCheckPendingAccountResources();
  inline void adoptCheckPendingAccountResources(::capnp::Orphan< ::koinos::rpc::mempool::CheckPendingAccountResourcesRequest>&& value);
  inline ::capnp::Orphan< ::koinos::rpc::mempool::CheckPendingAccountResourcesRequest> disownCheckPendingAccountResources();

  inline bool isGetPendingTransactions();
  inline bool hasGetPendingTransactions();
  inline  ::koinos::rpc::mempool::GetPendingTransactionsRequest::Builder getGetPendingTransactions();
  inline void setGetPendingTransactions( ::koinos::rpc::mempool::GetPendingTransactionsRequest::Reader value);
  inline  ::koinos::rpc::mempool::GetPendingTransactionsRequest::Builder initGetPendingTransactions();
  inline void adoptGetPendingTransactions(::capnp::Orphan< ::koinos::rpc::mempool::GetPendingTransactionsRequest>&& value);
  inline ::capnp::Orphan< ::koinos::rpc::mempool::GetPendingTransactionsRequest> disownGetPendingTransactions();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MempoolRPCRequest::Pipeline {
public:
  typedef MempoolRPCRequest Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MempoolReservedResponse::Reader {
public:
  typedef MempoolReservedResponse Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MempoolReservedResponse::Builder {
public:
  typedef MempoolReservedResponse Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MempoolReservedResponse::Pipeline {
public:
  typedef MempoolReservedResponse Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CheckPendingAccountResourcesResponse::Reader {
public:
  typedef CheckPendingAccountResourcesResponse Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CheckPendingAccountResourcesResponse::Builder {
public:
  typedef CheckPendingAccountResourcesResponse Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CheckPendingAccountResourcesResponse::Pipeline {
public:
  typedef CheckPendingAccountResourcesResponse Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GetPendingTransctionsResponse::Reader {
public:
  typedef GetPendingTransctionsResponse Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTransactions() const;
  inline  ::capnp::List< ::koinos::protocol::Transaction,  ::capnp::Kind::STRUCT>::Reader getTransactions() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GetPendingTransctionsResponse::Builder {
public:
  typedef GetPendingTransctionsResponse Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTransactions();
  inline  ::capnp::List< ::koinos::protocol::Transaction,  ::capnp::Kind::STRUCT>::Builder getTransactions();
  inline void setTransactions( ::capnp::List< ::koinos::protocol::Transaction,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::koinos::protocol::Transaction,  ::capnp::Kind::STRUCT>::Builder initTransactions(unsigned int size);
  inline void adoptTransactions(::capnp::Orphan< ::capnp::List< ::koinos::protocol::Transaction,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::koinos::protocol::Transaction,  ::capnp::Kind::STRUCT>> disownTransactions();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GetPendingTransctionsResponse::Pipeline {
public:
  typedef GetPendingTransctionsResponse Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MempoolRPCResponse::Reader {
public:
  typedef MempoolRPCResponse Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isMempoolReserved() const;
  inline bool hasMempoolReserved() const;
  inline  ::koinos::rpc::mempool::MempoolReservedResponse::Reader getMempoolReserved() const;

  inline bool isMempoolError() const;
  inline bool hasMempoolError() const;
  inline  ::koinos::rpc::ErrorResponse::Reader getMempoolError() const;

  inline bool isCheckPendingAccountResources() const;
  inline bool hasCheckPendingAccountResources() const;
  inline  ::koinos::rpc::mempool::CheckPendingAccountResourcesResponse::Reader getCheckPendingAccountResources() const;

  inline bool isGetPendingTransactions() const;
  inline bool hasGetPendingTransactions() const;
  inline  ::koinos::rpc::mempool::GetPendingTransctionsResponse::Reader getGetPendingTransactions() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MempoolRPCResponse::Builder {
public:
  typedef MempoolRPCResponse Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isMempoolReserved();
  inline bool hasMempoolReserved();
  inline  ::koinos::rpc::mempool::MempoolReservedResponse::Builder getMempoolReserved();
  inline void setMempoolReserved( ::koinos::rpc::mempool::MempoolReservedResponse::Reader value);
  inline  ::koinos::rpc::mempool::MempoolReservedResponse::Builder initMempoolReserved();
  inline void adoptMempoolReserved(::capnp::Orphan< ::koinos::rpc::mempool::MempoolReservedResponse>&& value);
  inline ::capnp::Orphan< ::koinos::rpc::mempool::MempoolReservedResponse> disownMempoolReserved();

  inline bool isMempoolError();
  inline bool hasMempoolError();
  inline  ::koinos::rpc::ErrorResponse::Builder getMempoolError();
  inline void setMempoolError( ::koinos::rpc::ErrorResponse::Reader value);
  inline  ::koinos::rpc::ErrorResponse::Builder initMempoolError();
  inline void adoptMempoolError(::capnp::Orphan< ::koinos::rpc::ErrorResponse>&& value);
  inline ::capnp::Orphan< ::koinos::rpc::ErrorResponse> disownMempoolError();

  inline bool isCheckPendingAccountResources();
  inline bool hasCheckPendingAccountResources();
  inline  ::koinos::rpc::mempool::CheckPendingAccountResourcesResponse::Builder getCheckPendingAccountResources();
  inline void setCheckPendingAccountResources( ::koinos::rpc::mempool::CheckPendingAccountResourcesResponse::Reader value);
  inline  ::koinos::rpc::mempool::CheckPendingAccountResourcesResponse::Builder initCheckPendingAccountResources();
  inline void adoptCheckPendingAccountResources(::capnp::Orphan< ::koinos::rpc::mempool::CheckPendingAccountResourcesResponse>&& value);
  inline ::capnp::Orphan< ::koinos::rpc::mempool::CheckPendingAccountResourcesResponse> disownCheckPendingAccountResources();

  inline bool isGetPendingTransactions();
  inline bool hasGetPendingTransactions();
  inline  ::koinos::rpc::mempool::GetPendingTransctionsResponse::Builder getGetPendingTransactions();
  inline void setGetPendingTransactions( ::koinos::rpc::mempool::GetPendingTransctionsResponse::Reader value);
  inline  ::koinos::rpc::mempool::GetPendingTransctionsResponse::Builder initGetPendingTransactions();
  inline void adoptGetPendingTransactions(::capnp::Orphan< ::koinos::rpc::mempool::GetPendingTransctionsResponse>&& value);
  inline ::capnp::Orphan< ::koinos::rpc::mempool::GetPendingTransctionsResponse> disownGetPendingTransactions();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MempoolRPCResponse::Pipeline {
public:
  typedef MempoolRPCResponse Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool CheckPendingAccountResourcesRequest::Reader::hasPayer() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CheckPendingAccountResourcesRequest::Builder::hasPayer() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader CheckPendingAccountResourcesRequest::Reader::getPayer() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder CheckPendingAccountResourcesRequest::Builder::getPayer() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CheckPendingAccountResourcesRequest::Builder::setPayer( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder CheckPendingAccountResourcesRequest::Builder::initPayer(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void CheckPendingAccountResourcesRequest::Builder::adoptPayer(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> CheckPendingAccountResourcesRequest::Builder::disownPayer() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t CheckPendingAccountResourcesRequest::Reader::getMaxPayerResources() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t CheckPendingAccountResourcesRequest::Builder::getMaxPayerResources() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CheckPendingAccountResourcesRequest::Builder::setMaxPayerResources( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t CheckPendingAccountResourcesRequest::Reader::getTrxResourceLimit() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t CheckPendingAccountResourcesRequest::Builder::getTrxResourceLimit() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void CheckPendingAccountResourcesRequest::Builder::setTrxResourceLimit( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t GetPendingTransactionsRequest::Reader::getLimit() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t GetPendingTransactionsRequest::Builder::getLimit() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void GetPendingTransactionsRequest::Builder::setLimit( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::koinos::rpc::mempool::MempoolRPCRequest::Which MempoolRPCRequest::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::koinos::rpc::mempool::MempoolRPCRequest::Which MempoolRPCRequest::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool MempoolRPCRequest::Reader::isMempoolReserved() const {
  return which() == MempoolRPCRequest::MEMPOOL_RESERVED;
}
inline bool MempoolRPCRequest::Builder::isMempoolReserved() {
  return which() == MempoolRPCRequest::MEMPOOL_RESERVED;
}
inline bool MempoolRPCRequest::Reader::hasMempoolReserved() const {
  if (which() != MempoolRPCRequest::MEMPOOL_RESERVED) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool MempoolRPCRequest::Builder::hasMempoolReserved() {
  if (which() != MempoolRPCRequest::MEMPOOL_RESERVED) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::koinos::rpc::mempool::MempoolReservedRequest::Reader MempoolRPCRequest::Reader::getMempoolReserved() const {
  KJ_IREQUIRE((which() == MempoolRPCRequest::MEMPOOL_RESERVED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::MempoolReservedRequest>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::koinos::rpc::mempool::MempoolReservedRequest::Builder MempoolRPCRequest::Builder::getMempoolReserved() {
  KJ_IREQUIRE((which() == MempoolRPCRequest::MEMPOOL_RESERVED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::MempoolReservedRequest>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MempoolRPCRequest::Builder::setMempoolReserved( ::koinos::rpc::mempool::MempoolReservedRequest::Reader value) {
  _builder.setDataField<MempoolRPCRequest::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCRequest::MEMPOOL_RESERVED);
  ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::MempoolReservedRequest>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::koinos::rpc::mempool::MempoolReservedRequest::Builder MempoolRPCRequest::Builder::initMempoolReserved() {
  _builder.setDataField<MempoolRPCRequest::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCRequest::MEMPOOL_RESERVED);
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::MempoolReservedRequest>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MempoolRPCRequest::Builder::adoptMempoolReserved(
    ::capnp::Orphan< ::koinos::rpc::mempool::MempoolReservedRequest>&& value) {
  _builder.setDataField<MempoolRPCRequest::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCRequest::MEMPOOL_RESERVED);
  ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::MempoolReservedRequest>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::koinos::rpc::mempool::MempoolReservedRequest> MempoolRPCRequest::Builder::disownMempoolReserved() {
  KJ_IREQUIRE((which() == MempoolRPCRequest::MEMPOOL_RESERVED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::MempoolReservedRequest>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool MempoolRPCRequest::Reader::isCheckPendingAccountResources() const {
  return which() == MempoolRPCRequest::CHECK_PENDING_ACCOUNT_RESOURCES;
}
inline bool MempoolRPCRequest::Builder::isCheckPendingAccountResources() {
  return which() == MempoolRPCRequest::CHECK_PENDING_ACCOUNT_RESOURCES;
}
inline bool MempoolRPCRequest::Reader::hasCheckPendingAccountResources() const {
  if (which() != MempoolRPCRequest::CHECK_PENDING_ACCOUNT_RESOURCES) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool MempoolRPCRequest::Builder::hasCheckPendingAccountResources() {
  if (which() != MempoolRPCRequest::CHECK_PENDING_ACCOUNT_RESOURCES) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::koinos::rpc::mempool::CheckPendingAccountResourcesRequest::Reader MempoolRPCRequest::Reader::getCheckPendingAccountResources() const {
  KJ_IREQUIRE((which() == MempoolRPCRequest::CHECK_PENDING_ACCOUNT_RESOURCES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::CheckPendingAccountResourcesRequest>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::koinos::rpc::mempool::CheckPendingAccountResourcesRequest::Builder MempoolRPCRequest::Builder::getCheckPendingAccountResources() {
  KJ_IREQUIRE((which() == MempoolRPCRequest::CHECK_PENDING_ACCOUNT_RESOURCES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::CheckPendingAccountResourcesRequest>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MempoolRPCRequest::Builder::setCheckPendingAccountResources( ::koinos::rpc::mempool::CheckPendingAccountResourcesRequest::Reader value) {
  _builder.setDataField<MempoolRPCRequest::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCRequest::CHECK_PENDING_ACCOUNT_RESOURCES);
  ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::CheckPendingAccountResourcesRequest>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::koinos::rpc::mempool::CheckPendingAccountResourcesRequest::Builder MempoolRPCRequest::Builder::initCheckPendingAccountResources() {
  _builder.setDataField<MempoolRPCRequest::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCRequest::CHECK_PENDING_ACCOUNT_RESOURCES);
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::CheckPendingAccountResourcesRequest>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MempoolRPCRequest::Builder::adoptCheckPendingAccountResources(
    ::capnp::Orphan< ::koinos::rpc::mempool::CheckPendingAccountResourcesRequest>&& value) {
  _builder.setDataField<MempoolRPCRequest::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCRequest::CHECK_PENDING_ACCOUNT_RESOURCES);
  ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::CheckPendingAccountResourcesRequest>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::koinos::rpc::mempool::CheckPendingAccountResourcesRequest> MempoolRPCRequest::Builder::disownCheckPendingAccountResources() {
  KJ_IREQUIRE((which() == MempoolRPCRequest::CHECK_PENDING_ACCOUNT_RESOURCES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::CheckPendingAccountResourcesRequest>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool MempoolRPCRequest::Reader::isGetPendingTransactions() const {
  return which() == MempoolRPCRequest::GET_PENDING_TRANSACTIONS;
}
inline bool MempoolRPCRequest::Builder::isGetPendingTransactions() {
  return which() == MempoolRPCRequest::GET_PENDING_TRANSACTIONS;
}
inline bool MempoolRPCRequest::Reader::hasGetPendingTransactions() const {
  if (which() != MempoolRPCRequest::GET_PENDING_TRANSACTIONS) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool MempoolRPCRequest::Builder::hasGetPendingTransactions() {
  if (which() != MempoolRPCRequest::GET_PENDING_TRANSACTIONS) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::koinos::rpc::mempool::GetPendingTransactionsRequest::Reader MempoolRPCRequest::Reader::getGetPendingTransactions() const {
  KJ_IREQUIRE((which() == MempoolRPCRequest::GET_PENDING_TRANSACTIONS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::GetPendingTransactionsRequest>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::koinos::rpc::mempool::GetPendingTransactionsRequest::Builder MempoolRPCRequest::Builder::getGetPendingTransactions() {
  KJ_IREQUIRE((which() == MempoolRPCRequest::GET_PENDING_TRANSACTIONS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::GetPendingTransactionsRequest>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MempoolRPCRequest::Builder::setGetPendingTransactions( ::koinos::rpc::mempool::GetPendingTransactionsRequest::Reader value) {
  _builder.setDataField<MempoolRPCRequest::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCRequest::GET_PENDING_TRANSACTIONS);
  ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::GetPendingTransactionsRequest>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::koinos::rpc::mempool::GetPendingTransactionsRequest::Builder MempoolRPCRequest::Builder::initGetPendingTransactions() {
  _builder.setDataField<MempoolRPCRequest::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCRequest::GET_PENDING_TRANSACTIONS);
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::GetPendingTransactionsRequest>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MempoolRPCRequest::Builder::adoptGetPendingTransactions(
    ::capnp::Orphan< ::koinos::rpc::mempool::GetPendingTransactionsRequest>&& value) {
  _builder.setDataField<MempoolRPCRequest::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCRequest::GET_PENDING_TRANSACTIONS);
  ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::GetPendingTransactionsRequest>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::koinos::rpc::mempool::GetPendingTransactionsRequest> MempoolRPCRequest::Builder::disownGetPendingTransactions() {
  KJ_IREQUIRE((which() == MempoolRPCRequest::GET_PENDING_TRANSACTIONS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::GetPendingTransactionsRequest>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CheckPendingAccountResourcesResponse::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool CheckPendingAccountResourcesResponse::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CheckPendingAccountResourcesResponse::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool GetPendingTransctionsResponse::Reader::hasTransactions() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GetPendingTransctionsResponse::Builder::hasTransactions() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::koinos::protocol::Transaction,  ::capnp::Kind::STRUCT>::Reader GetPendingTransctionsResponse::Reader::getTransactions() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::koinos::protocol::Transaction,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::koinos::protocol::Transaction,  ::capnp::Kind::STRUCT>::Builder GetPendingTransctionsResponse::Builder::getTransactions() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::koinos::protocol::Transaction,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GetPendingTransctionsResponse::Builder::setTransactions( ::capnp::List< ::koinos::protocol::Transaction,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::koinos::protocol::Transaction,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::koinos::protocol::Transaction,  ::capnp::Kind::STRUCT>::Builder GetPendingTransctionsResponse::Builder::initTransactions(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::koinos::protocol::Transaction,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void GetPendingTransctionsResponse::Builder::adoptTransactions(
    ::capnp::Orphan< ::capnp::List< ::koinos::protocol::Transaction,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::koinos::protocol::Transaction,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::koinos::protocol::Transaction,  ::capnp::Kind::STRUCT>> GetPendingTransctionsResponse::Builder::disownTransactions() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::koinos::protocol::Transaction,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::koinos::rpc::mempool::MempoolRPCResponse::Which MempoolRPCResponse::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::koinos::rpc::mempool::MempoolRPCResponse::Which MempoolRPCResponse::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool MempoolRPCResponse::Reader::isMempoolReserved() const {
  return which() == MempoolRPCResponse::MEMPOOL_RESERVED;
}
inline bool MempoolRPCResponse::Builder::isMempoolReserved() {
  return which() == MempoolRPCResponse::MEMPOOL_RESERVED;
}
inline bool MempoolRPCResponse::Reader::hasMempoolReserved() const {
  if (which() != MempoolRPCResponse::MEMPOOL_RESERVED) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool MempoolRPCResponse::Builder::hasMempoolReserved() {
  if (which() != MempoolRPCResponse::MEMPOOL_RESERVED) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::koinos::rpc::mempool::MempoolReservedResponse::Reader MempoolRPCResponse::Reader::getMempoolReserved() const {
  KJ_IREQUIRE((which() == MempoolRPCResponse::MEMPOOL_RESERVED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::MempoolReservedResponse>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::koinos::rpc::mempool::MempoolReservedResponse::Builder MempoolRPCResponse::Builder::getMempoolReserved() {
  KJ_IREQUIRE((which() == MempoolRPCResponse::MEMPOOL_RESERVED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::MempoolReservedResponse>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MempoolRPCResponse::Builder::setMempoolReserved( ::koinos::rpc::mempool::MempoolReservedResponse::Reader value) {
  _builder.setDataField<MempoolRPCResponse::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCResponse::MEMPOOL_RESERVED);
  ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::MempoolReservedResponse>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::koinos::rpc::mempool::MempoolReservedResponse::Builder MempoolRPCResponse::Builder::initMempoolReserved() {
  _builder.setDataField<MempoolRPCResponse::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCResponse::MEMPOOL_RESERVED);
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::MempoolReservedResponse>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MempoolRPCResponse::Builder::adoptMempoolReserved(
    ::capnp::Orphan< ::koinos::rpc::mempool::MempoolReservedResponse>&& value) {
  _builder.setDataField<MempoolRPCResponse::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCResponse::MEMPOOL_RESERVED);
  ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::MempoolReservedResponse>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::koinos::rpc::mempool::MempoolReservedResponse> MempoolRPCResponse::Builder::disownMempoolReserved() {
  KJ_IREQUIRE((which() == MempoolRPCResponse::MEMPOOL_RESERVED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::MempoolReservedResponse>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool MempoolRPCResponse::Reader::isMempoolError() const {
  return which() == MempoolRPCResponse::MEMPOOL_ERROR;
}
inline bool MempoolRPCResponse::Builder::isMempoolError() {
  return which() == MempoolRPCResponse::MEMPOOL_ERROR;
}
inline bool MempoolRPCResponse::Reader::hasMempoolError() const {
  if (which() != MempoolRPCResponse::MEMPOOL_ERROR) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool MempoolRPCResponse::Builder::hasMempoolError() {
  if (which() != MempoolRPCResponse::MEMPOOL_ERROR) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::koinos::rpc::ErrorResponse::Reader MempoolRPCResponse::Reader::getMempoolError() const {
  KJ_IREQUIRE((which() == MempoolRPCResponse::MEMPOOL_ERROR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::ErrorResponse>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::koinos::rpc::ErrorResponse::Builder MempoolRPCResponse::Builder::getMempoolError() {
  KJ_IREQUIRE((which() == MempoolRPCResponse::MEMPOOL_ERROR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::ErrorResponse>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MempoolRPCResponse::Builder::setMempoolError( ::koinos::rpc::ErrorResponse::Reader value) {
  _builder.setDataField<MempoolRPCResponse::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCResponse::MEMPOOL_ERROR);
  ::capnp::_::PointerHelpers< ::koinos::rpc::ErrorResponse>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::koinos::rpc::ErrorResponse::Builder MempoolRPCResponse::Builder::initMempoolError() {
  _builder.setDataField<MempoolRPCResponse::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCResponse::MEMPOOL_ERROR);
  return ::capnp::_::PointerHelpers< ::koinos::rpc::ErrorResponse>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MempoolRPCResponse::Builder::adoptMempoolError(
    ::capnp::Orphan< ::koinos::rpc::ErrorResponse>&& value) {
  _builder.setDataField<MempoolRPCResponse::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCResponse::MEMPOOL_ERROR);
  ::capnp::_::PointerHelpers< ::koinos::rpc::ErrorResponse>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::koinos::rpc::ErrorResponse> MempoolRPCResponse::Builder::disownMempoolError() {
  KJ_IREQUIRE((which() == MempoolRPCResponse::MEMPOOL_ERROR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::ErrorResponse>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool MempoolRPCResponse::Reader::isCheckPendingAccountResources() const {
  return which() == MempoolRPCResponse::CHECK_PENDING_ACCOUNT_RESOURCES;
}
inline bool MempoolRPCResponse::Builder::isCheckPendingAccountResources() {
  return which() == MempoolRPCResponse::CHECK_PENDING_ACCOUNT_RESOURCES;
}
inline bool MempoolRPCResponse::Reader::hasCheckPendingAccountResources() const {
  if (which() != MempoolRPCResponse::CHECK_PENDING_ACCOUNT_RESOURCES) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool MempoolRPCResponse::Builder::hasCheckPendingAccountResources() {
  if (which() != MempoolRPCResponse::CHECK_PENDING_ACCOUNT_RESOURCES) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::koinos::rpc::mempool::CheckPendingAccountResourcesResponse::Reader MempoolRPCResponse::Reader::getCheckPendingAccountResources() const {
  KJ_IREQUIRE((which() == MempoolRPCResponse::CHECK_PENDING_ACCOUNT_RESOURCES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::CheckPendingAccountResourcesResponse>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::koinos::rpc::mempool::CheckPendingAccountResourcesResponse::Builder MempoolRPCResponse::Builder::getCheckPendingAccountResources() {
  KJ_IREQUIRE((which() == MempoolRPCResponse::CHECK_PENDING_ACCOUNT_RESOURCES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::CheckPendingAccountResourcesResponse>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MempoolRPCResponse::Builder::setCheckPendingAccountResources( ::koinos::rpc::mempool::CheckPendingAccountResourcesResponse::Reader value) {
  _builder.setDataField<MempoolRPCResponse::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCResponse::CHECK_PENDING_ACCOUNT_RESOURCES);
  ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::CheckPendingAccountResourcesResponse>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::koinos::rpc::mempool::CheckPendingAccountResourcesResponse::Builder MempoolRPCResponse::Builder::initCheckPendingAccountResources() {
  _builder.setDataField<MempoolRPCResponse::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCResponse::CHECK_PENDING_ACCOUNT_RESOURCES);
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::CheckPendingAccountResourcesResponse>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MempoolRPCResponse::Builder::adoptCheckPendingAccountResources(
    ::capnp::Orphan< ::koinos::rpc::mempool::CheckPendingAccountResourcesResponse>&& value) {
  _builder.setDataField<MempoolRPCResponse::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCResponse::CHECK_PENDING_ACCOUNT_RESOURCES);
  ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::CheckPendingAccountResourcesResponse>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::koinos::rpc::mempool::CheckPendingAccountResourcesResponse> MempoolRPCResponse::Builder::disownCheckPendingAccountResources() {
  KJ_IREQUIRE((which() == MempoolRPCResponse::CHECK_PENDING_ACCOUNT_RESOURCES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::CheckPendingAccountResourcesResponse>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool MempoolRPCResponse::Reader::isGetPendingTransactions() const {
  return which() == MempoolRPCResponse::GET_PENDING_TRANSACTIONS;
}
inline bool MempoolRPCResponse::Builder::isGetPendingTransactions() {
  return which() == MempoolRPCResponse::GET_PENDING_TRANSACTIONS;
}
inline bool MempoolRPCResponse::Reader::hasGetPendingTransactions() const {
  if (which() != MempoolRPCResponse::GET_PENDING_TRANSACTIONS) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool MempoolRPCResponse::Builder::hasGetPendingTransactions() {
  if (which() != MempoolRPCResponse::GET_PENDING_TRANSACTIONS) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::koinos::rpc::mempool::GetPendingTransctionsResponse::Reader MempoolRPCResponse::Reader::getGetPendingTransactions() const {
  KJ_IREQUIRE((which() == MempoolRPCResponse::GET_PENDING_TRANSACTIONS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::GetPendingTransctionsResponse>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::koinos::rpc::mempool::GetPendingTransctionsResponse::Builder MempoolRPCResponse::Builder::getGetPendingTransactions() {
  KJ_IREQUIRE((which() == MempoolRPCResponse::GET_PENDING_TRANSACTIONS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::GetPendingTransctionsResponse>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MempoolRPCResponse::Builder::setGetPendingTransactions( ::koinos::rpc::mempool::GetPendingTransctionsResponse::Reader value) {
  _builder.setDataField<MempoolRPCResponse::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCResponse::GET_PENDING_TRANSACTIONS);
  ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::GetPendingTransctionsResponse>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::koinos::rpc::mempool::GetPendingTransctionsResponse::Builder MempoolRPCResponse::Builder::initGetPendingTransactions() {
  _builder.setDataField<MempoolRPCResponse::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCResponse::GET_PENDING_TRANSACTIONS);
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::GetPendingTransctionsResponse>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MempoolRPCResponse::Builder::adoptGetPendingTransactions(
    ::capnp::Orphan< ::koinos::rpc::mempool::GetPendingTransctionsResponse>&& value) {
  _builder.setDataField<MempoolRPCResponse::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MempoolRPCResponse::GET_PENDING_TRANSACTIONS);
  ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::GetPendingTransctionsResponse>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::koinos::rpc::mempool::GetPendingTransctionsResponse> MempoolRPCResponse::Builder::disownGetPendingTransactions() {
  KJ_IREQUIRE((which() == MempoolRPCResponse::GET_PENDING_TRANSACTIONS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::koinos::rpc::mempool::GetPendingTransctionsResponse>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace
}  // namespace

